Directory structure:
└── wilcoxadvisors-wilcox-advisors.git/
    ├── package.json
    ├── client/
    │   ├── jsconfig.json
    │   ├── package.json
    │   ├── postcss.config.js
    │   ├── tailwind.config.js
    │   ├── public/
    │   │   ├── _redirects
    │   │   ├── index.html
    │   │   └── site.webmanifest
    │   └── src/
    │       ├── App.jsx
    │       ├── index.css
    │       ├── index.js
    │       ├── components/
    │       │   ├── AdminDashboard.jsx
    │       │   ├── ClientDashboard.jsx
    │       │   ├── ConsultationFormModal.jsx
    │       │   ├── Footer.jsx
    │       │   ├── Header.jsx
    │       │   ├── LoginModal.jsx
    │       │   ├── MainContent.jsx
    │       │   ├── ManualJournalEntry.jsx
    │       │   ├── ProtectedRoutes.jsx
    │       │   ├── Sidebar.jsx
    │       │   ├── TabNavigation.jsx
    │       │   ├── WebsiteContentManager.jsx
    │       │   ├── accounting/
    │       │   │   ├── ChartOfAccountsManager.jsx
    │       │   │   └── FixedAssetManager.jsx
    │       │   ├── common/
    │       │   │   └── ChatWidget.jsx
    │       │   ├── dashboard/
    │       │   │   ├── CashFlowChart.jsx
    │       │   │   ├── ClientChat.jsx
    │       │   │   ├── CustomReports.jsx
    │       │   │   ├── DownloadSection.jsx
    │       │   │   ├── FileUpload.jsx
    │       │   │   ├── FinancialOverview.jsx
    │       │   │   └── GeneralLedger.jsx
    │       │   ├── form/
    │       │   │   ├── CompanyInformationStep.jsx
    │       │   │   ├── FormNavigation.jsx
    │       │   │   ├── FormProgress.jsx
    │       │   │   └── ServicesSelectionStep.jsx
    │       │   ├── journal/
    │       │   │   ├── ActionButtons.jsx
    │       │   │   ├── JournalEntriesTable.jsx
    │       │   │   ├── JournalEntryRow.jsx
    │       │   │   ├── JournalHeader.jsx
    │       │   │   └── SupportingDocuments.jsx
    │       │   ├── modals/
    │       │   │   └── ChecklistModal.jsx
    │       │   ├── sections/
    │       │   │   ├── AboutSection.jsx
    │       │   │   ├── BlogSection.jsx
    │       │   │   ├── ChecklistSection.jsx
    │       │   │   ├── ContactSection.jsx
    │       │   │   ├── HeroSection.jsx
    │       │   │   ├── ServicesSection.jsx
    │       │   │   └── TestimonialsSection.jsx
    │       │   └── website/
    │       │       ├── AboutTab.jsx
    │       │       ├── ContactTab.jsx
    │       │       ├── GeneralTab.jsx
    │       │       ├── HomePageTab.jsx
    │       │       ├── LearnMoreTab.jsx
    │       │       └── ServicesTab.jsx
    │       ├── contexts/
    │       │   ├── AuthContext.js
    │       │   └── UIContext.js
    │       ├── hooks/
    │       │   ├── useFormData.js
    │       │   ├── useJournalEntryForm.js
    │       │   └── useMultiStepForm.js
    │       ├── pages/
    │       │   ├── Home.jsx
    │       │   └── LearnMore.jsx
    │       └── utils/
    │           ├── api.js
    │           └── csrf.js
    └── server/
        ├── accountService.js
        ├── index.js
        ├── package.json
        ├── config/
        │   └── database.js
        ├── controllers/
        │   ├── accountController.js
        │   ├── chartOfAccountsController.js
        │   ├── entityController.js
        │   ├── journalEntryController.js
        │   └── reportController.js
        ├── middleware/
        │   ├── auth.js
        │   ├── errorHandler.js
        │   └── requestValidator.js
        ├── models/
        │   ├── account.js
        │   ├── auditLog.js
        │   ├── blog.js
        │   ├── budget.js
        │   ├── cashFlowForecast.js
        │   ├── chartOfAccounts.js
        │   ├── chat.js
        │   ├── checklist.js
        │   ├── consolidation.js
        │   ├── consultation.js
        │   ├── contact.js
        │   ├── content.js
        │   ├── entity.js
        │   ├── entityGroup.js
        │   ├── file.js
        │   ├── fixedAsset.js
        │   ├── invoice.js
        │   ├── journalEntry.js
        │   ├── payrollEntry.js
        │   ├── report.js
        │   ├── transaction.js
        │   ├── user.js
        │   └── vendor.js
        ├── routes/
        │   ├── accounting.js
        │   ├── accounts.js
        │   ├── admin.js
        │   ├── auth.js
        │   ├── blog.js
        │   ├── chartOfAccounts.js
        │   ├── chat.js
        │   ├── checklists.js
        │   ├── client.js
        │   ├── consultations.js
        │   ├── contacts.js
        │   ├── entities.js
        │   ├── files.js
        │   ├── index.js
        │   ├── journalEntries.js
        │   └── reports.js
        ├── utils/
        │   ├── api.js
        │   ├── emailService.js
        │   └── logger.js
        └── validators/
            ├── accountValidator.js
            ├── entityValidator.js
            └── journalEntryValidator.js

================================================
File: package.json
================================================
{
  "name": "wilcox-advisors",
  "private": true,
  "workspaces": [
    "client",
    "server",
    "shared"
  ],
  "scripts": {
    "start": "concurrently \"npm run start:server\" \"npm run start:client\"",
    "start:client": "npm start --workspace=client",
    "start:server": "npm start --workspace=server",
    "build": "npm run build --workspace=client",
    "test": "npm run test --workspace=client && npm run test --workspace=server",
    "deploy": "npm run build && npm run deploy:server"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  }
}



================================================
File: client/jsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": "src"
  }
}



================================================
File: client/package.json
================================================
{
  "name": "wilcox-advisors-frontend",
  "version": "1.0.0",
  "dependencies": {
    "axios": "^1.6.7",
    "chart.js": "^4.4.1",
    "lucide-react": "^0.344.0",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.2.0",
    "react-quill": "^2.0.0",
    "web-vitals": "^3.5.2",
    "react-router-dom": "^6.22.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "lint": "eslint src/**/*.js",
    "format": "prettier --write src/**/*.js"
  },
  "devDependencies": {
    "react-scripts": "5.0.1",
    "tailwindcss": "^3.4.3",
    "postcss": "^8.4.38",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.0.0",
    "prettier": "^2.0.0"
  }
}



================================================
File: client/postcss.config.js
================================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};



================================================
File: client/tailwind.config.js
================================================
module.exports = {
  content: [
    './src/**/*.{js,jsx}',
    './src/pages/**/*.{js,jsx}', // Ensure this is included
  ],
  theme: { extend: {} },
  plugins: [],
};



================================================
File: client/public/_redirects
================================================
/*    /index.html   200



================================================
File: client/public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Wilcox Advisors - Financial Solutions for Small Businesses" />
    <title>Wilcox Advisors</title>
    <link rel="apple-touch-icon" sizes="180x180" href="%PUBLIC_URL%/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="%PUBLIC_URL%/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="%PUBLIC_URL%/favicon-16x16.png">
    <link rel="manifest" href="%PUBLIC_URL%/site.webmanifest">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>



================================================
File: client/public/site.webmanifest
================================================
{
  "name": "Wilcox Advisors",
  "short_name": "Wilcox Advisors",
  "icons": [
    {
      "src": "favicon-16x16.png",
      "sizes": "16x16",
      "type": "image/png"
    },
    {
      "src": "favicon-32x32.png",
      "sizes": "32x32",
      "type": "image/png"
    },
    {
      "src": "apple-touch-icon.png",
      "sizes": "180x180",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#1E3A8A",
  "background_color": "#ffffff"
}



================================================
File: client/src/App.jsx
================================================
// src/App.jsx
import React, { useState } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Header from './components/Header';
import Footer from './components/Footer';
import Home from './pages/Home';
import LearnMore from './pages/LearnMore';
import AdminDashboard from './components/AdminDashboard';
import ClientDashboard from './components/ClientDashboard';
import LoginModal from './components/LoginModal';
import ConsultationFormModal from './components/ConsultationFormModal';
import { AdminProtectedRoute, ClientProtectedRoute } from './components/ProtectedRoutes';
import { AuthProvider } from './contexts/AuthContext';
import { UIProvider } from './contexts/UIContext';

function App() {
  const [showLogin, setShowLogin] = useState(false);
  const [showConsultationForm, setShowConsultationForm] = useState(false);

  return (
    <AuthProvider>
      <UIProvider>
        <Router>
          <div className="min-h-screen bg-gray-50">
            <Header
              setShowLoginModal={setShowLogin}
            />
            <Routes>
              <Route path="/" element={<Home setShowConsultationForm={setShowConsultationForm} />} />
              <Route path="/learn-more" element={<LearnMore />} />
              <Route path="/admin-dashboard" element={
                <AdminProtectedRoute>
                  <AdminDashboard />
                </AdminProtectedRoute>
              } />
              <Route path="/client-dashboard" element={
                <ClientProtectedRoute>
                  <ClientDashboard />
                </ClientProtectedRoute>
              } />
            </Routes>
            <Footer />
            {showLogin && 
              <LoginModal 
                setShowLoginModal={setShowLogin} 
              />
            }
            {showConsultationForm && <ConsultationFormModal setShowConsultationForm={setShowConsultationForm} />}
          </div>
        </Router>
      </UIProvider>
    </AuthProvider>
  );
}

export default App;



================================================
File: client/src/index.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #ffffff;
  line-height: 1.6;
  color: #333;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}



================================================
File: client/src/index.js
================================================
import React, { useState, lazy, Suspense } from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Header from './components/Header'; // Header component
import Footer from './components/Footer'; // Footer component
import ConsultationFormModal from './components/ConsultationFormModal'; // Consultation form modal component
import LoginModal from './components/LoginModal'; // Login modal component
import { UIProvider } from './contexts/UIContext'; // Import UIProvider
import { AuthProvider } from './contexts/AuthContext'; // Import AuthProvider
import './index.css'; // Global styles (assumed to exist)

// Lazy load components
const Home = lazy(() => import('./pages/Home'));
const LearnMore = lazy(() => import('./pages/LearnMore'));
const AdminDashboard = lazy(() => import('./components/AdminDashboard'));
const ClientDashboard = lazy(() => import('./components/ClientDashboard'));
const AdminProtectedRoute = lazy(() => import('./components/ProtectedRoutes').then(module => ({ default: module.AdminProtectedRoute })));
const ClientProtectedRoute = lazy(() => import('./components/ProtectedRoutes').then(module => ({ default: module.ClientProtectedRoute })));

// Wrapper component to manage modal states
function App() {
  const [showConsultationForm, setShowConsultationForm] = useState(false);
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [isLoggedIn, setIsLoggedIn] = useState(localStorage.getItem('token') !== null);
  const [isAdmin, setIsAdmin] = useState(localStorage.getItem('isAdmin') === 'true');

  const handleLogout = () => {
    localStorage.removeItem('token');
    localStorage.removeItem('isAdmin');
    setIsLoggedIn(false);
    setIsAdmin(false);
  };

  return (
    <Router>
      {/* Pass both modal setters to Header for triggering the modals */}
      <Header 
        setShowConsultationForm={setShowConsultationForm} 
        setShowLoginModal={setShowLoginModal}
        isLoggedIn={isLoggedIn}
        isAdmin={isAdmin}
        handleLogout={handleLogout}
      />
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          {/* Home page route with consultation form trigger */}
          <Route
            path="/"
            element={<Home setShowConsultationForm={setShowConsultationForm} />}
          />
          {/* Learn More page route */}
          <Route path="/learn-more" element={<LearnMore />} />
          {/* Protected Admin Dashboard route */}
          <Route
            path="/admin-dashboard"
            element={
              <AdminProtectedRoute>
                <AdminDashboard />
              </AdminProtectedRoute>
            }
          />
          {/* Protected Client Dashboard route */}
          <Route
            path="/client-dashboard"
            element={
              <ClientProtectedRoute>
                <ClientDashboard />
              </ClientProtectedRoute>
            }
          />
        </Routes>
      </Suspense>
      <Footer />
      {/* Render the modals conditionally */}
      {showConsultationForm && (
        <ConsultationFormModal setShowConsultationForm={setShowConsultationForm} />
      )}
      {showLoginModal && (
        <LoginModal 
          setShowLoginModal={setShowLoginModal} 
          setIsLoggedIn={setIsLoggedIn}
          setIsAdmin={setIsAdmin}
        />
      )}
    </Router>
  );
}

ReactDOM.render(
  <React.StrictMode>
    <AuthProvider>
      <UIProvider>
        <App />
      </UIProvider>
    </AuthProvider>
  </React.StrictMode>,
  document.getElementById('root') // Renders the app into the DOM element with id="root" in index.html
);



================================================
File: client/src/components/AdminDashboard.jsx
================================================
// src/components/AdminDashboard.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
import { 
  Home, Users, FileText, Database, FileSpreadsheet, Settings, Globe, 
  Upload, Image, Layout, Edit, Info, Bookmark, Phone, Save, CheckCircle, 
  LogOut, PlusCircle 
} from 'lucide-react';
import Sidebar from './Sidebar';
import WebsiteContentManager from './WebsiteContentManager';

function AdminDashboard() {
  const [activeModule, setActiveModule] = useState('dashboard');
  const [dashboardData, setDashboardData] = useState({
    blogDrafts: [],
    hero: { headline: '', subtext: '' },
    about: '',
    stats: {
      consultations: 0,
      checklists: 0,
      contacts: 0,
      chats: 0,
      files: 0
    }
  });
  const [editingBlog, setEditingBlog] = useState(null);
  const [editingContent, setEditingContent] = useState(null);
  const [logoFile, setLogoFile] = useState(null);
  const [saved, setSaved] = useState(false);
  const [activeTab, setActiveTab] = useState('general');
  const navigate = useNavigate();
  
  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    const token = localStorage.getItem('token');
    try {
      const response = await axios.get(`${process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com'}/api/admin/dashboard`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      setDashboardData(response.data);
    } catch (error) {
      console.error('Failed to fetch dashboard data:', error);
    }
  };

  const handleBlogEdit = (draft) => setEditingBlog({ ...draft });

  const handleBlogSave = async () => {
    try {
      const token = localStorage.getItem('token');
      if (editingBlog._id) {
        await axios.put(`${process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com'}/api/blog/${editingBlog._id}`, editingBlog, {
          headers: { Authorization: `Bearer ${token}` },
        });
      } else {
        await axios.post(`${process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com'}/api/blog`, editingBlog, {
          headers: { Authorization: `Bearer ${token}` },
        });
      }
      setEditingBlog(null);
      fetchDashboardData();
      alert('Blog post saved!');
    } catch (error) {
      alert('Failed to save blog post.');
    }
  };

  const handleContentEdit = (section) => setEditingContent({ section, value: dashboardData[section] });

  const handleContentSave = async () => {
    try {
      const token = localStorage.getItem('token');
      await axios.post(`${process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com'}/api/admin/content`, editingContent, {
        headers: { Authorization: `Bearer ${token}` },
      });
      setDashboardData(prev => ({ ...prev, [editingContent.section]: editingContent.value }));
      setEditingContent(null);
      alert('Content saved!');
    } catch (error) {
      alert('Failed to save content.');
    }
  };
  
  const handleLogoChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setLogoFile(URL.createObjectURL(e.target.files[0]));
    }
  };
  
  const handleWebsiteSave = () => {
    setSaved(true);
    // In a real implementation, save data to backend here
    setTimeout(() => setSaved(false), 3000);
  };

  const renderModule = () => {
    switch(activeModule) {
      case 'dashboard':
        return (
          <section className="py-16 px-6">
            <h2 className="text-3xl font-bold text-blue-800 mb-10">Admin Dashboard</h2>
            <div className="bg-white p-6 rounded-lg shadow-md space-y-8">
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">Overview</h3>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div className="bg-blue-50 p-4 rounded-lg">
                    <p className="text-sm text-gray-600">Total Consultations</p>
                    <p className="text-2xl font-bold text-blue-800">{dashboardData.stats?.consultations || 0}</p>
                  </div>
                  <div className="bg-green-50 p-4 rounded-lg">
                    <p className="text-sm text-gray-600">Checklist Downloads</p>
                    <p className="text-2xl font-bold text-green-700">{dashboardData.stats?.checklists || 0}</p>
                  </div>
                  <div className="bg-purple-50 p-4 rounded-lg">
                    <p className="text-sm text-gray-600">Contact Requests</p>
                    <p className="text-2xl font-bold text-purple-700">{dashboardData.stats?.contacts || 0}</p>
                  </div>
                </div>
              </div>
              
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">Quick Links</h3>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <button 
                    onClick={() => setActiveModule('blogs')}
                    className="bg-blue-100 text-blue-800 p-4 rounded-lg hover:bg-blue-200"
                  >
                    Manage Blog Posts
                  </button>
                  <button 
                    onClick={() => setActiveModule('website')}
                    className="bg-blue-100 text-blue-800 p-4 rounded-lg hover:bg-blue-200"
                  >
                    Edit Website Content
                  </button>
                  <button 
                    onClick={() => setActiveModule('accounting')}
                    className="bg-blue-100 text-blue-800 p-4 rounded-lg hover:bg-blue-200"
                  >
                    Accounting System
                  </button>
                </div>
              </div>
              
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">Recent Activity</h3>
                <div className="bg-gray-50 p-4 rounded-lg">
                  <p className="text-gray-600">No recent activity to display.</p>
                </div>
              </div>
            </div>
          </section>
        );
      
      case 'blogs':
        return (
          <section className="py-16 px-6">
            <h2 className="text-3xl font-bold text-blue-800 mb-10">Blog Management</h2>
            <div className="bg-white p-6 rounded-lg shadow-md space-y-8">
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">Blog Posts</h3>
                {editingBlog ? (
                  <div>
                    <input
                      type="text"
                      value={editingBlog.title}
                      onChange={(e) => setEditingBlog({ ...editingBlog, title: e.target.value })}
                      className="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 mb-2 border p-2"
                      placeholder="Blog Title"
                    />
                    <ReactQuill 
                      value={editingBlog.content} 
                      onChange={(content) => setEditingBlog({ ...editingBlog, content })} 
                      className="mb-4" 
                    />
                    <div className="flex space-x-4">
                      <button 
                        onClick={handleBlogSave} 
                        className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 transition duration-200"
                      >
                        Save Post
                      </button>
                      <button 
                        onClick={() => setEditingBlog(null)} 
                        className="text-gray-700 hover:text-blue-800"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                ) : (
                  <div className="space-y-4">
                    {dashboardData.blogDrafts && dashboardData.blogDrafts.map((draft, index) => (
                      <div key={index} className="bg-gray-50 p-4 rounded-lg shadow-sm">
                        <h4 className="font-semibold text-gray-900">{draft.title}</h4>
                        <div dangerouslySetInnerHTML={{ __html: draft.content.substring(0, 100) + '...' }} />
                        <div className="mt-2 flex space-x-2">
                          <button 
                            onClick={() => handleBlogEdit(draft)} 
                            className="text-blue-800 hover:underline"
                          >
                            Edit
                          </button>
                          <button 
                            className="text-red-600 hover:underline"
                          >
                            Delete
                          </button>
                        </div>
                      </div>
                    ))}
                    <button 
                      onClick={() => setEditingBlog({ title: '', content: '' })} 
                      className="flex items-center text-blue-800 hover:underline mt-4"
                    >
                      <PlusCircle size={16} className="mr-1" /> Add New Blog Post
                    </button>
                  </div>
                )}
              </div>
            </div>
          </section>
        );
      
      case 'accounting':
        return (
          <section className="py-10 px-6">
            <h2 className="text-3xl font-bold text-blue-800 mb-6">Accounting System</h2>
            
            {/* Client Selector */}
            <div className="bg-white p-4 rounded-lg shadow-md mb-6">
              <label className="block text-sm font-medium text-gray-700 mb-2">Select Client</label>
              <select className="w-full p-2 border rounded focus:ring-blue-500 focus:border-blue-500">
                <option value="">-- Select a Client --</option>
                <option value="client1">Acme Corporation</option>
                <option value="client2">Globex Industries</option>
                <option value="client3">Stark Enterprises</option>
                <option value="client4">Wayne Industries</option>
              </select>
            </div>
            
            {/* Accounting Features */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="bg-blue-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">General Ledger (GL)</h3>
                <p className="text-gray-700 mb-3">Manage journal entries and multi-currency/entity support.</p>
                <button className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900">
                  Access GL Module
                </button>
              </div>
              
              <div className="bg-green-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">Accounts Payable/Receivable</h3>
                <p className="text-gray-700 mb-3">Manage invoices, bills, and payments.</p>
                <button className="bg-green-700 text-white px-4 py-2 rounded hover:bg-green-800">
                  Access AP/AR Module
                </button>
              </div>
              
              <div className="bg-purple-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">Financial Reporting</h3>
                <p className="text-gray-700 mb-3">Generate financial statements and dashboards.</p>
                <button className="bg-purple-700 text-white px-4 py-2 rounded hover:bg-purple-800">
                  Access Reporting
                </button>
              </div>
              
              <div className="bg-yellow-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">Budgeting/Forecasting</h3>
                <p className="text-gray-700 mb-3">Create and track budgets and forecasts.</p>
                <button className="bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700">
                  Access Budgeting
                </button>
              </div>
              
              <div className="bg-red-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">Inventory/Supply Chain</h3>
                <p className="text-gray-700 mb-3">Manage inventory and supply chain operations.</p>
                <button className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">
                  Access Inventory
                </button>
              </div>
              
              <div className="bg-indigo-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">Automation</h3>
                <p className="text-gray-700 mb-3">Automate journal entries and bank reconciliation.</p>
                <button className="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">
                  Access Automation
                </button>
              </div>
              
              <div className="bg-gray-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">Compliance/Audit</h3>
                <p className="text-gray-700 mb-3">Manage audit trails and compliance documentation.</p>
                <button className="bg-gray-700 text-white px-4 py-2 rounded hover:bg-gray-800">
                  Access Compliance
                </button>
              </div>
              
              <div className="bg-teal-50 p-4 rounded-lg shadow-md">
                <h3 className="text-lg font-semibold mb-2">Integration</h3>
                <p className="text-gray-700 mb-3">Connect with external APIs (Plaid, Stripe, etc.).</p>
                <button className="bg-teal-700 text-white px-4 py-2 rounded hover:bg-teal-800">
                  Manage Integrations
                </button>
              </div>
            </div>
            
            {/* Multi-Entity/Currency Settings */}
            <div className="mt-6 bg-white p-4 rounded-lg shadow-md">
              <h3 className="text-lg font-semibold mb-4">Advanced Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <h4 className="font-medium mb-2">Multi-Entity Support</h4>
                  <button className="bg-blue-100 text-blue-800 px-4 py-2 rounded hover:bg-blue-200">
                    Manage Entities
                  </button>
                </div>
                <div>
                  <h4 className="font-medium mb-2">Multi-Currency Support</h4>
                  <button className="bg-blue-100 text-blue-800 px-4 py-2 rounded hover:bg-blue-200">
                    Manage Currencies
                  </button>
                </div>
              </div>
            </div>
          </section>
        );
      
      case 'website':
        return <WebsiteContentManager />;
      
      case 'clients':
        return (
          <section className="py-16 px-6">
            <h2 className="text-3xl font-bold text-blue-800 mb-10">Client Management</h2>
            <div className="bg-white p-6 rounded-lg shadow-md space-y-8">
              <div>
                <div className="flex justify-between items-center mb-4">
                  <h3 className="text-xl font-semibold text-gray-900">Clients</h3>
                  <button className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 flex items-center">
                    <PlusCircle size={16} className="mr-1" /> Add New Client
                  </button>
                </div>
                <div className="bg-gray-50 p-4 rounded-lg">
                  <p className="text-gray-600">No clients to display. Add your first client to get started.</p>
                </div>
              </div>
            </div>
          </section>
        );
      
      case 'reports':
        return (
          <section className="py-16 px-6">
            <h2 className="text-3xl font-bold text-blue-800 mb-10">Financial Reports</h2>
            <div className="bg-white p-6 rounded-lg shadow-md space-y-8">
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">Reports</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <h4 className="font-medium mb-2">Income Statement</h4>
                    <p className="text-sm text-gray-600 mb-3">View revenue, expenses, and profit/loss over time.</p>
                    <button className="text-blue-800 hover:underline">Generate Report</button>
                  </div>
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <h4 className="font-medium mb-2">Balance Sheet</h4>
                    <p className="text-sm text-gray-600 mb-3">View assets, liabilities, and equity at a point in time.</p>
                    <button className="text-blue-800 hover:underline">Generate Report</button>
                  </div>
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <h4 className="font-medium mb-2">Cash Flow Statement</h4>
                    <p className="text-sm text-gray-600 mb-3">View cash inflows and outflows over time.</p>
                    <button className="text-blue-800 hover:underline">Generate Report</button>
                  </div>
                </div>
              </div>
            </div>
          </section>
        );
      
      case 'settings':
        return (
          <section className="py-16 px-6">
            <h2 className="text-3xl font-bold text-blue-800 mb-10">System Settings</h2>
            <div className="bg-white p-6 rounded-lg shadow-md space-y-8">
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">User Management</h3>
                <button className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 flex items-center">
                  <PlusCircle size={16} className="mr-1" /> Add New User
                </button>
              </div>
              <div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">API Integrations</h3>
                <div className="bg-gray-50 p-4 rounded-lg">
                  <p className="text-gray-600">Configure integrations with third-party services.</p>
                </div>
              </div>
            </div>
          </section>
        );
      
      default:
        return (
          <section className="py-16 px-6">
            <h2 className="text-3xl font-bold text-blue-800 mb-10">Module Not Found</h2>
            <p>The requested module '{activeModule}' does not exist.</p>
          </section>
        );
    }
  };

  return (
    <div className="flex h-screen bg-gray-50">
      <Sidebar activeModule={activeModule} setActiveModule={setActiveModule} />
      <div className="flex-1 overflow-auto">
        {renderModule()}
      </div>
    </div>
  );
}

function TabButton({ icon, label, active, onClick }) {
  return (
    <button
      onClick={onClick}
      className={`px-4 py-3 flex items-center ${
        active 
          ? 'border-b-2 border-blue-800 text-blue-800' 
          : 'text-gray-600 hover:text-blue-800'
      }`}
    >
      {icon && <span className="mr-2">{icon}</span>}
      {label}
    </button>
  );
}

export default AdminDashboard;



================================================
File: client/src/components/ClientDashboard.jsx
================================================
// src/components/ClientDashboard.jsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

// Import dashboard components
import FinancialOverview from './dashboard/FinancialOverview';
import CashFlowChart from './dashboard/CashFlowChart';
import CustomReports from './dashboard/CustomReports';
import GeneralLedger from './dashboard/GeneralLedger';
import FileUpload from './dashboard/FileUpload';
import DownloadSection from './dashboard/DownloadSection';
import ClientChat from './dashboard/ClientChat';

function ClientDashboard() {
  const [dashboardData, setDashboardData] = useState({
    financials: { 
      profitLoss: { revenue: 50000, expenses: 30000, netIncome: 20000 }, 
      balanceSheet: { assets: 100000, liabilities: 40000, equity: 60000 } 
    },
    cashFlow: { labels: ['Jan', 'Feb', 'Mar'], data: [10000, 15000, 12000] },
    reports: ['Sales by Category', 'Expense Breakdown'],
    gl: [{ date: '2025-02-01', description: 'Sales', amount: 5000 }],
  });
  const [clientChatMessages, setClientChatMessages] = useState([]);
  const [activeTab, setActiveTab] = useState('overview');
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    setIsLoading(true);
    const token = localStorage.getItem('token');
    try {
      const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/client/dashboard`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      setDashboardData(response.data);
      if (response.data.clientChat) {
        setClientChatMessages(response.data.clientChat);
      }
    } catch (error) {
      console.error('Failed to fetch dashboard data:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Mobile-friendly tab navigation
  const renderTabContent = () => {
    switch (activeTab) {
      case 'overview':
        return <FinancialOverview financials={dashboardData.financials} />;
      case 'cashflow':
        return <CashFlowChart cashFlow={dashboardData.cashFlow} />;
      case 'reports':
        return <CustomReports reports={dashboardData.reports} />;
      case 'ledger':
        return <GeneralLedger entries={dashboardData.gl} />;
      case 'upload':
        return <FileUpload onSuccess={fetchDashboardData} />;
      case 'download':
        return <DownloadSection />;
      case 'chat':
        return <ClientChat messages={clientChatMessages} setMessages={setClientChatMessages} />;
      default:
        return <FinancialOverview financials={dashboardData.financials} />;
    }
  };

  return (
    <section className="py-8 md:py-16 bg-gray-50">
      <div className="max-w-6xl mx-auto px-4">
        <h2 className="text-2xl md:text-3xl font-bold text-blue-800 mb-6 md:mb-10 text-center">Your Financial Dashboard</h2>
        
        {isLoading ? (
          <div className="bg-white p-6 rounded-lg shadow-md flex justify-center items-center h-64">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-800"></div>
          </div>
        ) : (
          <>
            {/* Mobile Tab Navigation */}
            <div className="md:hidden mb-6 bg-white rounded-lg shadow overflow-x-auto">
              <div className="flex">
                <TabButton label="Overview" active={activeTab === 'overview'} onClick={() => setActiveTab('overview')} />
                <TabButton label="Cash Flow" active={activeTab === 'cashflow'} onClick={() => setActiveTab('cashflow')} />
                <TabButton label="Ledger" active={activeTab === 'ledger'} onClick={() => setActiveTab('ledger')} />
                <TabButton label="More" active={['reports', 'upload', 'download', 'chat'].includes(activeTab)} onClick={() => setActiveTab('reports')} />
              </div>
            </div>
            
            {/* Mobile View: Single Component Based on Tab */}
            <div className="md:hidden bg-white p-4 md:p-6 rounded-lg shadow-md mb-6">
              {renderTabContent()}
              
              {/* Secondary Tabs for "More" */}
              {['reports', 'upload', 'download', 'chat'].includes(activeTab) && (
                <div className="mt-6 pt-6 border-t border-gray-200">
                  <div className="flex space-x-2 overflow-x-auto pb-2">
                    <SecondaryTabButton label="Reports" active={activeTab === 'reports'} onClick={() => setActiveTab('reports')} />
                    <SecondaryTabButton label="Upload" active={activeTab === 'upload'} onClick={() => setActiveTab('upload')} />
                    <SecondaryTabButton label="Download" active={activeTab === 'download'} onClick={() => setActiveTab('download')} />
                    <SecondaryTabButton label="Chat" active={activeTab === 'chat'} onClick={() => setActiveTab('chat')} />
                  </div>
                </div>
              )}
            </div>
            
            {/* Desktop View: All Components */}
            <div className="hidden md:block bg-white p-6 rounded-lg shadow-md space-y-8">
              <FinancialOverview financials={dashboardData.financials} />
              <CashFlowChart cashFlow={dashboardData.cashFlow} />
              <CustomReports reports={dashboardData.reports} />
              <GeneralLedger entries={dashboardData.gl} />
              <FileUpload onSuccess={fetchDashboardData} />
              <DownloadSection />
              <ClientChat 
                messages={clientChatMessages} 
                setMessages={setClientChatMessages} 
              />
            </div>
          </>
        )}
      </div>
    </section>
  );
}

// Tab Button Component for Mobile Navigation
function TabButton({ label, active, onClick }) {
  return (
    <button
      onClick={onClick}
      className={`flex-1 py-3 text-center text-sm font-medium ${
        active 
          ? 'text-blue-800 border-b-2 border-blue-800' 
          : 'text-gray-500 hover:text-blue-800'
      }`}
    >
      {label}
    </button>
  );
}

// Secondary Tab Button for "More" section
function SecondaryTabButton({ label, active, onClick }) {
  return (
    <button
      onClick={onClick}
      className={`px-3 py-1 text-sm rounded-full ${
        active 
          ? 'bg-blue-800 text-white' 
          : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
      }`}
    >
      {label}
    </button>
  );
}

export default ClientDashboard;



================================================
File: client/src/components/ConsultationFormModal.jsx
================================================
// src/components/ConsultationFormModal.jsx
import React, { useState } from 'react';
import { X } from 'lucide-react';
import axios from 'axios';
import useMultiStepForm from '../hooks/useMultiStepForm';
import FormProgress from './form/FormProgress';
import CompanyInformationStep from './form/CompanyInformationStep';
import ServicesSelectionStep from './form/ServicesSelectionStep';
import FormNavigation from './form/FormNavigation';
import { useUI } from '../contexts/UIContext';

const servicesList = [
  { id: 'bookkeeping', title: 'Bookkeeping', description: 'Full-service bookkeeping including transaction coding and reconciliations' },
  { id: 'monthlyFinancials', title: 'Monthly Financial Package', description: 'Comprehensive monthly financial statements with analysis' },
  { id: 'cashFlow', title: 'Cash Flow Management', description: 'Detailed cash flow tracking and forecasting' },
  { id: 'customReporting', title: 'Custom Reporting', description: 'Tailored financial reports for your specific needs' },
  { id: 'budgeting', title: 'Budgeting & Forecasting', description: 'Development and monitoring of budgets and forecasts' },
  { id: 'controllerCFO', title: 'Outsourced Controller/CFO Services', description: 'Strategic financial oversight and planning tailored to your business' },
];

const formSteps = [
  {
    title: "Company Information",
    fields: [
      { name: "companyName", label: "Company Name", type: "text", required: true },
      { name: "industry", label: "Industry", type: "text", required: true },
      { name: "yearsInBusiness", label: "Years in Business", type: "select", options: ["Less than 1 year", "1-3 years", "3-5 years", "5-10 years", "More than 10 years"], required: true },
      { name: "revenueRange", label: "Annual Revenue Range", type: "select", options: ["Under $100K", "$100K - $250K", "$250K - $500K", "$500K - $1M", "Over $1M"], required: true },
    ],
  },
  { title: "Services of Interest", fields: [{ name: "services", type: "services", required: true }] },
  {
    title: "Contact Information",
    fields: [
      { name: "contactName", label: "Your Name", type: "text", required: true },
      { name: "email", label: "Email Address", type: "email", required: true },
      { name: "phone", label: "Phone Number", type: "tel", required: false },
      { name: "preferredContact", label: "Preferred Contact Method", type: "select", options: ["Email", "Phone"], required: true },
      { name: "preferredTime", label: "Best Time to Contact", type: "select", options: ["Morning", "Afternoon", "Evening"], required: true },
      { name: "notes", label: "Additional Notes", type: "textarea", required: false },
    ],
  },
];

function ConsultationFormModal({ setShowConsultationForm }) { // Add prop
  const { setShowConsultationForm: setShowConsultationFormContext } = useUI(); // Keep context for debugging
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const initialFormData = {
    companyName: '', industry: '', yearsInBusiness: '', revenueRange: '', services: [],
    contactName: '', email: '', phone: '', preferredContact: '', preferredTime: '', notes: '',
  };

  const handleFormSubmit = async (formData) => {
    setIsSubmitting(true);
    try {
      await axios.post(`${process.env.REACT_APP_API_URL || 'http://localhost:10000'}/api/consultation`, formData);
      alert('Thank you! Your request has been submitted. We\'ll contact you shortly!');
      setShowConsultationForm(false); // Use prop to close modal
    } catch (error) {
      alert('Submission failed. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const {
    currentStep,
    formData,
    handleInputChange,
    handleServiceToggle,
    isStepValid,
    prevStep,
    nextStep,
    handleSubmit
  } = useMultiStepForm(formSteps, initialFormData, handleFormSubmit);

  const handleClose = () => {
    setShowConsultationForm(false); // Use prop to close modal
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg shadow-xl max-h-[90vh] overflow-y-auto w-full max-w-md sm:max-w-lg md:max-w-3xl">
        <div className="sticky top-0 bg-white p-6 border-b flex justify-between items-center">
          <h2 className="text-2xl font-bold text-blue-800">Schedule Your Free Consultation</h2>
          <button onClick={handleClose} className="text-gray-500 hover:text-gray-700">
            <X size={24} />
          </button>
        </div>
        <div className="p-6">
          <FormProgress steps={formSteps} currentStep={currentStep} />
          
          <form onSubmit={handleSubmit}>
            {currentStep === 0 && (
              <CompanyInformationStep
                formData={formData}
                handleInputChange={handleInputChange}
                fields={formSteps[0].fields}
              />
            )}
            
            {currentStep === 1 && (
              <ServicesSelectionStep
                formData={formData}
                handleServiceToggle={handleServiceToggle}
                servicesList={servicesList}
              />
            )}
            
            {currentStep === 2 && (
              <CompanyInformationStep
                formData={formData}
                handleInputChange={handleInputChange}
                fields={formSteps[2].fields}
              />
            )}
            
            <FormNavigation
              currentStep={currentStep}
              totalSteps={formSteps.length}
              prevStep={prevStep}
              nextStep={nextStep}
              isStepValid={isStepValid}
              isSubmitting={isSubmitting}
            />
          </form>
        </div>
      </div>
    </div>
  );
}

export default ConsultationFormModal;



================================================
File: client/src/components/Footer.jsx
================================================
import React from 'react';

function Footer() {
  return (
    <footer className="bg-gradient-to-r from-blue-900 to-blue-800 text-white py-8" role="contentinfo" aria-label="Footer">
      <div className="max-w-6xl mx-auto px-4 text-center">
        <h3 className="text-xl font-bold mb-3">Wilcox Advisors</h3>
        <p className="text-blue-100 mb-6">Professional financial services tailored for small businesses.</p>
        
        <div className="border-t border-blue-700 pt-4">
          <p className="text-sm text-blue-100">© 2025 Wilcox Advisors. All rights reserved.</p>
        </div>
      </div>
    </footer>
  );
}

export default Footer;



================================================
File: client/src/components/Header.jsx
================================================
// src/components/Header.jsx - Improved mobile responsiveness
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { Menu, X } from 'lucide-react';
import { useAuth } from '../contexts/AuthContext';

function Header({ setShowLoginModal }) {
  const { isLoggedIn, isAdmin, logout } = useAuth();
  const navigate = useNavigate();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [scrolled, setScrolled] = useState(false);
  
  // Add scroll effect for better mobile UX
  useEffect(() => {
    const handleScroll = () => {
      if (window.scrollY > 10) {
        setScrolled(true);
      } else {
        setScrolled(false);
      }
    };
    
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const handleLoginClick = () => {
    setShowLoginModal(true);
    setIsMobileMenuOpen(false);
  };

  const handleLogout = () => {
    logout();
    navigate('/');
    setIsMobileMenuOpen(false);
  };

  const handleSectionClick = (section) => {
    if (window.location.pathname === '/') {
      document.getElementById(section)?.scrollIntoView({ behavior: 'smooth' });
    } else {
      navigate(`/#${section}`);
    }
    setIsMobileMenuOpen(false);
  };

  return (
    <nav 
      className={`bg-white shadow-md sticky top-0 z-50 transition-all duration-300 ${
        scrolled ? 'py-2' : 'py-4'
      }`} 
      role="navigation" 
      aria-label="Main navigation"
    >
      <div className="max-w-6xl mx-auto px-4">
        <div className="flex justify-between items-center">
          <div className="flex items-center">
            <Link to="/" className="text-xl md:text-2xl text-blue-800 font-bold hover:text-blue-900 transition duration-200" aria-label="Home">
              WILCOX ADVISORS
            </Link>
          </div>
          
          {/* Desktop Navigation */}
          <div className="hidden md:flex items-center space-x-4 lg:space-x-8">
            <button 
              onClick={() => handleSectionClick('services')} 
              className="text-gray-700 hover:text-blue-800 font-medium px-2 py-1" 
              aria-label="Services section"
            >
              Services
            </button>
            <button 
              onClick={() => handleSectionClick('blog')} 
              className="text-gray-700 hover:text-blue-800 font-medium px-2 py-1" 
              aria-label="Blog section"
            >
              Blog
            </button>
            <button 
              onClick={() => handleSectionClick('about')} 
              className="text-gray-700 hover:text-blue-800 font-medium px-2 py-1" 
              aria-label="About section"
            >
              About
            </button>
            <button 
              onClick={() => handleSectionClick('contact')} 
              className="text-gray-700 hover:text-blue-800 font-medium px-2 py-1" 
              aria-label="Contact section"
            >
              Contact
            </button>
            {isLoggedIn ? (
              <>
                <Link 
                  to={isAdmin ? '/admin-dashboard' : '/client-dashboard'} 
                  className="px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900 transition duration-200" 
                  aria-label={isAdmin ? "Admin Dashboard" : "Client Dashboard"}
                >
                  Dashboard
                </Link>
                <button 
                  onClick={handleLogout} 
                  className="text-gray-700 hover:text-blue-800 font-medium" 
                  aria-label="Logout"
                >
                  Logout
                </button>
              </>
            ) : (
              <button 
                onClick={handleLoginClick} 
                className="px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900 transition duration-200" 
                aria-label="Login"
              >
                Login
              </button>
            )}
          </div>
          
          {/* Mobile menu button */}
          <div className="md:hidden">
            <button 
              onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)} 
              className="text-gray-700 hover:text-blue-800 p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-md" 
              aria-label="Toggle mobile menu"
              aria-expanded={isMobileMenuOpen}
            >
              {isMobileMenuOpen ? <X size={24} /> : <Menu size={24} />}
            </button>
          </div>
        </div>
        
        {/* Mobile Navigation */}
        <div className={`md:hidden transition-all duration-300 overflow-hidden ${isMobileMenuOpen ? 'max-h-96 opacity-100' : 'max-h-0 opacity-0'}`}>
          <div className="py-3 space-y-2 bg-white" role="menu">
            <button 
              onClick={() => handleSectionClick('services')} 
              className="block w-full text-left px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-800 rounded-md" 
              aria-label="Services section"
            >
              Services
            </button>
            <button 
              onClick={() => handleSectionClick('blog')} 
              className="block w-full text-left px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-800 rounded-md" 
              aria-label="Blog section"
            >
              Blog
            </button>
            <button 
              onClick={() => handleSectionClick('about')} 
              className="block w-full text-left px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-800 rounded-md" 
              aria-label="About section"
            >
              About
            </button>
            <button 
              onClick={() => handleSectionClick('contact')} 
              className="block w-full text-left px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-800 rounded-md" 
              aria-label="Contact section"
            >
              Contact
            </button>
            {isLoggedIn ? (
              <>
                <Link 
                  to={isAdmin ? '/admin-dashboard' : '/client-dashboard'} 
                  className="block w-full text-left px-4 py-3 bg-blue-800 text-white rounded-md hover:bg-blue-900" 
                  onClick={() => setIsMobileMenuOpen(false)} 
                  aria-label={isAdmin ? "Admin Dashboard" : "Client Dashboard"}
                >
                  Dashboard
                </Link>
                <button 
                  onClick={handleLogout} 
                  className="block w-full text-left px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-800 rounded-md" 
                  aria-label="Logout"
                >
                  Logout
                </button>
              </>
            ) : (
              <button 
                onClick={handleLoginClick} 
                className="block w-full text-left px-4 py-3 bg-blue-800 text-white rounded-md hover:bg-blue-900"
                aria-label="Login"
              >
                Login
              </button>
            )}
          </div>
        </div>
      </div>
    </nav>
  );
}

export default Header;



================================================
File: client/src/components/LoginModal.jsx
================================================
// src/components/LoginModal.jsx
import React, { useState } from 'react';
import { X } from 'lucide-react';
import axios from 'axios';
import { useAuth } from '../contexts/AuthContext';
import { useNavigate } from 'react-router-dom';

function LoginModal({ setShowLoginModal }) {
  const auth = useAuth();
  const navigate = useNavigate();
  const [loginData, setLoginData] = useState({ email: '', password: '' });
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setLoginData(prev => ({ ...prev, [name]: value }));
  };

  const handleLoginSubmit = async (e) => {
    e.preventDefault();
    
    if (!loginData.email.trim() || !loginData.password.trim()) {
      setError('Please enter both email and password.');
      return;
    }
    
    setIsLoading(true);
    setError('');
    
    try {
      const API_URL = process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com';
      
      console.log("Attempting login with:", loginData.email);
      const response = await axios.post(
        `${API_URL}/api/auth/login`, 
        loginData
      );
      
      console.log("Login response:", response.data);
      
      // Store authentication state
      auth.login(response.data.token, response.data.isAdmin);
      setShowLoginModal(false);
      
      // Use React Router's navigate instead of window.location.href
      setTimeout(() => {
        if (response.data.isAdmin) {
          console.log("Redirecting to admin dashboard");
          navigate('/admin-dashboard');
        } else {
          console.log("Redirecting to client dashboard");
          navigate('/client-dashboard');
        }
      }, 100);
    } catch (error) {
      console.error('Login Error:', error);
      
      if (error.response) {
        switch (error.response.status) {
          case 401:
            setError('Invalid email or password. Please try again.');
            break;
          case 403:
            setError('Access forbidden. Please contact administrator.');
            break;
          case 500:
            setError('Server error. Please try again later.');
            break;
          default:
            setError(error.response.data?.message || 'Login failed. Please try again.');
        }
      } else if (error.request) {
        setError('No response from server. Please check your internet connection.');
      } else {
        setError('An unexpected error occurred. Please try again.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold text-blue-800">Client Login</h2>
          <button onClick={() => setShowLoginModal(false)} className="text-gray-500 hover:text-gray-700">
            <X size={24} />
          </button>
        </div>
        <form onSubmit={handleLoginSubmit}>
          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">Email</label>
              <input
                id="email"
                type="email"
                name="email"
                value={loginData.email}
                onChange={handleInputChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border"
                required
              />
            </div>
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">Password</label>
              <input
                id="password"
                type="password"
                name="password"
                value={loginData.password}
                onChange={handleInputChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border"
                required
              />
            </div>
          </div>
          {error && <p className="text-red-500 mt-2">{error}</p>}
          <div className="mt-6 flex justify-between items-center">
            <button 
              type="submit" 
              className="bg-blue-800 text-white px-6 py-2 rounded-lg hover:bg-blue-900 transition duration-200"
              disabled={isLoading}
            >
              {isLoading ? 'Logging in...' : 'Login'}
            </button>
            <button
              type="button"
              className="text-blue-800 hover:underline"
              onClick={() => alert('Please contact support to reset your password.')}
            >
              Forgot Password?
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}

export default LoginModal;



================================================
File: client/src/components/MainContent.jsx
================================================
// src/components/MainContent.jsx
import React from 'react';
import { Routes, Route, useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useUI } from '../contexts/UIContext';
import Header from './Header';
import Footer from './Footer';
import Home from '../pages/Home';
import LearnMore from '../pages/LearnMore';
import AdminDashboard from './AdminDashboard';
import ClientDashboard from './ClientDashboard';
import { AdminProtectedRoute, ClientProtectedRoute } from './ProtectedRoutes';
import LoginModal from './LoginModal';
import ConsultationFormModal from './ConsultationFormModal';

function MainContent() {
  const navigate = useNavigate();
  const { isLoggedIn, isAdmin, logout } = useAuth();
  const { showLogin, setShowLogin, showConsultationForm, setShowConsultationForm } = useUI();

  const handleLogout = () => {
    logout();
    navigate('/');
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <Header
        isLoggedIn={isLoggedIn}
        isAdmin={isAdmin}
        handleLogout={handleLogout}
        setShowLoginModal={setShowLogin}
      />
      <Routes>
        <Route path="/" element={<Home setShowConsultationForm={setShowConsultationForm} />} />
        <Route path="/learn-more" element={<LearnMore />} />
        <Route path="/admin-dashboard" element={
          <AdminProtectedRoute>
            <AdminDashboard />
          </AdminProtectedRoute>
        } />
        <Route path="/client-dashboard" element={
          <ClientProtectedRoute>
            <ClientDashboard />
          </ClientProtectedRoute>
        } />
      </Routes>
      <Footer />
      {showLogin && <LoginModal setShowLoginModal={setShowLogin} />}
      {showConsultationForm && <ConsultationFormModal setShowConsultationForm={setShowConsultationForm} />}
    </div>
  );
}

export default MainContent;



================================================
File: client/src/components/ManualJournalEntry.jsx
================================================
// src/components/ManualJournalEntry.jsx
import React, { useState, useEffect } from 'react';
import useJournalEntryForm from '../hooks/useJournalEntryForm';
import { Plus, Trash2, Download, Upload, Save, Info } from 'lucide-react';
import axios from 'axios';

function JournalEntrySystem() {
  const [showAdvancedFields, setShowAdvancedFields] = useState(false);
  const [accountsList, setAccountsList] = useState([]);
  const [showTips, setShowTips] = useState(false);
  
  useEffect(() => {
    fetchAccounts();
  }, []);
  
  const fetchAccounts = async () => {
    try {
      const token = localStorage.getItem('token');
      const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/accounting/accounts`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      setAccountsList(response.data.accounts);
    } catch (error) {
      console.error('Failed to fetch accounts:', error);
    }
  };
  
  const {
    journalData, errors, entryErrors, isSubmitting, totals,
    supportingDocs, handleChange, handleEntryChange, 
    addEntryRow, removeEntryRow, handleFileUpload, handleSubmit
  } = useJournalEntryForm();

  return (
    <div className="max-w-6xl mx-auto p-4 md:p-6 bg-white rounded-lg shadow-md">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl md:text-2xl font-bold text-blue-800">Journal Entry</h2>
        <button 
          onClick={() => setShowTips(!showTips)}
          className="flex items-center text-blue-600 text-sm"
        >
          <Info size={16} className="mr-1" />
          {showTips ? "Hide Tips" : "Show Tips"}
        </button>
      </div>
      
      {showTips && (
        <div className="bg-blue-50 p-4 rounded-md mb-6 text-sm">
          <h3 className="font-semibold text-blue-800 mb-2">Quick Tips:</h3>
          <ul className="list-disc pl-5 space-y-1">
            <li>Enter debits first, followed by credits</li>
            <li>Total debits must equal total credits</li>
            <li>Use account numbers that begin with 1xxx for assets, 2xxx for liabilities, 3xxx for equity, 4xxx for revenue, 5-9xxx for expenses</li>
            <li>Add supporting documentation for audit purposes</li>
          </ul>
        </div>
      )}
      
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Journal Entry Header */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 bg-gray-50 p-4 rounded-lg">
          <div className="flex flex-col">
            <label htmlFor="date" className="text-gray-700 font-medium mb-1">Date *</label>
            <input
              type="date"
              id="date"
              name="date"
              value={journalData.date}
              onChange={handleChange}
              className="border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              aria-required="true"
            />
            {errors.date && <p className="text-red-500 text-sm mt-1">{errors.date}</p>}
          </div>
          
          <div className="flex flex-col">
            <label htmlFor="transactionNo" className="text-gray-700 font-medium mb-1">Transaction No.</label>
            <input
              type="text"
              id="transactionNo"
              name="transactionNo"
              value={journalData.transactionNo}
              onChange={handleChange}
              className="border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>
          
          <div className="flex flex-col md:items-end justify-end">
            <button 
              type="button"
              onClick={() => setShowAdvancedFields(!showAdvancedFields)}
              className="text-blue-600 hover:text-blue-800 flex items-center self-end mt-2 text-sm"
            >
              {showAdvancedFields ? "Hide Advanced Fields" : "Show Advanced Fields"}
            </button>
          </div>
          
          <div className="md:col-span-3">
            <label htmlFor="description" className="text-gray-700 font-medium mb-1">Description *</label>
            <textarea
              id="description"
              name="description"
              value={journalData.description}
              onChange={handleChange}
              rows={2}
              className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              aria-required="true"
            />
            {errors.description && <p className="text-red-500 text-sm mt-1">{errors.description}</p>}
          </div>
        </div>
        
        {/* Journal Entry Table */}
        <div className="overflow-x-auto bg-white rounded-lg border">
          <table className="w-full text-sm">
            <thead className="bg-gray-100">
              <tr>
                <th className="py-2 px-3 text-left">Account</th>
                <th className="py-2 px-3 text-left">Description</th>
                {showAdvancedFields && (
                  <>
                    <th className="py-2 px-3 text-left">Reference</th>
                    <th className="py-2 px-3 text-left">Subledger</th>
                  </>
                )}
                <th className="py-2 px-3 text-right">Debit</th>
                <th className="py-2 px-3 text-right">Credit</th>
                <th className="w-10"></th>
              </tr>
            </thead>
            <tbody>
              {journalData.entries.map((entry, index) => (
                <tr key={entry.id} className="border-t">
                  <td className="py-2 px-3">
                    <div className="flex flex-col">
                      <select
                        value={entry.accountNo}
                        onChange={(e) => {
                          handleEntryChange(entry.id, 'accountNo', e.target.value);
                          const selectedAccount = accountsList.find(a => a.accountNumber === e.target.value);
                          if (selectedAccount) {
                            handleEntryChange(entry.id, 'accountTitle', selectedAccount.accountName);
                          }
                        }}
                        className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      >
                        <option value="">Select Account</option>
                        {accountsList.map(account => (
                          <option key={account.accountNumber} value={account.accountNumber}>
                            {account.accountNumber} - {account.accountName}
                          </option>
                        ))}
                      </select>
                      {entryErrors[index]?.accountNo && (
                        <p className="text-red-500 text-xs mt-1">{entryErrors[index].accountNo}</p>
                      )}
                    </div>
                  </td>
                  <td className="py-2 px-3">
                    <input
                      type="text"
                      value={entry.description || ''}
                      onChange={(e) => handleEntryChange(entry.id, 'description', e.target.value)}
                      placeholder="Line description"
                      className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                  </td>
                  {showAdvancedFields && (
                    <>
                      <td className="py-2 px-3">
                        <input
                          type="text"
                          value={entry.reference || ''}
                          onChange={(e) => handleEntryChange(entry.id, 'reference', e.target.value)}
                          placeholder="Invoice #, etc."
                          className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        />
                      </td>
                      <td className="py-2 px-3">
                        <select
                          value={entry.subledger || ''}
                          onChange={(e) => handleEntryChange(entry.id, 'subledger', e.target.value)}
                          className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                          <option value="">None</option>
                          <option value="AP">Accounts Payable</option>
                          <option value="AR">Accounts Receivable</option>
                          <option value="Payroll">Payroll</option>
                          <option value="Inventory">Inventory</option>
                          <option value="Assets">Fixed Assets</option>
                        </select>
                      </td>
                    </>
                  )}
                  <td className="py-2 px-3">
                    <input
                      type="number"
                      value={entry.debit}
                      onChange={(e) => handleEntryChange(entry.id, 'debit', e.target.value)}
                      placeholder="0.00"
                      step="0.01"
                      min="0"
                      className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 text-right"
                    />
                  </td>
                  <td className="py-2 px-3">
                    <input
                      type="number"
                      value={entry.credit}
                      onChange={(e) => handleEntryChange(entry.id, 'credit', e.target.value)}
                      placeholder="0.00"
                      step="0.01"
                      min="0"
                      className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 text-right"
                    />
                    {entryErrors[index]?.amount && (
                      <p className="text-red-500 text-xs mt-1">{entryErrors[index].amount}</p>
                    )}
                  </td>
                  <td className="py-2 px-3">
                    <button
                      type="button"
                      onClick={() => removeEntryRow(entry.id)}
                      className="text-red-500 hover:text-red-700 p-1"
                      title="Remove line"
                    >
                      <Trash2 size={18} />
                    </button>
                  </td>
                </tr>
              ))}
              
              {/* Totals row */}
              <tr className="bg-gray-50 font-semibold border-t">
                <td colSpan={showAdvancedFields ? 4 : 2} className="py-2 px-3 text-right">Totals</td>
                <td className="py-2 px-3 text-right">${totals.debit.toFixed(2)}</td>
                <td className="py-2 px-3 text-right">${totals.credit.toFixed(2)}</td>
                <td></td>
              </tr>
            </tbody>
          </table>
        </div>
        
        {/* Balance check */}
        <div className="flex justify-between items-center">
          <button
            type="button"
            onClick={addEntryRow}
            className="flex items-center text-blue-600 hover:text-blue-800 bg-blue-50 px-3 py-2 rounded-md"
          >
            <Plus size={18} className="mr-1" /> Add Line
          </button>
          
          <div>
            {errors.balance && (
              <p className="text-red-500 font-medium">{errors.balance}</p>
            )}
            
            {totals.isBalanced && totals.debit > 0 && (
              <p className="text-green-600 font-medium">✓ Balanced</p>
            )}
          </div>
        </div>
        
        {/* Supporting Documents */}
        <div className="bg-gray-50 p-4 rounded-lg">
          <h3 className="font-medium mb-2">Supporting Documents</h3>
          
          <div className="flex flex-wrap gap-2 mb-4">
            {supportingDocs.map((doc, idx) => (
              <div key={idx} className="bg-white px-3 py-2 rounded-md flex items-center text-sm">
                <span className="truncate max-w-xs">{doc.name}</span>
                <button 
                  type="button"
                  onClick={() => {
                    const newDocs = [...supportingDocs];
                    newDocs.splice(idx, 1);
                    // Call function to update supporting docs
                  }} 
                  className="ml-2 text-red-500 hover:text-red-700"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            ))}
            
            {supportingDocs.length === 0 && (
              <p className="text-gray-500 text-sm">No documents attached</p>
            )}
          </div>
          
          <div className="flex flex-wrap gap-4">
            <label className="flex items-center bg-white border border-gray-300 rounded-md px-4 py-2 cursor-pointer hover:bg-gray-50">
              <Upload className="mr-2 h-5 w-5 text-blue-800" />
              <span>Upload Document</span>
              <input 
                type="file"
                onChange={(e) => handleFileUpload(e.target.files[0])} 
                className="hidden"
                accept=".pdf,.xls,.xlsx,.csv,.doc,.docx"
              />
            </label>
            
            <button 
              type="button"
              className="flex items-center bg-white border border-gray-300 rounded-md px-4 py-2 hover:bg-gray-50"
            >
              <Download className="mr-2 h-5 w-5 text-blue-800" />
              <span>Entry Template</span>
            </button>
          </div>
        </div>
        
        {/* Submit Button */}
        <div className="flex justify-end">
          <button 
            type="submit"
            disabled={isSubmitting}
            className={`
              flex items-center bg-blue-800 text-white px-6 py-3 rounded-md
              ${isSubmitting ? 'opacity-70 cursor-not-allowed' : 'hover:bg-blue-900'}
              transition duration-200
            `}
          >
            {isSubmitting ? 'Posting...' : 'Post Journal Entry'}
            <Save className="ml-2 h-5 w-5" />
          </button>
        </div>
      </form>
    </div>
  );
}

export default JournalEntrySystem;



================================================
File: client/src/components/ProtectedRoutes.jsx
================================================
// src/components/ProtectedRoutes.jsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

export function AdminProtectedRoute({ children }) {
  const { isLoggedIn, isAdmin } = useAuth();
  console.log("AdminProtectedRoute check:", { isLoggedIn, isAdmin });
  
  if (!isLoggedIn) {
    console.log("Not logged in, redirecting to home");
    return <Navigate to="/" />;
  }
  
  if (!isAdmin) {
    console.log("Not admin, redirecting to client dashboard");
    return <Navigate to="/client-dashboard" />;
  }
  
  console.log("Admin access granted");
  return children;
}

export function ClientProtectedRoute({ children }) {
  const { isLoggedIn } = useAuth();
  console.log("ClientProtectedRoute check:", { isLoggedIn });
  
  if (!isLoggedIn) {
    console.log("Not logged in, redirecting to home");
    return <Navigate to="/" />;
  }
  
  console.log("Client access granted");
  return children;
}



================================================
File: client/src/components/Sidebar.jsx
================================================
// src/components/Sidebar.jsx
import React from 'react';
import { Home, Users, Database, FileSpreadsheet, Settings, Globe, LogOut } from 'lucide-react';
import { useAuth } from '../contexts/AuthContext';
import { useNavigate } from 'react-router-dom';

export default function Sidebar({ activeModule, setActiveModule }) {
  const { logout } = useAuth();
  const navigate = useNavigate();
  
  const handleLogout = () => {
    logout();
    navigate('/');
  };
  
  return (
    <div className="w-64 bg-blue-900 text-white h-screen flex-shrink-0 flex flex-col">
      <div className="p-6 border-b border-blue-800">
        <h1 className="text-2xl font-bold">Wilcox Advisors</h1>
      </div>
      <nav className="p-4 flex-grow">
        <NavItem icon={<Home className="mr-3" />} label="Dashboard" active={activeModule === 'dashboard'} onClick={() => setActiveModule('dashboard')} />
        <NavItem icon={<Users className="mr-3" />} label="Clients" active={activeModule === 'clients'} onClick={() => setActiveModule('clients')} />
        <NavItem icon={<Database className="mr-3" />} label="Accounting" active={activeModule === 'accounting'} onClick={() => setActiveModule('accounting')} />
        <NavItem icon={<FileSpreadsheet className="mr-3" />} label="Reports" active={activeModule === 'reports'} onClick={() => setActiveModule('reports')} />
        <NavItem icon={<Globe className="mr-3" />} label="Website" active={activeModule === 'website'} onClick={() => setActiveModule('website')} />
        <NavItem icon={<Settings className="mr-3" />} label="Settings" active={activeModule === 'settings'} onClick={() => setActiveModule('settings')} />
      </nav>
      
      {/* Logout Button */}
      <div className="p-4 border-t border-blue-800">
        <button onClick={handleLogout} className="flex items-center w-full p-3 rounded hover:bg-blue-800 text-white">
          <LogOut className="mr-3" />
          Logout
        </button>
      </div>
    </div>
  );
}

function NavItem({ icon, label, active, onClick }) {
  return (
    <button
      onClick={onClick}
      className={`flex items-center w-full p-3 rounded hover:bg-blue-800 mb-2 ${
        active ? 'bg-blue-800' : ''
      }`}
    >
      {icon}
      {label}
    </button>
  );
}



================================================
File: client/src/components/TabNavigation.jsx
================================================
// components/TabNavigation.jsx
import React from 'react';
import { Layout, Home, Info, Bookmark, FileText, Phone } from 'lucide-react';

export default function TabNavigation({ activeTab, setActiveTab }) {
  return (
    <div className="flex border-b overflow-x-auto">
      <TabButton 
        active={activeTab === 'general'} 
        onClick={() => setActiveTab('general')}
        icon={<Layout size={16} />}
        label="General"
      />
      <TabButton 
        active={activeTab === 'home'} 
        onClick={() => setActiveTab('home')}
        icon={<Home size={16} />}
        label="Home Page"
      />
      <TabButton 
        active={activeTab === 'learn-more'} 
        onClick={() => setActiveTab('learn-more')}
        icon={<Info size={16} />}
        label="Learn More"
      />
      <TabButton 
        active={activeTab === 'about'} 
        onClick={() => setActiveTab('about')}
        icon={<Bookmark size={16} />}
        label="About Us"
      />
      <TabButton 
        active={activeTab === 'services'} 
        onClick={() => setActiveTab('services')}
        icon={<FileText size={16} />}
        label="Services"
      />
      <TabButton 
        active={activeTab === 'contact'} 
        onClick={() => setActiveTab('contact')}
        icon={<Phone size={16} />}
        label="Contact"
      />
    </div>
  );
}

function TabButton({ icon, label, active, onClick }) {
  return (
    <button
      onClick={onClick}
      className={`px-4 py-3 flex items-center ${
        active 
          ? 'border-b-2 border-blue-800 text-blue-800' 
          : 'text-gray-600 hover:text-blue-800'
      }`}
    >
      {icon && <span className="mr-2">{icon}</span>}
      {label}
    </button>
  );
}



================================================
File: client/src/components/WebsiteContentManager.jsx
================================================
// components/WebsiteContentManager.jsx
import React, { useState } from 'react';
import { Save, CheckCircle } from 'lucide-react';
import TabNavigation from './TabNavigation';
import GeneralTab from './website/GeneralTab';
import HomePageTab from './website/HomePageTab';
import LearnMoreTab from './website/LearnMoreTab';
import AboutTab from './website/AboutTab';
import ServicesTab from './website/ServicesTab';
import ContactTab from './website/ContactTab';

export default function WebsiteContentManager() {
  const [activeTab, setActiveTab] = useState('general');
  const [saved, setSaved] = useState(false);
  
  const handleSave = () => {
    setSaved(true);
    // In a real implementation, save data to backend here
    setTimeout(() => setSaved(false), 3000);
  };
  
  return (
    <div className="flex-1 p-6 bg-gray-100">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-3xl font-bold">Website Content Management</h2>
        
        <div className="flex space-x-2">
          <button 
            onClick={handleSave}
            className="flex items-center bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900"
          >
            <Save className="mr-2" size={18} />
            Save Changes
          </button>
        </div>
      </div>
      
      {saved && (
        <div className="mb-6 p-4 bg-green-100 text-green-800 rounded-lg flex items-center">
          <CheckCircle className="mr-2" />
          Changes saved successfully! Your website has been updated.
        </div>
      )}
      
      <div className="bg-white rounded-lg shadow-md overflow-hidden mb-6">
        <TabNavigation activeTab={activeTab} setActiveTab={setActiveTab} />
        
        <div className="p-6">
          {activeTab === 'general' && <GeneralTab />}
          {activeTab === 'home' && <HomePageTab />}
          {activeTab === 'learn-more' && <LearnMoreTab />}
          {activeTab === 'about' && <AboutTab />}
          {activeTab === 'services' && <ServicesTab />}
          {activeTab === 'contact' && <ContactTab />}
        </div>
      </div>
    </div>
  );
}



================================================
File: client/src/components/accounting/ChartOfAccountsManager.jsx
================================================
import React, { useState, useEffect } from 'react';
import { Plus, Edit2, Trash2, ChevronRight, ChevronDown, Search, Download, FileText, Copy } from 'lucide-react';
import axios from 'axios';

const ChartOfAccountsManager = () => {
  const [chartOfAccounts, setChartOfAccounts] = useState([]);
  const [selectedChart, setSelectedChart] = useState(null);
  const [accounts, setAccounts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalMode, setModalMode] = useState('chart'); // 'chart', 'account', 'import'
  const [modalAction, setModalAction] = useState('add'); // 'add', 'edit'
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    entityId: '',
    accountNumber: '',
    accountName: '',
    accountType: 'Asset',
    fslCategory: '',
    subledgerType: 'GL',
    description: '',
    customFields: {}
  });
  const [expandedTypes, setExpandedTypes] = useState({
    Asset: true,
    Liability: true,
    Equity: true,
    Revenue: true,
    Expense: true
  });
  const [entities, setEntities] = useState([]);
  const [fsliCategories, setFsliCategories] = useState({});
  const [sourceChartId, setSourceChartId] = useState('');
  const [customFieldsData, setCustomFieldsData] = useState([
    { name: '', value: '' }
  ]);

  // Mock data for customization options
  const accountTypes = [
    { id: 'Asset', label: 'Asset' },
    { id: 'Liability', label: 'Liability' },
    { id: 'Equity', label: 'Equity' },
    { id: 'Revenue', label: 'Revenue' },
    { id: 'Expense', label: 'Expense' }
  ];

  const subledgerTypes = [
    { id: 'GL', label: 'General Ledger' },
    { id: 'AP', label: 'Accounts Payable' },
    { id: 'AR', label: 'Accounts Receivable' },
    { id: 'Payroll', label: 'Payroll' },
    { id: 'Inventory', label: 'Inventory' },
    { id: 'Assets', label: 'Fixed Assets' }
  ];

  useEffect(() => {
    // Fetch entities for dropdown
    const fetchEntities = async () => {
      try {
        const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/accounting/entities`, {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        });
        
        if (response.data && response.data.entities) {
          setEntities(response.data.entities);
          
          // Set default entity if available
          if (response.data.entities.length > 0 && !formData.entityId) {
            setFormData(prev => ({
              ...prev,
              entityId: response.data.entities[0].id
            }));
          }
        }
      } catch (error) {
        console.error('Error fetching entities:', error);
        // Set sample data for demo
        setEntities([
          { id: '1', name: 'Main Company' },
          { id: '2', name: 'Subsidiary A' },
          { id: '3', name: 'Subsidiary B' }
        ]);
      }
    };

    // Fetch FSLI categories
    const fetchFSLICategories = async () => {
      try {
        const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/chart-of-accounts/fsli-categories`, {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        });
        
        if (response.data && response.data.fsliCategories) {
          setFsliCategories(response.data.fsliCategories);
        }
      } catch (error) {
        console.error('Error fetching FSLI categories:', error);
        // Set sample data for demo
        setFsliCategories({
          Asset: [
            'Cash and Cash Equivalents',
            'Accounts Receivable',
            'Inventory',
            'Property, Plant and Equipment'
          ],
          Liability: [
            'Accounts Payable',
            'Accrued Liabilities',
            'Short-term Debt',
            'Long-term Debt'
          ],
          Equity: [
            'Common Stock',
            'Retained Earnings'
          ],
          Revenue: [
            'Revenue',
            'Other Income'
          ],
          Expense: [
            'Cost of Goods Sold',
            'Operating Expenses',
            'Income Tax Expense'
          ]
        });
      }
    };

    fetchEntities();
    fetchFSLICategories();
    fetchChartOfAccounts();
  }, []);

  useEffect(() => {
    // When selected chart changes, fetch its accounts
    if (selectedChart) {
      fetchAccounts(selectedChart.id);
    } else {
      setAccounts([]);
    }
  }, [selectedChart]);

  const fetchChartOfAccounts = async () => {
    setLoading(true);
    try {
      const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/chart-of-accounts`, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
      });
      
      if (response.data && response.data.chartOfAccounts) {
        setChartOfAccounts(response.data.chartOfAccounts);
        
        // Select first chart if available
        if (response.data.chartOfAccounts.length > 0) {
          setSelectedChart(response.data.chartOfAccounts[0]);
        }
      }
    } catch (error) {
      console.error('Error fetching chart of accounts:', error);
      // Set sample data for demo
      const sampleData = [
        { id: '1', name: 'Default Chart of Accounts', description: 'Standard accounts for the main company', entityId: '1', version: 1, isActive: true },
        { id: '2', name: 'Manufacturing CoA', description: 'Custom accounts for manufacturing operations', entityId: '2', version: 2, isActive: true }
      ];
      setChartOfAccounts(sampleData);
      setSelectedChart(sampleData[0]);
    } finally {
      setLoading(false);
    }
  };

  const fetchAccounts = async (chartId) => {
    setLoading(true);
    try {
      const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/chart-of-accounts/${chartId}`, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
      });
      
      if (response.data && response.data.chartOfAccounts && response.data.chartOfAccounts.accounts) {
        setAccounts(response.data.chartOfAccounts.accounts);
      }
    } catch (error) {
      console.error('Error fetching accounts:', error);
      // Set sample data for demo
      setAccounts([
        { accountNumber: '1000', accountName: 'Cash', accountType: 'Asset', fslCategory: 'Cash and Cash Equivalents', subledgerType: 'GL' },
        { accountNumber: '1100', accountName: 'Accounts Receivable', accountType: 'Asset', fslCategory: 'Accounts Receivable', subledgerType: 'AR' },
        { accountNumber: '1200', accountName: 'Inventory', accountType: 'Asset', fslCategory: 'Inventory', subledgerType: 'Inventory' },
        { accountNumber: '1500', accountName: 'Fixed Assets', accountType: 'Asset', fslCategory: 'Property, Plant and Equipment', subledgerType: 'Assets' },
        { accountNumber: '2000', accountName: 'Accounts Payable', accountType: 'Liability', fslCategory: 'Accounts Payable', subledgerType: 'AP' },
        { accountNumber: '3000', accountName: 'Common Stock', accountType: 'Equity', fslCategory: 'Common Stock', subledgerType: 'GL' },
        { accountNumber: '4000', accountName: 'Sales Revenue', accountType: 'Revenue', fslCategory: 'Revenue', subledgerType: 'GL' },
        { accountNumber: '5000', accountName: 'Cost of Goods Sold', accountType: 'Expense', fslCategory: 'Cost of Goods Sold', subledgerType: 'GL' },
        { accountNumber: '6000', accountName: 'Salaries and Wages', accountType: 'Expense', fslCategory: 'Operating Expenses', subledgerType: 'Payroll' }
      ]);
    } finally {
      setLoading(false);
    }
  };

  const handleCreateChart = async () => {
    if (!formData.name || !formData.entityId) {
      alert('Please fill in all required fields');
      return;
    }

    try {
      await axios.post(
        `${process.env.REACT_APP_API_URL}/api/chart-of-accounts`,
        {
          entityId: formData.entityId,
          name: formData.name,
          description: formData.description
        },
        {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        }
      );
      
      fetchChartOfAccounts();
      setIsModalOpen(false);
    } catch (error) {
      console.error('Error creating chart of accounts:', error);
      alert('Failed to create chart of accounts');
      
      // For demo, simulate success
      const newChart = {
        id: Date.now().toString(),
        name: formData.name,
        description: formData.description,
        entityId: formData.entityId,
        version: 1,
        isActive: true
      };
      
      setChartOfAccounts(prev => [...prev, newChart]);
      setSelectedChart(newChart);
      setIsModalOpen(false);
    }
  };

  const handleCreateDefaultChart = async () => {
    if (!formData.entityId) {
      alert('Please select an entity');
      return;
    }

    try {
      await axios.post(
        `${process.env.REACT_APP_API_URL}/api/chart-of-accounts/default`,
        {
          entityId: formData.entityId,
          name: formData.name || 'Default Chart of Accounts'
        },
        {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        }
      );
      
      fetchChartOfAccounts();
      setIsModalOpen(false);
    } catch (error) {
      console.error('Error creating default chart of accounts:', error);
      alert('Failed to create default chart of accounts');
      
      // For demo, simulate success
      const newChart = {
        id: Date.now().toString(),
        name: formData.name || 'Default Chart of Accounts',
        description: 'Standard chart of accounts',
        entityId: formData.entityId,
        version: 1,
        isActive: true
      };
      
      setChartOfAccounts(prev => [...prev, newChart]);
      setSelectedChart(newChart);
      setIsModalOpen(false);
    }
  };

  const handleAddAccount = async () => {
    if (!formData.accountNumber || !formData.accountName || !formData.fslCategory) {
      alert('Please fill in all required fields');
      return;
    }

    try {
      // Convert custom fields array to object
      const customFields = {};
      customFieldsData.forEach(field => {
        if (field.name.trim() && field.value.trim()) {
          customFields[field.name.trim()] = field.value.trim();
        }
      });

      await axios.post(
        `${process.env.REACT_APP_API_URL}/api/chart-of-accounts/${selectedChart.id}/accounts`,
        {
          accountNumber: formData.accountNumber,
          accountName: formData.accountName,
          accountType: formData.accountType,
          fslCategory: formData.fslCategory,
          subledgerType: formData.subledgerType,
          description: formData.description,
          customFields
        },
        {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        }
      );
      
      fetchAccounts(selectedChart.id);
      setIsModalOpen(false);
    } catch (error) {
      console.error('Error adding account:', error);
      alert('Failed to add account');
      
      // For demo, simulate success
      const newAccount = {
        accountNumber: formData.accountNumber,
        accountName: formData.accountName,
        accountType: formData.accountType,
        fslCategory: formData.fslCategory,
        subledgerType: formData.subledgerType,
        description: formData.description,
        customFields
      };
      
      setAccounts(prev => [...prev, newAccount]);
      setIsModalOpen(false);
    }
  };

  const handleUpdateAccount = async () => {
    if (!formData.accountName || !formData.fslCategory) {
      alert('Please fill in all required fields');
      return;
    }

    try {
      // Convert custom fields array to object
      const customFields = {};
      customFieldsData.forEach(field => {
        if (field.name.trim() && field.value.trim()) {
          customFields[field.name.trim()] = field.value.trim();
        }
      });

      await axios.put(
        `${process.env.REACT_APP_API_URL}/api/chart-of-accounts/${selectedChart.id}/accounts/${formData.accountNumber}`,
        {
          accountName: formData.accountName,
          fslCategory: formData.fslCategory,
          subledgerType: formData.subledgerType,
          description: formData.description,
          customFields
        },
        {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        }
      );
      
      fetchAccounts(selectedChart.id);
      setIsModalOpen(false);
    } catch (error) {
      console.error('Error updating account:', error);
      alert('Failed to update account');
      
      // For demo, simulate success
      setAccounts(prev => prev.map(account => 
        account.accountNumber === formData.accountNumber
          ? { 
              ...account, 
              accountName: formData.accountName,
              fslCategory: formData.fslCategory,
              subledgerType: formData.subledgerType,
              description: formData.description
            }
          : account
      ));
      setIsModalOpen(false);
    }
  };

  const handleDeleteAccount = async (accountNumber) => {
    if (!confirm(`Are you sure you want to delete account ${accountNumber}?`)) {
      return;
    }

    try {
      await axios.delete(
        `${process.env.REACT_APP_API_URL}/api/chart-of-accounts/${selectedChart.id}/accounts/${accountNumber}`,
        {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        }
      );
      
      fetchAccounts(selectedChart.id);
    } catch (error) {
      console.error('Error deleting account:', error);
      alert('Failed to delete account');
      
      // For demo, simulate success
      setAccounts(prev => prev.filter(account => account.accountNumber !== accountNumber));
    }
  };

  const handleImportAccounts = async () => {
    if (!sourceChartId) {
      alert('Please select a source chart of accounts');
      return;
    }

    try {
      await axios.post(
        `${process.env.REACT_APP_API_URL}/api/chart-of-accounts/${selectedChart.id}/import`,
        { sourceChartId },
        {
          headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
        }
      );
      
      fetchAccounts(selectedChart.id);
      setIsModalOpen(false);
    } catch (error) {
      console.error('Error importing accounts:', error);
      alert('Failed to import accounts');
      
      // For demo, simulate success
      setIsModalOpen(false);
      fetchAccounts(selectedChart.id);
    }
  };

  const openAddChartModal = () => {
    setModalMode('chart');
    setModalAction('add');
    setFormData({
      name: '',
      description: '',
      entityId: entities.length > 0 ? entities[0].id : '',
      accountNumber: '',
      accountName: '',
      accountType: 'Asset',
      fslCategory: '',
      subledgerType: 'GL',
      description: ''
    });
    setIsModalOpen(true);
  };

  const openDefaultChartModal = () => {
    setModalMode('chart');
    setModalAction('default');
    setFormData({
      name: 'Default Chart of Accounts',
      description: '',
      entityId: entities.length > 0 ? entities[0].id : ''
    });
    setIsModalOpen(true);
  };

  const openAddAccountModal = () => {
    setModalMode('account');
    setModalAction('add');
    setFormData({
      ...formData,
      accountNumber: '',
      accountName: '',
      accountType: 'Asset',
      fslCategory: fsliCategories['Asset'] ? fsliCategories['Asset'][0] : '',
      subledgerType: 'GL',
      description: ''
    });
    setCustomFieldsData([{ name: '', value: '' }]);
    setIsModalOpen(true);
  };

  const openEditAccountModal = (account) => {
    setModalMode('account');
    setModalAction('edit');
    
    // Convert customFields object to array for form
    const customFieldsArray = [];
    if (account.customFields) {
      Object.entries(account.customFields).forEach(([name, value]) => {
        customFieldsArray.push({ name, value });
      });
    }
    
    if (customFieldsArray.length === 0) {
      customFieldsArray.push({ name: '', value: '' });
    }
    
    setFormData({
      ...formData,
      accountNumber: account.accountNumber,
      accountName: account.accountName,
      accountType: account.accountType,
      fslCategory: account.fslCategory,
      subledgerType: account.subledgerType || 'GL',
      description: account.description || ''
    });
    
    setCustomFieldsData(customFieldsArray);
    setIsModalOpen(true);
  };

  const openImportModal = () => {
    setModalMode('import');
    setSourceChartId('');
    setIsModalOpen(true);
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    
    // Special case for accountType, also update fslCategory
    if (name === 'accountType' && fsliCategories[value]) {
      setFormData({
        ...formData,
        [name]: value,
        fslCategory: fsliCategories[value][0] || ''
      });
    } else {
      setFormData({
        ...formData,
        [name]: value
      });
    }
  };

  const handleCustomFieldChange = (index, field, value) => {
    const newCustomFields = [...customFieldsData];
    newCustomFields[index] = {
      ...newCustomFields[index],
      [field]: value
    };
    
    setCustomFieldsData(newCustomFields);
  };

  const addCustomField = () => {
    setCustomFieldsData([...customFieldsData, { name: '', value: '' }]);
  };

  const removeCustomField = (index) => {
    if (customFieldsData.length === 1) {
      setCustomFieldsData([{ name: '', value: '' }]);
    } else {
      const newCustomFields = [...customFieldsData];
      newCustomFields.splice(index, 1);
      setCustomFieldsData(newCustomFields);
    }
  };

  const toggleExpandType = (type) => {
    setExpandedTypes({
      ...expandedTypes,
      [type]: !expandedTypes[type]
    });
  };

  const filteredAccounts = accounts.filter(account => {
    const searchLower = searchTerm.toLowerCase();
    return (
      account.accountNumber.toLowerCase().includes(searchLower) ||
      account.accountName.toLowerCase().includes(searchLower) ||
      account.fslCategory.toLowerCase().includes(searchLower)
    );
  });

  // Organize accounts by type
  const accountsByType = {};
  accountTypes.forEach(type => {
    accountsByType[type.id] = filteredAccounts.filter(account => account.accountType === type.id);
  });

  // Get entity name by ID
  const getEntityName = (entityId) => {
    const entity = entities.find(e => e.id === entityId);
    return entity ? entity.name : 'Unknown Entity';
  };

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-800">Chart of Accounts</h1>
        <div className="flex space-x-2">
          <button
            onClick={openAddChartModal}
            className="flex items-center bg-blue-800 text-white px-3 py-2 rounded-md hover:bg-blue-900"
          >
            <Plus size={16} className="mr-1" /> New Chart
          </button>
          <button
            onClick={openDefaultChartModal}
            className="flex items-center bg-green-700 text-white px-3 py-2 rounded-md hover:bg-green-800"
          >
            <FileText size={16} className="mr-1" /> Default Chart
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        {/* Chart of Accounts List */}
        <div className="md:col-span-1 bg-gray-50 p-4 rounded-lg">
          <h2 className="text-lg font-semibold mb-3">Available Charts</h2>
          {loading && chartOfAccounts.length === 0 ? (
            <div className="text-center py-4">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-800 mx-auto"></div>
              <p className="mt-2 text-sm text-gray-500">Loading charts...</p>
            </div>
          ) : chartOfAccounts.length === 0 ? (
            <div className="text-center py-4">
              <p className="text-gray-500">No charts available</p>
              <button
                onClick={openAddChartModal}
                className="mt-2 text-blue-800 hover:underline text-sm"
              >
                Create your first chart of accounts
              </button>
            </div>
          ) : (
            <ul className="space-y-2">
              {chartOfAccounts.map((chart) => (
                <li 
                  key={chart.id}
                  className={`p-3 rounded-md cursor-pointer transition-colors ${
                    selectedChart && selectedChart.id === chart.id
                      ? 'bg-blue-100 border-l-4 border-blue-800'
                      : 'hover:bg-gray-100'
                  }`}
                  onClick={() => setSelectedChart(chart)}
                >
                  <div className="font-medium text-gray-900">{chart.name}</div>
                  <div className="text-xs text-gray-500">
                    Entity: {getEntityName(chart.entityId)}
                  </div>
                  <div className="text-xs text-gray-500">
                    Version: {chart.version}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>

        {/* Accounts Display */}
        <div className="md:col-span-3">
          {selectedChart ? (
            <>
              <div className="bg-gray-50 p-4 rounded-lg mb-4">
                <div className="flex justify-between items-center">
                  <div>
                    <h2 className="text-lg font-semibold">{selectedChart.name}</h2>
                    <p className="text-sm text-gray-500">
                      Entity: {getEntityName(selectedChart.entityId)} | Version: {selectedChart.version}
                    </p>
                  </div>
                  <div className="flex space-x-2">
                    <button
                      onClick={openAddAccountModal}
                      className="flex items-center bg-blue-800 text-white px-3 py-2 rounded-md hover:bg-blue-900"
                    >
                      <Plus size={16} className="mr-1" /> Add Account
                    </button>
                    <button
                      onClick={openImportModal}
                      className="flex items-center bg-gray-700 text-white px-3 py-2 rounded-md hover:bg-gray-800"
                    >
                      <Copy size={16} className="mr-1" /> Import
                    </button>
                    <button
                      onClick={() => {}}
                      className="flex items-center bg-gray-100 text-gray-800 px-3 py-2 rounded-md hover:bg-gray-200"
                    >
                      <Download size={16} className="mr-1" /> Export
                    </button>
                  </div>
                </div>
              </div>

              <div className="mb-4 relative">
                <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                  <Search className="w-5 h-5 text-gray-400" />
                </div>
                <input
                  type="text"
                  className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
                  placeholder="Search accounts..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>

              {loading ? (
                <div className="text-center py-16">
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-800 mx-auto"></div>
                  <p className="mt-4 text-sm text-gray-500">Loading accounts...</p>
                </div>
              ) : accounts.length === 0 ? (
                <div className="text-center py-16 bg-gray-50 rounded-lg">
                  <FileText className="h-12 w-12 text-gray-400 mx-auto" />
                  <h3 className="mt-2 text-lg font-medium text-gray-900">No accounts found</h3>
                  <p className="mt-1 text-sm text-gray-500">
                    Get started by adding your first account or importing existing ones.
                  </p>
                  <div className="mt-6 flex justify-center space-x-4">
                    <button
                      onClick={openAddAccountModal}
                      className="bg-blue-800 text-white px-4 py-2 rounded-md hover:bg-blue-900"
                    >
                      Add Account
                    </button>
                    <button
                      onClick={openImportModal}
                      className="bg-gray-700 text-white px-4 py-2 rounded-md hover:bg-gray-800"
                    >
                      Import Accounts
                    </button>
                  </div>
                </div>
              ) : (
                <>
                  <div className="bg-white border rounded-lg overflow-hidden">
                    <div className="border-b">
                      {/* Account Type Headers */}
                      {accountTypes.map((type) => (
                        <div key={type.id} className="border-t first:border-t-0">
                          <button
                            className={`w-full text-left px-4 py-3 bg-gray-50 hover:bg-gray-100 focus:outline-none flex justify-between items-center ${
                              expandedTypes[type.id] ? 'font-semibold' : ''
                            }`}
                            onClick={() => toggleExpandType(type.id)}
                          >
                            <span>{type.label} Accounts ({accountsByType[type.id].length})</span>
                            {expandedTypes[type.id] ? (
                              <ChevronDown className="h-5 w-5 text-gray-500" />
                            ) : (
                              <ChevronRight className="h-5 w-5 text-gray-500" />
                            )}
                          </button>
                          
                          {/* Account List */}
                          {expandedTypes[type.id] && (
                            <div className="overflow-x-auto">
                              <table className="min-w-full divide-y divide-gray-200">
                                <thead className="bg-gray-100">
                                  <tr>
                                    <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                      Number
                                    </th>
                                    <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                      Name
                                    </th>
                                    <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                      FSLI Category
                                    </th>
                                    <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                      Subledger
                                    </th>
                                    <th scope="col" className="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                      Actions
                                    </th>
                                  </tr>
                                </thead>
                                <tbody className="bg-white divide-y divide-gray-200">
                                  {accountsByType[type.id].map((account) => (
                                    <tr key={`${type.id}-${account.accountNumber}`} className="hover:bg-gray-50">
                                      <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                                        {account.accountNumber}
                                      </td>
                                      <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-700">
                                        {account.accountName}
                                      </td>
                                      <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-700">
                                        {account.fslCategory}
                                      </td>
                                      <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-700">
                                        {account.subledgerType || 'GL'}
                                      </td>
                                      <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 text-right">
                                        <button
                                          onClick={() => openEditAccountModal(account)}
                                          className="text-blue-800 hover:text-blue-900 mx-1"
                                          title="Edit account"
                                        >
                                          <Edit2 className="h-4 w-4" />
                                        </button>
                                        <button
                                          onClick={() => handleDeleteAccount(account.accountNumber)}
                                          className="text-red-600 hover:text-red-700 mx-1"
                                          title="Delete account"
                                        >
                                          <Trash2 className="h-4 w-4" />
                                        </button>
                                      </td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                </>
              )}
            </>
          ) : (
            <div className="bg-gray-50 rounded-lg p-8 text-center">
              <FileText className="mx-auto h-12 w-12 text-gray-400" />
              <h3 className="mt-2 text-lg font-medium text-gray-900">No Chart Selected</h3>
              <p className="mt-1 text-sm text-gray-500">
                Select a chart of accounts from the left or create a new one.
              </p>
              <div className="mt-6">
                <button
                  onClick={openAddChartModal}
                  className="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-800 hover:bg-blue-900"
                >
                  <Plus size={16} className="-ml-1 mr-2" /> New Chart of Accounts
                </button>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Modal for adding/editing charts and accounts */}
      {isModalOpen && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            {/* Modal header */}
            <div className="mb-4">
              <h2 className="text-xl font-bold text-gray-800">
                {modalMode === 'chart' && modalAction === 'add' && 'Add New Chart of Accounts'}
                {modalMode === 'chart' && modalAction === 'default' && 'Create Default Chart of Accounts'}
                {modalMode === 'account' && modalAction === 'add' && 'Add New Account'}
                {modalMode === 'account' && modalAction === 'edit' && 'Edit Account'}
                {modalMode === 'import' && 'Import Accounts'}
              </h2>
            </div>

            {/* Modal content */}
            {modalMode === 'chart' && (
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Entity
                  </label>
                  <select
                    name="entityId"
                    value={formData.entityId}
                    onChange={handleInputChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  >
                    {entities.map((entity) => (
                      <option key={entity.id} value={entity.id}>
                        {entity.name}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Name
                  </label>
                  <input
                    type="text"
                    name="name"
                    value={formData.name}
                    onChange={handleInputChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Description
                  </label>
                  <textarea
                    name="description"
                    value={formData.description}
                    onChange={handleInputChange}
                    rows="2"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  ></textarea>
                </div>
              </div>
            )}

            {modalMode === 'account' && (
              <div className="space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700">
                      Account Number
                    </label>
                    <input
                      type="text"
                      name="accountNumber"
                      value={formData.accountNumber}
                      onChange={handleInputChange}
                      disabled={modalAction === 'edit'}
                      className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">
                      Account Type
                    </label>
                    <select
                      name="accountType"
                      value={formData.accountType}
                      onChange={handleInputChange}
                      disabled={modalAction === 'edit'}
                      className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 disabled:bg-gray-100"
                    >
                      {accountTypes.map((type) => (
                        <option key={type.id} value={type.id}>
                          {type.label}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Account Name
                  </label>
                  <input
                    type="text"
                    name="accountName"
                    value={formData.accountName}
                    onChange={handleInputChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    FSLI Category
                  </label>
                  <select
                    name="fslCategory"
                    value={formData.fslCategory}
                    onChange={handleInputChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  >
                    {fsliCategories[formData.accountType] ? (
                      fsliCategories[formData.accountType].map((category) => (
                        <option key={category} value={category}>
                          {category}
                        </option>
                      ))
                    ) : (
                      <option value="">Loading categories...</option>
                    )}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Subledger Type
                  </label>
                  <select
                    name="subledgerType"
                    value={formData.subledgerType}
                    onChange={handleInputChange}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  >
                    {subledgerTypes.map((type) => (
                      <option key={type.id} value={type.id}>
                        {type.label}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Description
                  </label>
                  <textarea
                    name="description"
                    value={formData.description}
                    onChange={handleInputChange}
                    rows="2"
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  ></textarea>
                </div>

                {/* Custom Fields Section */}
                <div>
                  <div className="flex justify-between items-center mb-2">
                    <label className="block text-sm font-medium text-gray-700">
                      Custom Fields
                    </label>
                    <button
                      type="button"
                      onClick={addCustomField}
                      className="text-xs text-blue-800 hover:text-blue-900"
                    >
                      + Add Field
                    </button>
                  </div>
                  
                  {customFieldsData.map((field, index) => (
                    <div key={index} className="flex items-center space-x-2 mb-2">
                      <input
                        type="text"
                        placeholder="Field Name"
                        value={field.name}
                        onChange={(e) => handleCustomFieldChange(index, 'name', e.target.value)}
                        className="flex-1 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm"
                      />
                      <input
                        type="text"
                        placeholder="Field Value"
                        value={field.value}
                        onChange={(e) => handleCustomFieldChange(index, 'value', e.target.value)}
                        className="flex-1 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 text-sm"
                      />
                      <button
                        type="button"
                        onClick={() => removeCustomField(index)}
                        className="text-red-500 hover:text-red-700"
                      >
                        <Trash2 className="h-4 w-4" />
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {modalMode === 'import' && (
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Source Chart of Accounts
                  </label>
                  <select
                    value={sourceChartId}
                    onChange={(e) => setSourceChartId(e.target.value)}
                    className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  >
                    <option value="">Select source chart</option>
                    {chartOfAccounts
                      .filter(chart => chart.id !== selectedChart?.id)
                      .map((chart) => (
                        <option key={chart.id} value={chart.id}>
                          {chart.name} ({getEntityName(chart.entityId)})
                        </option>
                      ))}
                  </select>
                </div>
                <p className="text-sm text-gray-600">
                  This will import all accounts from the selected chart that don't already exist in the current chart.
                </p>
              </div>
            )}

            {/* Modal footer */}
            <div className="mt-6 flex justify-end space-x-3">
              <button
                type="button"
                onClick={() => setIsModalOpen(false)}
                className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
              >
                Cancel
              </button>

              {modalMode === 'chart' && modalAction === 'add' && (
                <button
                  type="button"
                  onClick={handleCreateChart}
                  className="px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900"
                >
                  Create Chart
                </button>
              )}

              {modalMode === 'chart' && modalAction === 'default' && (
                <button
                  type="button"
                  onClick={handleCreateDefaultChart}
                  className="px-4 py-2 bg-green-700 text-white rounded-md hover:bg-green-800"
                >
                  Create Default Chart
                </button>
              )}

              {modalMode === 'account' && modalAction === 'add' && (
                <button
                  type="button"
                  onClick={handleAddAccount}
                  className="px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900"
                >
                  Add Account
                </button>
              )}

              {modalMode === 'account' && modalAction === 'edit' && (
                <button
                  type="button"
                  onClick={handleUpdateAccount}
                  className="px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900"
                >
                  Update Account
                </button>
              )}

              {modalMode === 'import' && (
                <button
                  type="button"
                  onClick={handleImportAccounts}
                  className="px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900"
                >
                  Import Accounts
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ChartOfAccountsManager;



================================================
File: client/src/components/accounting/FixedAssetManager.jsx
================================================
// src/components/accounting/FixedAssetManager.jsx
import React, { useState, useEffect } from 'react';
import { Plus, Edit2, Trash2, Search, ChevronDown, ChevronUp, Printer, Download } from 'lucide-react';
import axios from 'axios';

const FixedAssetManager = () => {
  const [assets, setAssets] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedAsset, setSelectedAsset] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [sortField, setSortField] = useState('name');
  const [sortDirection, setSortDirection] = useState('asc');
  const [searchTerm, setSearchTerm] = useState('');
  const [categoryFilter, setCategoryFilter] = useState('all');
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    assetCategory: 'equipment',
    acquisitionDate: '',
    acquisitionCost: '',
    depreciationMethod: 'straight-line',
    usefulLife: '',
    salvageValue: '0',
  });

  const categories = [
    { id: 'equipment', label: 'Equipment' },
    { id: 'furniture', label: 'Furniture & Fixtures' },
    { id: 'vehicles', label: 'Vehicles' },
    { id: 'buildings', label: 'Buildings' },
    { id: 'land', label: 'Land' },
    { id: 'computers', label: 'Computers & IT' },
    { id: 'software', label: 'Software' },
    { id: 'other', label: 'Other' }
  ];

  const depreciationMethods = [
    { id: 'straight-line', label: 'Straight Line' },
    { id: 'declining-balance', label: 'Declining Balance' },
    { id: 'units-of-production', label: 'Units of Production' }
  ];

  useEffect(() => {
    fetchAssets();
  }, []);

  const fetchAssets = async () => {
    setLoading(true);
    try {
      // This will need to be replaced with your actual API endpoint
      const response = await axios.get(`${process.env.REACT_APP_API_URL}/api/accounting/fixed-assets`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      });
      
      if (response.data && response.data.assets) {
        setAssets(response.data.assets);
      }
    } catch (error) {
      console.error('Error fetching assets:', error);
      // For demo/development, use sample data
      setAssets([
        {
          id: '1',
          name: 'Dell XPS Laptop',
          description: 'Development laptop for engineering team',
          assetCategory: 'computers',
          acquisitionDate: '2024-01-15',
          acquisitionCost: 1899.99,
          depreciationMethod: 'straight-line',
          usefulLife: 36, // months
          salvageValue: 300,
          currentBookValue: 1766.66,
          disposed: false
        },
        {
          id: '2',
          name: 'Office Furniture Set',
          description: 'Reception area furniture',
          assetCategory: 'furniture',
          acquisitionDate: '2023-11-05',
          acquisitionCost: 4500,
          depreciationMethod: 'straight-line',
          usefulLife: 60, // months
          salvageValue: 500,
          currentBookValue: 4300,
          disposed: false
        },
        {
          id: '3',
          name: 'Company Vehicle',
          description: 'Ford Transit delivery van',
          assetCategory: 'vehicles',
          acquisitionDate: '2023-08-20',
          acquisitionCost: 32000,
          depreciationMethod: 'declining-balance',
          usefulLife: 84, // months
          salvageValue: 5000,
          currentBookValue: 29142.86,
          disposed: false
        }
      ]);
    } finally {
      setLoading(false);
    }
  };

  const handleSort = (field) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const getSortIcon = (field) => {
    if (sortField !== field) return null;
    return sortDirection === 'asc' ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />;
  };

  const sortedAssets = () => {
    let filtered = [...assets];
    
    // Apply search filter
    if (searchTerm) {
      filtered = filtered.filter(asset => 
        asset.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        asset.description.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Apply category filter
    if (categoryFilter !== 'all') {
      filtered = filtered.filter(asset => asset.assetCategory === categoryFilter);
    }
    
    // Sort the filtered results
    return filtered.sort((a, b) => {
      let aValue = a[sortField];
      let bValue = b[sortField];
      
      if (typeof aValue === 'string') {
        aValue = aValue.toLowerCase();
        bValue = bValue.toLowerCase();
      }
      
      if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const openAddModal = () => {
    setSelectedAsset(null);
    setFormData({
      name: '',
      description: '',
      assetCategory: 'equipment',
      acquisitionDate: '',
      acquisitionCost: '',
      depreciationMethod: 'straight-line',
      usefulLife: '',
      salvageValue: '0',
    });
    setIsModalOpen(true);
  };

  const openEditModal = (asset) => {
    setSelectedAsset(asset);
    setFormData({
      name: asset.name,
      description: asset.description,
      assetCategory: asset.assetCategory,
      acquisitionDate: asset.acquisitionDate,
      acquisitionCost: asset.acquisitionCost.toString(),
      depreciationMethod: asset.depreciationMethod,
      usefulLife: asset.usefulLife.toString(),
      salvageValue: asset.salvageValue.toString(),
    });
    setIsModalOpen(true);
  };

  const openDeleteModal = (asset) => {
    setSelectedAsset(asset);
    setIsDeleteModalOpen(true);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate form data
    if (!formData.name || !formData.acquisitionDate || !formData.acquisitionCost || !formData.usefulLife) {
      alert('Please fill in all required fields');
      return;
    }
    
    try {
      const payload = {
        ...formData,
        acquisitionCost: parseFloat(formData.acquisitionCost),
        usefulLife: parseInt(formData.usefulLife),
        salvageValue: parseFloat(formData.salvageValue) || 0
      };
      
      if (selectedAsset) {
        // Update existing asset
        await axios.put(
          `${process.env.REACT_APP_API_URL}/api/accounting/fixed-assets/${selectedAsset.id}`,
          payload,
          {
            headers: {
              Authorization: `Bearer ${localStorage.getItem('token')}`
            }
          }
        );
      } else {
        // Create new asset
        await axios.post(
          `${process.env.REACT_APP_API_URL}/api/accounting/fixed-assets`,
          payload,
          {
            headers: {
              Authorization: `Bearer ${localStorage.getItem('token')}`
            }
          }
        );
      }
      
      // Refresh the asset list
      fetchAssets();
      setIsModalOpen(false);
    } catch (error) {
      console.error('Error saving asset:', error);
      alert('Failed to save asset. Please try again.');
      
      // For demo purposes, simulate successful save
      if (selectedAsset) {
        setAssets(prev => prev.map(a => a.id === selectedAsset.id ? {...a, ...formData} : a));
      } else {
        const newAsset = {
          id: Date.now().toString(),
          ...formData,
          acquisitionCost: parseFloat(formData.acquisitionCost),
          usefulLife: parseInt(formData.usefulLife),
          salvageValue: parseFloat(formData.salvageValue) || 0,
          currentBookValue: parseFloat(formData.acquisitionCost),
          disposed: false
        };
        setAssets(prev => [...prev, newAsset]);
      }
      setIsModalOpen(false);
    }
  };

  const handleDelete = async () => {
    if (!selectedAsset) return;
    
    try {
      await axios.delete(
        `${process.env.REACT_APP_API_URL}/api/accounting/fixed-assets/${selectedAsset.id}`,
        {
          headers: {
            Authorization: `Bearer ${localStorage.getItem('token')}`
          }
        }
      );
      
      // Refresh the asset list
      fetchAssets();
      setIsDeleteModalOpen(false);
    } catch (error) {
      console.error('Error deleting asset:', error);
      alert('Failed to delete asset. Please try again.');
      
      // For demo purposes, simulate successful delete
      setAssets(prev => prev.filter(a => a.id !== selectedAsset.id));
      setIsDeleteModalOpen(false);
    }
  };

  const handleDispose = async (asset) => {
    try {
      const response = await axios.put(
        `${process.env.REACT_APP_API_URL}/api/accounting/fixed-assets/${asset.id}/dispose`,
        {
          disposalDate: new Date().toISOString().split('T')[0],
          disposalValue: 0
        },
        {
          headers: {
            Authorization: `Bearer ${localStorage.getItem('token')}`
          }
        }
      );
      
      // Refresh the asset list
      fetchAssets();
    } catch (error) {
      console.error('Error disposing asset:', error);
      alert('Failed to dispose asset. Please try again.');
      
      // For demo purposes, simulate successful dispose
      setAssets(prev => prev.map(a => a.id === asset.id ? {...a, disposed: true} : a));
    }
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
  };

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };

  const getCategoryName = (categoryId) => {
    const category = categories.find(c => c.id === categoryId);
    return category ? category.label : categoryId;
  };

  const getDepreciationMethodName = (methodId) => {
    const method = depreciationMethods.find(m => m.id === methodId);
    return method ? method.label : methodId;
  };

  // Calculate total book value of all assets
  const totalBookValue = assets.reduce((sum, asset) => sum + (asset.disposed ? 0 : asset.currentBookValue), 0);

  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-800">Fixed Asset Management</h1>
        <div className="flex items-center space-x-2">
          <button
            onClick={() => {}}
            className="px-3 py-2 flex items-center text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200"
          >
            <Printer className="w-4 h-4 mr-1" />
            <span>Print</span>
          </button>
          <button
            onClick={() => {}}
            className="px-3 py-2 flex items-center text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200"
          >
            <Download className="w-4 h-4 mr-1" />
            <span>Export</span>
          </button>
          <button
            onClick={openAddModal}
            className="px-3 py-2 flex items-center text-white bg-blue-800 rounded-md hover:bg-blue-900"
          >
            <Plus className="w-4 h-4 mr-1" />
            <span>Add Asset</span>
          </button>
        </div>
      </div>
      
      <div className="bg-blue-50 p-4 rounded-lg mb-6">
        <div className="flex flex-wrap items-center justify-between gap-4">
          <div className="relative flex-grow max-w-md">
            <div className="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
              <Search className="w-5 h-5 text-gray-400" />
            </div>
            <input
              type="text"
              className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
              placeholder="Search assets..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
          
          <div className="flex items-center space-x-2">
            <label htmlFor="category-filter" className="text-sm font-medium text-gray-700">Category:</label>
            <select
              id="category-filter"
              className="bg-white border border-gray-300 rounded-md px-3 py-2 focus:ring-blue-500 focus:border-blue-500"
              value={categoryFilter}
              onChange={(e) => setCategoryFilter(e.target.value)}
            >
              <option value="all">All Categories</option>
              {categories.map((category) => (
                <option key={category.id} value={category.id}>{category.label}</option>
              ))}
            </select>
          </div>
        </div>
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg mb-6">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div className="bg-white p-4 rounded-lg shadow-sm">
            <h3 className="text-sm font-medium text-gray-500">Total Assets</h3>
            <p className="text-2xl font-semibold text-gray-900">{assets.length}</p>
          </div>
          <div className="bg-white p-4 rounded-lg shadow-sm">
            <h3 className="text-sm font-medium text-gray-500">Active Assets</h3>
            <p className="text-2xl font-semibold text-gray-900">{assets.filter(a => !a.disposed).length}</p>
          </div>
          <div className="bg-white p-4 rounded-lg shadow-sm">
            <h3 className="text-sm font-medium text-gray-500">Disposed Assets</h3>
            <p className="text-2xl font-semibold text-gray-900">{assets.filter(a => a.disposed).length}</p>
          </div>
          <div className="bg-white p-4 rounded-lg shadow-sm">
            <h3 className="text-sm font-medium text-gray-500">Total Book Value</h3>
            <p className="text-2xl font-semibold text-gray-900">{formatCurrency(totalBookValue)}</p>
          </div>
        </div>
      </div>
      
      {loading ? (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-800"></div>
        </div>
      ) : (
        <>
          {assets.length === 0 ? (
            <div className="text-center py-12">
              <h3 className="text-lg font-medium text-gray-900">No assets found</h3>
              <p className="text-gray-500 mt-2">Get started by adding your first asset.</p>
              <button
                onClick={openAddModal}
                className="mt-4 px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900"
              >
                Add Asset
              </button>
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full border-collapse">
                <thead>
                  <tr className="bg-gray-100">
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('name')}>
                      <div className="flex items-center">
                        Asset Name
                        {getSortIcon('name')}
                      </div>
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('assetCategory')}>
                      <div className="flex items-center">
                        Category
                        {getSortIcon('assetCategory')}
                      </div>
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('acquisitionDate')}>
                      <div className="flex items-center">
                        Purchase Date
                        {getSortIcon('acquisitionDate')}
                      </div>
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('acquisitionCost')}>
                      <div className="flex items-center">
                        Cost
                        {getSortIcon('acquisitionCost')}
                      </div>
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer" onClick={() => handleSort('currentBookValue')}>
                      <div className="flex items-center">
                        Book Value
                        {getSortIcon('currentBookValue')}
                      </div>
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Status
                    </th>
                    <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {sortedAssets().map((asset) => (
                    <tr key={asset.id} className={asset.disposed ? "bg-gray-50" : ""}>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="flex items-center">
                          <div>
                            <div className="text-sm font-medium text-gray-900">{asset.name}</div>
                            <div className="text-sm text-gray-500">{asset.description}</div>
                          </div>
                        </div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{getCategoryName(asset.assetCategory)}</div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{formatDate(asset.acquisitionDate)}</div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{formatCurrency(asset.acquisitionCost)}</div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <div className="text-sm text-gray-900">{formatCurrency(asset.currentBookValue)}</div>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap">
                        <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                          asset.disposed
                            ? 'bg-gray-100 text-gray-800'
                            : 'bg-green-100 text-green-800'
                        }`}>
                          {asset.disposed ? 'Disposed' : 'Active'}
                        </span>
                      </td>
                      <td className="px-4 py-3 whitespace-nowrap text-right text-sm font-medium">
                        <div className="flex justify-end space-x-2">
                          <button
                            onClick={() => openEditModal(asset)}
                            className="text-blue-800 hover:text-blue-900"
                          >
                            <Edit2 className="w-4 h-4" />
                          </button>
                          {!asset.disposed && (
                            <button
                              onClick={() => handleDispose(asset)}
                              className="text-yellow-600 hover:text-yellow-700"
                              title="Mark as disposed"
                            >
                              Dispose
                            </button>
                          )}
                          <button
                            onClick={() => openDeleteModal(asset)}
                            className="text-red-600 hover:text-red-700"
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </>
      )}
      
      {/* Add/Edit Asset Modal */}
      {isModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">{selectedAsset ? 'Edit Asset' : 'Add New Asset'}</h2>
            <form onSubmit={handleSubmit}>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700">Asset Name*</label>
                  <input
                    type="text"
                    name="name"
                    value={formData.name}
                    onChange={handleInputChange}
                    className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700">Description</label>
                  <textarea
                    name="description"
                    value={formData.description}
                    onChange={handleInputChange}
                    rows="2"
                    className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                  ></textarea>
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700">Category*</label>
                  <select
                    name="assetCategory"
                    value={formData.assetCategory}
                    onChange={handleInputChange}
                    className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  >
                    {categories.map((category) => (
                      <option key={category.id} value={category.id}>{category.label}</option>
                    ))}
                  </select>
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700">Acquisition Date*</label>
                  <input
                    type="date"
                    name="acquisitionDate"
                    value={formData.acquisitionDate}
                    onChange={handleInputChange}
                    className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700">Acquisition Cost*</label>
                  <div className="mt-1 relative rounded-md shadow-sm">
                    <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <span className="text-gray-500">$</span>
                    </div>
                    <input
                      type="number"
                      name="acquisitionCost"
                      value={formData.acquisitionCost}
                      onChange={handleInputChange}
                      className="block w-full pl-7 border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                      step="0.01"
                      min="0"
                      required
                    />
                  </div>
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700">Depreciation Method*</label>
                  <select
                    name="depreciationMethod"
                    value={formData.depreciationMethod}
                    onChange={handleInputChange}
                    className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  >
                    {depreciationMethods.map((method) => (
                      <option key={method.id} value={method.id}>{method.label}</option>
                    ))}
                  </select>
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700">Useful Life (months)*</label>
                  <input
                    type="number"
                    name="usefulLife"
                    value={formData.usefulLife}
                    onChange={handleInputChange}
                    className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                    min="1"
                    required
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700">Salvage Value</label>
                  <div className="mt-1 relative rounded-md shadow-sm">
                    <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <span className="text-gray-500">$</span>
                    </div>
                    <input
                      type="number"
                      name="salvageValue"
                      value={formData.salvageValue}
                      onChange={handleInputChange}
                      className="block w-full pl-7 border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500"
                      step="0.01"
                      min="0"
                    />
                  </div>
                </div>
              </div>
              
              <div className="mt-6 flex justify-end space-x-3">
                <button
                  type="button"
                  onClick={() => setIsModalOpen(false)}
                  className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900"
                >
                  {selectedAsset ? 'Update Asset' : 'Add Asset'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
      
      {/* Delete Confirmation Modal */}
      {isDeleteModalOpen && selectedAsset && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">Confirm Delete</h2>
            <p className="mb-4">
              Are you sure you want to delete <span className="font-semibold">{selectedAsset.name}</span>?
              This action cannot be undone.
            </p>
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => setIsDeleteModalOpen(false)}
                className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
              >
                Cancel
              </button>
              <button
                onClick={handleDelete}
                className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default FixedAssetManager;



================================================
File: client/src/components/common/ChatWidget.jsx
================================================
// src/components/common/ChatWidget.jsx
import React, { useState, useEffect, useRef } from 'react';
import { X } from 'lucide-react';
import axios from 'axios';

export default function ChatWidget({ isOpen, setIsOpen }) {
  const [chatMessages, setChatMessages] = useState([
    { text: "Hi there! How can I help with your financial needs today?", sender: 'ai' }
  ]);
  const [chatInput, setChatInput] = useState('');
  const chatRef = useRef(null);

  useEffect(() => {
    if (chatRef.current) chatRef.current.scrollTop = chatRef.current.scrollHeight;
  }, [chatMessages]);

  const handleChatSubmit = async (e) => {
    e.preventDefault();
    if (!chatInput.trim()) return;
    const userMessage = { text: chatInput, sender: 'user' };
    setChatMessages(prev => [...prev, userMessage]);
    setChatInput('');
    const token = localStorage.getItem('token');
    try {
      const response = await axios.post(`${process.env.REACT_APP_API_URL}/api/chat`, { message: chatInput }, {
        headers: token ? { Authorization: `Bearer ${token}` } : {}
      });
      setChatMessages(prev => [...prev, { text: response.data.reply, sender: 'ai' }]);
    } catch (error) {
      setChatMessages(prev => [...prev, { text: 'Sorry, something went wrong.', sender: 'ai' }]);
    }
  };

  return (
    <div className="fixed bottom-4 right-4 z-40">
      <button onClick={() => setIsOpen(!isOpen)} className="bg-blue-800 text-white p-3 rounded-full shadow-lg hover:bg-blue-900 transition duration-200">
        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 10h8m-4-4v8m9 4a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      </button>
      {isOpen && (
        <div className="absolute bottom-16 right-0 w-80 sm:w-96 bg-white rounded-lg shadow-xl overflow-hidden">
          <div className="flex justify-between items-center p-4 border-b">
            <h3 className="text-lg font-semibold text-blue-800">Chat with Us</h3>
            <button onClick={() => setIsOpen(false)} className="text-gray-500 hover:text-gray-700">
              <X size={20} />
            </button>
          </div>
          <div ref={chatRef} className="h-64 overflow-y-auto p-4 space-y-3">
            {chatMessages.map((msg, index) => (
              <div key={index} className={`p-2 rounded-lg max-w-[80%] ${msg.sender === 'user' ? 'bg-blue-100 ml-auto' : 'bg-gray-100'}`}>
                {msg.text}
              </div>
            ))}
          </div>
          <form onSubmit={handleChatSubmit} className="border-t p-4 flex">
            <input
              type="text"
              value={chatInput}
              onChange={(e) => setChatInput(e.target.value)}
              className="flex-1 border rounded-l-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Ask us anything..."
            />
            <button type="submit" className="bg-blue-800 text-white px-4 py-2 rounded-r-md hover:bg-blue-900 transition duration-200">
              Send
            </button>
          </form>
        </div>
      )}
    </div>
  );
}



================================================
File: client/src/components/dashboard/CashFlowChart.jsx
================================================
// src/components/dashboard/CashFlowChart.jsx
import React from 'react';
import { Line } from 'react-chartjs-2';

export default function CashFlowChart({ cashFlow }) {
  const chartData = {
    labels: cashFlow.labels,
    datasets: [{
      label: 'Cash Flow',
      data: cashFlow.data,
      borderColor: '#1E3A8A',
      tension: 0.1,
    }],
  };

  return (
    <div>
      <h3 className="text-xl font-semibold text-gray-900 mb-3">Cash Flow</h3>
      <Line data={chartData} options={{ responsive: true, scales: { y: { beginAtZero: true } } }} />
    </div>
  );
}



================================================
File: client/src/components/dashboard/ClientChat.jsx
================================================
// src/components/dashboard/ClientChat.jsx
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';

export default function ClientChat({ messages, setMessages }) {
  const [isOpen, setIsOpen] = useState(false);
  const [inputText, setInputText] = useState('');
  const chatRef = useRef(null);

  useEffect(() => {
    if (chatRef.current) chatRef.current.scrollTop = chatRef.current.scrollHeight;
  }, [messages]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!inputText.trim()) return;
    
    const userMessage = { text: inputText, sender: 'user' };
    setMessages(prev => [...prev, userMessage]);
    setInputText('');
    
    try {
      const response = await axios.post(
        `${process.env.REACT_APP_API_URL}/api/client/chat`, 
        { message: inputText }, 
        { headers: { Authorization: `Bearer ${localStorage.getItem('token')}` } }
      );
      setMessages(prev => [...prev, { text: response.data.reply, sender: 'ai' }]);
    } catch (error) {
      setMessages(prev => [...prev, { text: 'For detailed advice, schedule a consultation!', sender: 'ai' }]);
    }
  };

  return (
    <div>
      <h3 className="text-xl font-semibold text-gray-900 mb-3">Chat with Us</h3>
      <button 
        onClick={() => setIsOpen(!isOpen)} 
        className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 transition duration-200"
      >
        {isOpen ? 'Close Chat' : 'Open Chat'}
      </button>
      
      {isOpen && (
        <div className="mt-4 bg-gray-50 p-4 rounded-lg shadow-sm">
          <div ref={chatRef} className="h-64 overflow-y-auto space-y-3 mb-4">
            {messages.map((msg, index) => (
              <div key={index} className={`p-2 rounded-lg max-w-[80%] ${msg.sender === 'user' ? 'bg-blue-100 ml-auto' : 'bg-gray-100'}`}>
                {msg.text}
              </div>
            ))}
          </div>
          <form onSubmit={handleSubmit} className="flex space-x-2">
            <input
              type="text"
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
              className="flex-1 border rounded-l-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Ask a question..."
            />
            <button 
              type="submit" 
              className="bg-blue-800 text-white px-4 py-2 rounded-r-md hover:bg-blue-900 transition duration-200"
            >
              Send
            </button>
          </form>
        </div>
      )}
    </div>
  );
}



================================================
File: client/src/components/dashboard/CustomReports.jsx
================================================
// src/components/dashboard/CustomReports.jsx
import React from 'react';

export default function CustomReports({ reports }) {
  return (
    <div>
      <h3 className="text-xl font-semibold text-gray-900 mb-3">Custom Reports</h3>
      <select className="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
        {reports.map((report, index) => (
          <option key={index} value={report}>{report}</option>
        ))}
      </select>
    </div>
  );
}



================================================
File: client/src/components/dashboard/DownloadSection.jsx
================================================
// src/components/dashboard/DownloadSection.jsx
import React from 'react';

export default function DownloadSection() {
  return (
    <div>
      <h3 className="text-xl font-semibold text-gray-900 mb-3">Download Deliverables</h3>
      <button className="bg-blue-800 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-900 transition duration-200">
        Download Latest Report
      </button>
    </div>
  );
}



================================================
File: client/src/components/dashboard/FileUpload.jsx
================================================
// src/components/dashboard/FileUpload.jsx
import React, { useState, useRef } from 'react';
import axios from 'axios';
import { Upload, Check, AlertCircle, X, File } from 'lucide-react';

export default function FileUpload({ onSuccess }) {
  const [files, setFiles] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [uploadStatus, setUploadStatus] = useState(null);
  const fileInputRef = useRef(null);
  const dropzoneRef = useRef(null);

  const getFileIcon = (fileType) => {
    // Using just the standard File icon from lucide-react 
    // instead of specific file type icons that don't exist
    return <File size={20} />;
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    dropzoneRef.current.classList.add('border-blue-500', 'bg-blue-50');
    dropzoneRef.current.classList.remove('border-gray-300', 'bg-gray-50');
  };

  const handleDragLeave = () => {
    dropzoneRef.current.classList.remove('border-blue-500', 'bg-blue-50');
    dropzoneRef.current.classList.add('border-gray-300', 'bg-gray-50');
  };

  const handleDrop = (e) => {
    e.preventDefault();
    handleDragLeave();
    
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFiles(e.dataTransfer.files);
    }
  };

  const handleFileSelect = (e) => {
    if (e.target.files && e.target.files.length > 0) {
      handleFiles(e.target.files);
    }
  };

  const handleFiles = (selectedFiles) => {
    const newFiles = [...files];
    
    for (let i = 0; i < selectedFiles.length; i++) {
      // Add file if it doesn't already exist in the array
      if (!files.some(f => f.name === selectedFiles[i].name && f.size === selectedFiles[i].size)) {
        newFiles.push(selectedFiles[i]);
      }
    }
    
    setFiles(newFiles);
  };

  const removeFile = (index) => {
    const newFiles = [...files];
    newFiles.splice(index, 1);
    setFiles(newFiles);
  };

  const uploadFiles = async () => {
    if (files.length === 0) return;
    
    setUploading(true);
    setUploadStatus(null);
    
    try {
      const token = localStorage.getItem('token');
      const promises = files.map(file => {
        const formData = new FormData();
        formData.append('file', file);
        
        return axios.post(`${process.env.REACT_APP_API_URL}/api/upload`, formData, {
          headers: { 
            Authorization: `Bearer ${token}`,
            'Content-Type': 'multipart/form-data'
          },
        });
      });
      
      await Promise.all(promises);
      
      setUploadStatus({
        success: true,
        message: `Successfully uploaded ${files.length} file${files.length !== 1 ? 's' : ''}`
      });
      
      setFiles([]);
      
      if (onSuccess) onSuccess();
    } catch (error) {
      console.error('Upload failed:', error);
      setUploadStatus({
        success: false,
        message: 'Upload failed. Please check your connection and try again.'
      });
    } finally {
      setUploading(false);
    }
  };

  return (
    <div>
      <h3 className="text-xl font-semibold text-gray-900 mb-3">Upload Financial Documents</h3>
      
      {/* Dropzone */}
      <div 
        ref={dropzoneRef}
        className="border-2 border-dashed border-gray-300 rounded-lg p-6 bg-gray-50 text-center transition-colors duration-200"
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
      >
        <Upload className="mx-auto h-12 w-12 text-gray-400" />
        <p className="mt-2 text-gray-700">Drag and drop your files here, or</p>
        <button 
          type="button"
          onClick={() => fileInputRef.current.click()}
          className="mt-2 inline-flex items-center px-4 py-2 bg-blue-800 text-white rounded-md hover:bg-blue-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
        >
          Choose Files
        </button>
        <p className="mt-1 text-sm text-gray-500">
          Supported formats: PDF, Excel, CSV
        </p>
        <input 
          type="file"
          multiple
          ref={fileInputRef}
          onChange={handleFileSelect}
          className="hidden"
          accept=".pdf,.xls,.xlsx,.csv,.doc,.docx"
        />
      </div>
      
      {/* File List */}
      {files.length > 0 && (
        <div className="mt-4">
          <h4 className="font-medium text-gray-700 mb-2">Selected Files</h4>
          <div className="space-y-2 max-h-60 overflow-y-auto p-1">
            {files.map((file, idx) => (
              <div 
                key={`${file.name}-${idx}`} 
                className="flex items-center justify-between bg-white p-3 rounded-md shadow-sm border"
              >
                <div className="flex items-center">
                  {getFileIcon(file.type)}
                  <div className="ml-3">
                    <p className="text-sm font-medium text-gray-800 truncate max-w-xs">{file.name}</p>
                    <p className="text-xs text-gray-500">{(file.size / 1024).toFixed(1)} KB</p>
                  </div>
                </div>
                <button 
                  type="button" 
                  onClick={() => removeFile(idx)}
                  className="text-gray-500 hover:text-red-500"
                >
                  <X size={18} />
                </button>
              </div>
            ))}
          </div>
          
          <div className="mt-4 flex items-center justify-between">
            <button
              type="button"
              onClick={uploadFiles}
              disabled={uploading}
              className={`
                flex items-center px-4 py-2 rounded-md 
                ${uploading 
                  ? 'bg-gray-300 cursor-not-allowed text-gray-700' 
                  : 'bg-blue-800 hover:bg-blue-900 text-white'}
              `}
            >
              {uploading ? 'Uploading...' : `Upload ${files.length} File${files.length !== 1 ? 's' : ''}`}
            </button>
            
            <button
              type="button"
              onClick={() => setFiles([])}
              className="px-4 py-2 text-gray-700 hover:text-gray-900"
            >
              Clear All
            </button>
          </div>
        </div>
      )}
      
      {/* Status Message */}
      {uploadStatus && (
        <div className={`mt-4 p-3 rounded-md ${
          uploadStatus.success ? 'bg-green-50 text-green-800' : 'bg-red-50 text-red-800'
        }`}>
          <div className="flex items-center">
            {uploadStatus.success 
              ? <Check size={18} className="mr-2" /> 
              : <AlertCircle size={18} className="mr-2" />}
            <p>{uploadStatus.message}</p>
          </div>
        </div>
      )}
    </div>
  );
}



================================================
File: client/src/components/dashboard/FinancialOverview.jsx
================================================
// src/components/dashboard/FinancialOverview.jsx
import React from 'react';

export default function FinancialOverview({ financials }) {
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(amount);
  };

  return (
    <div>
      <h3 className="text-xl font-semibold text-gray-900 mb-3">Financial Overview</h3>
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div className="bg-blue-50 p-4 rounded-lg">
          <p className="text-gray-700 text-sm mb-1">Profit & Loss (YTD)</p>
          <div className="flex flex-col sm:flex-row sm:items-center justify-between sm:space-x-2">
            <div className="mb-2 sm:mb-0">
              <span className="block text-sm font-medium text-gray-500">Revenue</span>
              <span className="text-lg font-semibold text-gray-900">{formatCurrency(financials.profitLoss.revenue)}</span>
            </div>
            <div className="mb-2 sm:mb-0">
              <span className="block text-sm font-medium text-gray-500">Expenses</span>
              <span className="text-lg font-semibold text-gray-900">{formatCurrency(financials.profitLoss.expenses)}</span>
            </div>
            <div>
              <span className="block text-sm font-medium text-gray-500">Net Income</span>
              <span className="text-lg font-semibold text-blue-800">{formatCurrency(financials.profitLoss.netIncome)}</span>
            </div>
          </div>
        </div>
        <div className="bg-green-50 p-4 rounded-lg">
          <p className="text-gray-700 text-sm mb-1">Balance Sheet</p>
          <div className="flex flex-col sm:flex-row sm:items-center justify-between sm:space-x-2">
            <div className="mb-2 sm:mb-0">
              <span className="block text-sm font-medium text-gray-500">Assets</span>
              <span className="text-lg font-semibold text-gray-900">{formatCurrency(financials.balanceSheet.assets)}</span>
            </div>
            <div className="mb-2 sm:mb-0">
              <span className="block text-sm font-medium text-gray-500">Liabilities</span>
              <span className="text-lg font-semibold text-gray-900">{formatCurrency(financials.balanceSheet.liabilities)}</span>
            </div>
            <div>
              <span className="block text-sm font-medium text-gray-500">Equity</span>
              <span className="text-lg font-semibold text-green-700">{formatCurrency(financials.balanceSheet.equity)}</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
File: client/src/components/dashboard/GeneralLedger.jsx
================================================
// src/components/dashboard/GeneralLedger.jsx
import React, { useState } from 'react';

export default function GeneralLedger({ entries }) {
  const [visibleEntries, setVisibleEntries] = useState(5);
  
  const loadMore = () => {
    setVisibleEntries(prev => prev + 5);
  };
  
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0
    }).format(amount);
  };

  return (
    <div>
      <h3 className="text-xl font-semibold text-gray-900 mb-3">General Ledger</h3>
      
      {/* Mobile Card View */}
      <div className="md:hidden space-y-3">
        {entries.slice(0, visibleEntries).map((entry, index) => (
          <div key={index} className="bg-gray-50 p-3 rounded-lg shadow-sm">
            <div className="flex justify-between items-center mb-1">
              <span className="text-sm text-gray-500">{entry.date}</span>
              <span className="font-semibold text-blue-800">{formatCurrency(entry.amount)}</span>
            </div>
            <p className="text-gray-700">{entry.description}</p>
          </div>
        ))}
        
        {visibleEntries < entries.length && (
          <button 
            onClick={loadMore}
            className="w-full py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors text-sm"
          >
            Load More Entries
          </button>
        )}
      </div>
      
      {/* Desktop Table View */}
      <div className="hidden md:block overflow-x-auto">
        <table className="w-full text-sm text-left text-gray-700">
          <thead className="bg-gray-100">
            <tr>
              <th className="px-4 py-2">Date</th>
              <th className="px-4 py-2">Description</th>
              <th className="px-4 py-2 text-right">Amount</th>
            </tr>
          </thead>
          <tbody>
            {entries.map((entry, index) => (
              <tr key={index} className="border-b hover:bg-gray-50">
                <td className="px-4 py-2">{entry.date}</td>
                <td className="px-4 py-2">{entry.description}</td>
                <td className="px-4 py-2 text-right">{formatCurrency(entry.amount)}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}



================================================
File: client/src/components/form/CompanyInformationStep.jsx
================================================
// src/components/form/CompanyInformationStep.jsx
import React from 'react';

export default function CompanyInformationStep({ formData, handleInputChange, fields }) {
  return (
    <div className="space-y-6">
      {fields.map((field) => (
        <div key={field.name} className="space-y-2">
          <label className="block text-sm font-medium text-gray-700">
            {field.label} {field.required && <span className="text-red-500">*</span>}
          </label>
          {field.type === 'select' ? (
            <select
              name={field.name}
              value={formData[field.name]}
              onChange={handleInputChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              required={field.required}
            >
              <option value="">Select an option</option>
              {field.options.map((option) => (
                <option key={option} value={option}>{option}</option>
              ))}
            </select>
          ) : field.type === 'textarea' ? (
            <textarea
              name={field.name}
              value={formData[field.name]}
              onChange={handleInputChange}
              rows={4}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              required={field.required}
            />
          ) : (
            <input
              type={field.type}
              name={field.name}
              value={formData[field.name]}
              onChange={handleInputChange}
              className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
              required={field.required}
            />
          )}
        </div>
      ))}
    </div>
  );
}



================================================
File: client/src/components/form/FormNavigation.jsx
================================================
// src/components/form/FormNavigation.jsx
import React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';

export default function FormNavigation({
  currentStep,
  totalSteps,
  prevStep,
  nextStep,
  isStepValid,
  isSubmitting
}) {
  return (
    <div className="mt-8 flex justify-between">
      {currentStep > 0 && (
        <button 
          type="button" 
          onClick={prevStep} 
          className="flex items-center px-4 py-2 text-blue-800 hover:text-blue-900 transition duration-200"
        >
          <ChevronLeft className="w-5 h-5 mr-1" /> Previous
        </button>
      )}
      <button
        type={currentStep === totalSteps - 1 ? 'submit' : 'button'}
        onClick={currentStep < totalSteps - 1 ? nextStep : undefined}
        disabled={!isStepValid() || isSubmitting}
        className={`ml-auto px-6 py-2 rounded-lg font-semibold transition duration-200 ${
          isStepValid() && !isSubmitting
            ? 'bg-blue-800 text-white hover:bg-blue-900' 
            : 'bg-gray-300 text-gray-500 cursor-not-allowed'
        }`}
      >
        {isSubmitting ? 'Submitting...' : currentStep === totalSteps - 1 ? 'Submit' : 'Next'}
        {currentStep < totalSteps - 1 && <ChevronRight className="w-5 h-5 ml-1" />}
      </button>
    </div>
  );
}



================================================
File: client/src/components/form/FormProgress.jsx
================================================
// src/components/form/FormProgress.jsx
import React from 'react';
import { Check } from 'lucide-react';

export default function FormProgress({ steps, currentStep }) {
  return (
    <div className="flex justify-between mb-8">
      {steps.map((step, index) => (
        <div key={index} className="flex items-center">
          <div className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${
            index === currentStep ? 'bg-blue-800 text-white' :
            index < currentStep ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-600'
          }`}>
            {index < currentStep ? <Check size={16} /> : index + 1}
          </div>
          {index < steps.length - 1 && (
            <div className={`h-1 w-12 sm:w-16 ${index < currentStep ? 'bg-green-500' : 'bg-gray-200'}`} />
          )}
        </div>
      ))}
    </div>
  );
}



================================================
File: client/src/components/form/ServicesSelectionStep.jsx
================================================
// src/components/form/ServicesSelectionStep.jsx
import React from 'react';
import { Check } from 'lucide-react';

export default function ServicesSelectionStep({ formData, handleServiceToggle, servicesList }) {
  return (
    <div className="space-y-4">
      {servicesList.map((service) => (
        <div
          key={service.id}
          className="flex items-start p-4 bg-gray-50 rounded-lg hover:bg-gray-100 cursor-pointer transition duration-200"
          onClick={() => handleServiceToggle(service.id)}
        >
          <div className="flex items-center h-5">
            <div className={`w-5 h-5 border rounded flex items-center justify-center ${
              formData.services.includes(service.id) ? 'bg-blue-600 border-blue-600' : 'border-gray-300'
            }`}>
              {formData.services.includes(service.id) && <Check className="w-4 h-4 text-white" />}
            </div>
          </div>
          <div className="ml-3 flex-1">
            <label className="text-sm font-medium text-gray-900 cursor-pointer">{service.title}</label>
            <p className="text-sm text-gray-600">{service.description}</p>
          </div>
        </div>
      ))}
    </div>
  );
}



================================================
File: client/src/components/journal/ActionButtons.jsx
================================================
// src/components/journal/ActionButtons.jsx
import React, { useRef } from 'react';
import { PlusCircle, Upload, Save } from 'lucide-react';
import SupportingDocuments from './SupportingDocuments';

export default function ActionButtons({
  addEntryRow,
  supportingDocs,
  handleFileUpload,
  isSubmitting
}) {
  const fileInputRef = useRef(null);
  
  return (
    <>
      {/* Add Line Button and Supporting Documents */}
      <div className="flex justify-between items-start">
        <button
          type="button"
          onClick={addEntryRow}
          className="flex items-center text-blue-600 hover:text-blue-800"
        >
          <PlusCircle size={18} className="mr-1" /> Add Line
        </button>
        
        <SupportingDocuments supportingDocs={supportingDocs} />
      </div>
      
      {/* Submit and Upload Buttons */}
      <div className="flex justify-between">
        <div>
          <input
            type="file"
            ref={fileInputRef}
            onChange={(e) => handleFileUpload(e.target.files[0])}
            className="hidden"
            accept=".pdf,.xls,.xlsx,.csv,.doc,.docx"
          />
          <button 
            type="button"
            onClick={() => fileInputRef.current.click()}
            className="bg-gray-100 hover:bg-gray-200 text-gray-800 px-5 py-2 rounded-md transition duration-200 flex items-center justify-center"
          >
            <Upload className="mr-2 h-5 w-5" /> Upload Supporting Document
          </button>
        </div>
        
        <button 
          type="submit"
          disabled={isSubmitting}
          className={`${isSubmitting ? 'bg-blue-400' : 'bg-blue-800 hover:bg-blue-900'} text-white px-6 py-2 rounded-md transition duration-200 flex items-center justify-center`}
        >
          {isSubmitting ? 'Saving...' : 'Post Journal Entry'} <Save className="ml-2 h-5 w-5" />
        </button>
      </div>
    </>
  );
}



================================================
File: client/src/components/journal/JournalEntriesTable.jsx
================================================
// src/components/journal/JournalEntriesTable.jsx
import React from 'react';
import { ChevronDown, ChevronUp } from 'lucide-react';
import JournalEntryRow from './JournalEntryRow';

export default function JournalEntriesTable({
  journalData,
  entryErrors,
  handleEntryChange,
  handleAccountSelect,
  removeEntryRow,
  totals,
  errors,
  showDetailFields,
  setShowDetailFields,
  showAdvancedFields,
  accountsList,
  getSubledgerBadge
}) {
  return (
    <>
      {/* Detail Fields Toggle */}
      <div className="flex justify-end">
        <button 
          type="button"
          onClick={() => setShowDetailFields(!showDetailFields)}
          className="text-blue-600 hover:text-blue-800 flex items-center"
        >
          {showDetailFields ? <ChevronUp size={16} className="mr-1" /> : <ChevronDown size={16} className="mr-1" />}
          {showDetailFields ? 'Hide Detail Fields' : 'Show Detail Fields'}
        </button>
      </div>
      
      {/* Journal Entries Table */}
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead className="bg-gray-100">
            <tr>
              <th className="py-2 px-3 text-left w-16">Line No</th>
              <th className="py-2 px-3 text-left">Account No *</th>
              <th className="py-2 px-3 text-left">Account Title *</th>
              {showDetailFields && (
                <>
                  <th className="py-2 px-3 text-left">Vendor</th>
                  <th className="py-2 px-3 text-left">Document No</th>
                  {showAdvancedFields && (
                    <>
                      <th className="py-2 px-3 text-left">Department</th>
                      <th className="py-2 px-3 text-left">Project</th>
                    </>
                  )}
                </>
              )}
              <th className="py-2 px-3 text-right">Debit</th>
              <th className="py-2 px-3 text-right">Credit</th>
              <th className="py-2 px-3 text-left">Description</th>
              <th className="py-2 px-3 w-10"></th>
            </tr>
          </thead>
          <tbody>
            {journalData.entries.map((entry, index) => (
              <JournalEntryRow
                key={entry.id}
                entry={entry}
                entryErrors={entryErrors[index]}
                handleEntryChange={handleEntryChange}
                handleAccountSelect={handleAccountSelect}
                removeEntryRow={removeEntryRow}
                showDetailFields={showDetailFields}
                showAdvancedFields={showAdvancedFields}
                accountsList={accountsList}
                getSubledgerBadge={getSubledgerBadge}
              />
            ))}
            
            {/* Totals row */}
            <tr className="bg-gray-50 font-semibold">
              <td colSpan={showDetailFields ? (showAdvancedFields ? 7 : 5) : 3} className="py-2 px-3 text-right">Totals</td>
              <td className="py-2 px-3 text-right">${totals.debit.toFixed(2)}</td>
              <td className="py-2 px-3 text-right">${totals.credit.toFixed(2)}</td>
              <td colSpan={2}></td>
            </tr>
          </tbody>
        </table>
        
        {/* Balance check */}
        {errors.balance && (
          <p className="text-red-500 mt-2 font-medium">{errors.balance}</p>
        )}
        
        {totals.isBalanced && totals.debit > 0 && (
          <p className="text-green-600 mt-2 font-medium">✓ Debits and credits are balanced</p>
        )}
      </div>
    </>
  );
}



================================================
File: client/src/components/journal/JournalEntryRow.jsx
================================================
// src/components/journal/JournalEntryRow.jsx
import React from 'react';
import { Trash2 } from 'lucide-react';

export default function JournalEntryRow({
  entry,
  entryErrors,
  handleEntryChange,
  handleAccountSelect,
  removeEntryRow,
  showDetailFields,
  showAdvancedFields,
  accountsList,
  getSubledgerBadge
}) {
  return (
    <tr className="border-b">
      <td className="py-2 px-3">
        <input
          type="text"
          value={entry.lineNo}
          readOnly
          className="w-full bg-gray-50 border border-gray-300 rounded-md p-2"
        />
      </td>
      <td className="py-2 px-3">
        <div className="relative">
          <input
            type="text"
            value={entry.accountNo}
            onChange={(e) => handleEntryChange(entry.id, 'accountNo', e.target.value)}
            placeholder="1000"
            className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            list={`accounts-${entry.id}`}
          />
          <datalist id={`accounts-${entry.id}`}>
            {accountsList.map(account => (
              <option key={account.accountNumber} value={account.accountNumber}>
                {account.accountName}
              </option>
            ))}
          </datalist>
          {getSubledgerBadge(entry.accountNo)}
        </div>
        {entryErrors?.accountNo && (
          <p className="text-red-500 text-sm">{entryErrors.accountNo}</p>
        )}
      </td>
      <td className="py-2 px-3">
        <input
          type="text"
          value={entry.accountTitle}
          onChange={(e) => handleEntryChange(entry.id, 'accountTitle', e.target.value)}
          placeholder="Cash"
          className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        {entryErrors?.accountTitle && (
          <p className="text-red-500 text-sm">{entryErrors.accountTitle}</p>
        )}
      </td>
      {showDetailFields && (
        <>
          <td className="py-2 px-3">
            <input
              type="text"
              value={entry.vendor}
              onChange={(e) => handleEntryChange(entry.id, 'vendor', e.target.value)}
              placeholder="Vendor name"
              className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </td>
          <td className="py-2 px-3">
            <input
              type="text"
              value={entry.documentNo}
              onChange={(e) => handleEntryChange(entry.id, 'documentNo', e.target.value)}
              placeholder="INV-123"
              className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </td>
          {showAdvancedFields && (
            <>
              <td className="py-2 px-3">
                <input
                  type="text"
                  value={entry.department}
                  onChange={(e) => handleEntryChange(entry.id, 'department', e.target.value)}
                  placeholder="Dept."
                  className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </td>
              <td className="py-2 px-3">
                <input
                  type="text"
                  value={entry.project}
                  onChange={(e) => handleEntryChange(entry.id, 'project', e.target.value)}
                  placeholder="Project"
                  className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </td>
            </>
          )}
        </>
      )}
      <td className="py-2 px-3">
        <input
          type="number"
          value={entry.debit}
          onChange={(e) => handleEntryChange(entry.id, 'debit', e.target.value)}
          placeholder="0.00"
          step="0.01"
          min="0"
          className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 text-right"
        />
      </td>
      <td className="py-2 px-3">
        <input
          type="number"
          value={entry.credit}
          onChange={(e) => handleEntryChange(entry.id, 'credit', e.target.value)}
          placeholder="0.00"
          step="0.01"
          min="0"
          className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500 text-right"
        />
        {entryErrors?.amount && (
          <p className="text-red-500 text-sm">{entryErrors.amount}</p>
        )}
      </td>
      <td className="py-2 px-3">
        <input
          type="text"
          value={entry.description}
          onChange={(e) => handleEntryChange(entry.id, 'description', e.target.value)}
          placeholder="Line description"
          className="w-full border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </td>
      <td className="py-2 px-3">
        <button
          type="button"
          onClick={() => removeEntryRow(entry.id)}
          className="text-red-500 hover:text-red-700 p-1"
          title="Remove line"
        >
          <Trash2 size={18} />
        </button>
      </td>
    </tr>
  );
}



================================================
File: client/src/components/journal/JournalHeader.jsx
================================================
// src/components/journal/JournalHeader.jsx
import React from 'react';
import { ChevronDown, ChevronUp } from 'lucide-react';

export default function JournalHeader({ 
  journalData, 
  errors, 
  handleChange, 
  showAdvancedFields, 
  setShowAdvancedFields 
}) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 p-4 bg-gray-50 rounded-lg">
      <div className="flex flex-col">
        <label htmlFor="date" className="text-gray-700 font-medium mb-1">Date *</label>
        <input
          type="date"
          id="date"
          name="date"
          value={journalData.date}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-required="true"
        />
        {errors.date && <p className="text-red-500 text-sm mt-1">{errors.date}</p>}
      </div>
      
      <div className="flex flex-col">
        <label htmlFor="transactionNo" className="text-gray-700 font-medium mb-1">Transaction No.</label>
        <input
          type="text"
          id="transactionNo"
          name="transactionNo"
          value={journalData.transactionNo}
          onChange={handleChange}
          className="border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
      </div>
      
      <div className="flex flex-col md:col-span-1">
        <button 
          type="button"
          onClick={() => setShowAdvancedFields(!showAdvancedFields)}
          className="text-blue-600 hover:text-blue-800 flex items-center self-end mt-2"
        >
          {showAdvancedFields ? <ChevronUp size={16} className="mr-1" /> : <ChevronDown size={16} className="mr-1" />}
          {showAdvancedFields ? 'Hide Advanced Fields' : 'Show Advanced Fields'}
        </button>
      </div>
      
      <div className="flex flex-col md:col-span-3">
        <label htmlFor="description" className="text-gray-700 font-medium mb-1">Description *</label>
        <textarea
          id="description"
          name="description"
          value={journalData.description}
          onChange={handleChange}
          rows={2}
          className="border border-gray-300 rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-required="true"
        />
        {errors.description && <p className="text-red-500 text-sm mt-1">{errors.description}</p>}
      </div>
    </div>
  );
}



================================================
File: client/src/components/journal/SupportingDocuments.jsx
================================================
// src/components/journal/SupportingDocuments.jsx
import React from 'react';

export default function SupportingDocuments({ supportingDocs }) {
  if (supportingDocs.length === 0) return null;
  
  return (
    <div className="bg-gray-50 p-3 rounded-lg">
      <h3 className="text-sm font-medium mb-2">Supporting Documents:</h3>
      <ul className="text-sm">
        {supportingDocs.map((doc, idx) => (
          <li key={idx} className="text-gray-700">
            {doc.name} ({(doc.size / 1024).toFixed(1)} KB)
          </li>
        ))}
      </ul>
    </div>
  );
}



================================================
File: client/src/components/modals/ChecklistModal.jsx
================================================
// src/components/modals/ChecklistModal.jsx
import React from 'react';
import { useFormData } from '../../hooks/useFormData';
import axios from 'axios';

const checklistFormFields = [
  { name: "name", label: "Your Name", type: "text", required: true },
  { name: "email", label: "Email Address", type: "email", required: true },
  { name: "companyName", label: "Company Name", type: "text", required: true },
  { name: "revenueRange", label: "Annual Revenue Range", type: "select", options: ["Under $100K", "$100K - $250K", "$250K - $500K", "$500K - $1M", "Over $1M"], required: true },
];

export default function ChecklistModal({ isOpen, onClose }) {
  const [checklistData, handleChecklistInputChange, _, resetChecklistForm] = useFormData({
    name: '', email: '', companyName: '', revenueRange: '',
  });

  const isChecklistValid = () => 
    checklistFormFields.every(field => field.required ? checklistData[field.name]?.trim() !== '' : true);

  const handleChecklistSubmit = async (e) => {
    e.preventDefault();
    if (!isChecklistValid()) return alert('Please fill out all required fields.');
    try {
      await axios.post(`${process.env.REACT_APP_API_URL}/api/checklist`, checklistData);
      alert('Thank you! Your Financial Checklist has been sent to your email!');
      onClose();
      resetChecklistForm();
    } catch (error) {
      alert('Submission failed. Please try again.');
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md sm:max-w-lg">
        <h2 className="text-2xl font-bold text-blue-800 mb-4">Get Your Free Financial Checklist</h2>
        <p className="text-gray-700 mb-6">Please provide your details to download the checklist!</p>
        <form onSubmit={handleChecklistSubmit} className="space-y-6">
          {checklistFormFields.map((field) => (
            <div key={field.name} className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">
                {field.label} {field.required && <span className="text-red-500">*</span>}
              </label>
              {field.type === 'select' ? (
                <select
                  name={field.name}
                  value={checklistData[field.name]}
                  onChange={handleChecklistInputChange}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  required={field.required}
                >
                  <option value="">Select an option</option>
                  {field.options.map((option) => (
                    <option key={option} value={option}>{option}</option>
                  ))}
                </select>
              ) : (
                <input
                  type={field.type}
                  name={field.name}
                  value={checklistData[field.name]}
                  onChange={handleChecklistInputChange}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                  required={field.required}
                />
              )}
            </div>
          ))}
          <div className="flex justify-end space-x-4">
            <button type="button" onClick={onClose} className="text-gray-700 hover:text-blue-800">Cancel</button>
            <button 
              type="submit" 
              className="bg-blue-800 text-white px-6 py-2 rounded-lg font-semibold hover:bg-blue-900 transition duration-200" 
              disabled={!isChecklistValid()}
            >
              Submit & Download
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}



================================================
File: client/src/components/sections/AboutSection.jsx
================================================
// src/components/sections/AboutSection.jsx
import React from 'react';

export default function AboutSection({ aboutText }) {
  return (
    <section id="about" className="py-16 bg-gray-100">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 w-full text-center">
        <h2 className="text-3xl font-bold text-blue-800 mb-8">About Wilcox Advisors</h2>
        <p className="text-lg text-gray-700 max-w-3xl mx-auto">{aboutText}</p>
      </div>
    </section>
  );
}



================================================
File: client/src/components/sections/BlogSection.jsx
================================================
// src/components/sections/BlogSection.jsx
import React from 'react';

export default function BlogSection({ blogPosts }) {
  return (
    <section id="blog" className="py-16 bg-white">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 w-full">
        <h2 className="text-3xl font-bold text-blue-800 mb-10 text-center">Blog & Updates</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          {blogPosts.map((post) => (
            <div key={post._id} className="bg-gray-50 p-6 rounded-lg shadow-sm">
              <h3 className="text-xl font-semibold text-gray-900 mb-2">{post.title}</h3>
              <div className="text-gray-700" dangerouslySetInnerHTML={{ __html: post.content }} />
              <p className="mt-4 text-blue-800 font-medium">
                <a href="#contact">Contact us to learn more!</a>
              </p>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}



================================================
File: client/src/components/sections/ChecklistSection.jsx
================================================
// src/components/sections/ChecklistSection.jsx
import React from 'react';

export default function ChecklistSection({ setShowChecklistForm }) {
  return (
    <section className="py-16 bg-gray-100">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 w-full text-center">
        <h2 className="text-3xl font-bold text-blue-800 mb-4">Free Financial Checklist</h2>
        <p className="text-lg text-gray-700 mb-6 max-w-2xl mx-auto">
          Download our checklist to streamline your small business finances—simple steps to save time and money!
        </p>
        <button 
          onClick={() => setShowChecklistForm(true)} 
          className="bg-blue-800 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-900 transition duration-200"
        >
          Get It Now
        </button>
      </div>
    </section>
  );
}



================================================
File: client/src/components/sections/ContactSection.jsx
================================================
// src/components/sections/ContactSection.jsx
import React from 'react';
import { useFormData } from '../../hooks/useFormData';
import axios from 'axios';

export default function ContactSection() {
  const [contactData, handleContactInputChange, _, resetContactForm] = useFormData({
    name: '', email: '', company: '', message: '',
  });

  const isContactValid = () => 
    Object.values(contactData).every(value => value.trim() !== '');

  const handleContactSubmit = async (e) => {
    e.preventDefault();
    if (!isContactValid()) return alert('Please fill out all required fields.');
    try {
      await axios.post(`${process.env.REACT_APP_API_URL}/api/contact`, contactData);
      alert('Thank you for your message! We will get back to you soon.');
      resetContactForm();
    } catch (error) {
      alert('Submission failed. Please try again.');
    }
  };

  return (
    <section id="contact" className="py-16 bg-gray-50">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 w-full">
        <h2 className="text-3xl font-bold text-blue-800 mb-10 text-center">Contact Us</h2>
        <div className="bg-white p-6 rounded-lg shadow-md max-w-2xl mx-auto">
          <p className="text-gray-700 mb-6 text-center">
            Have questions about our services? Send us a message and we'll get back to you as soon as possible.
          </p>
          <form onSubmit={handleContactSubmit} className="space-y-6">
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">Your Name <span className="text-red-500">*</span></label>
              <input
                type="text"
                name="name"
                value={contactData.name}
                onChange={handleContactInputChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                required
              />
            </div>
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">Email Address <span className="text-red-500">*</span></label>
              <input
                type="email"
                name="email"
                value={contactData.email}
                onChange={handleContactInputChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                required
              />
            </div>
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">Company <span className="text-red-500">*</span></label>
              <input
                type="text"
                name="company"
                value={contactData.company}
                onChange={handleContactInputChange}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                required
              />
            </div>
            <div className="space-y-2">
              <label className="block text-sm font-medium text-gray-700">Message <span className="text-red-500">*</span></label>
              <textarea
                name="message"
                value={contactData.message}
                onChange={handleContactInputChange}
                rows={4}
                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                required
              />
            </div>
            <button
              type="submit"
              className="w-full bg-blue-800 text-white px-6 py-3 rounded-md font-semibold hover:bg-blue-900 transition duration-200"
              disabled={!isContactValid()}
            >
              Send Message
            </button>
          </form>
        </div>
      </div>
    </section>
  );
}



================================================
File: client/src/components/sections/HeroSection.jsx
================================================
// src/components/sections/HeroSection.jsx
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { useUI } from '../../contexts/UIContext';

export default function HeroSection({ dashboardData, setShowConsultationForm }) {
  const navigate = useNavigate();
  const uiContext = useUI();

  const handleScheduleConsultation = () => {
    console.log('Button clicked!');
    
    // Try to use context if available
    if (uiContext && typeof uiContext.setShowConsultationForm === 'function') {
      console.log('Setting consultation form to true (context)');
      uiContext.setShowConsultationForm(true);
    } else {
      console.log('UI Context not available or setShowConsultationForm is not a function');
    }
    
    // Also use prop if available (for backward compatibility)
    if (typeof setShowConsultationForm === 'function') {
      setShowConsultationForm(true);
      console.log('Setting consultation form to true (prop)');
    }
  };

  return (
    <div className="bg-gradient-to-r from-blue-800 to-blue-900 text-white py-20">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 w-full">
        <div className="w-full md:w-2/3">
          <h1 className="text-4xl md:text-5xl font-bold mb-6">{dashboardData.hero.headline}</h1>
          <p className="text-xl mb-8">{dashboardData.hero.subtext}</p>
          <div className="space-x-4">
            <button
              onClick={handleScheduleConsultation}
              className="bg-white text-blue-800 px-6 py-3 rounded-lg font-semibold hover:bg-gray-100 transition duration-200"
            >
              Schedule Free Consultation
            </button>
            <button
              onClick={() => navigate('/learn-more')}
              className="border-2 border-white text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-800 transition duration-200"
            >
              Learn More
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
File: client/src/components/sections/ServicesSection.jsx
================================================
// src/components/sections/ServicesSection.jsx
import React from 'react';

export default function ServicesSection({ servicesList }) {
  return (
    <section id="services" className="py-16 bg-gray-50">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 w-full">
        <h2 className="text-3xl font-bold text-blue-800 mb-10 text-center">Our Small Business Services</h2>
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
          {servicesList.map((service) => (
            <div key={service.id} className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition duration-200">
              <h3 className="text-xl font-semibold text-gray-900 mb-3">{service.title}</h3>
              <p className="text-gray-600">{service.description}</p>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}



================================================
File: client/src/components/sections/TestimonialsSection.jsx
================================================
// src/components/sections/TestimonialsSection.jsx
import React from 'react';

export default function TestimonialsSection() {
  return (
    <section className="py-16 bg-white">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 w-full">
        <h2 className="text-3xl font-bold text-blue-800 mb-10 text-center">What Small Businesses Say</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div className="bg-gray-50 p-6 rounded-lg shadow-sm">
            <p className="text-gray-700 italic">"Wilcox Advisors made our finances manageable—perfect for my small shop!"</p>
            <p className="mt-4 text-gray-900 font-medium">— Local Retail Owner</p>
          </div>
          <div className="bg-gray-50 p-6 rounded-lg shadow-sm">
            <p className="text-gray-700 italic">"Their cash flow help kept my startup alive. Amazing support!"</p>
            <p className="mt-4 text-gray-900 font-medium">— Tech Founder</p>
          </div>
        </div>
      </div>
    </section>
  );
}



================================================
File: client/src/components/website/AboutTab.jsx
================================================
// components/website/AboutTab.jsx
import React from 'react';
import { PlusCircle } from 'lucide-react';

export default function AboutTab() {
  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold">About Us Content</h3>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Company Description</h4>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            About Us Text
          </label>
          <textarea
            defaultValue="At Wilcox Advisors, we specialize in financial solutions for small businesses. From startups to growing companies, we provide the expertise you need to succeed—built to scale with you every step of the way."
            className="w-full p-2 border rounded"
            rows={6}
          />
        </div>
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Team Members</h4>
        
        <div className="bg-white p-4 rounded border mb-4">
          <div className="flex justify-between">
            <p className="font-medium">John Smith</p>
            <div>
              <button className="text-blue-800 hover:text-blue-900 mr-2">
                Edit
              </button>
              <button className="text-red-600 hover:text-red-700">
                Remove
              </button>
            </div>
          </div>
          <p className="text-sm text-gray-700">Senior Financial Advisor</p>
        </div>
        
        <div className="bg-white p-4 rounded border">
          <div className="flex justify-between">
            <p className="font-medium">Emily Rodriguez</p>
            <div>
              <button className="text-blue-800 hover:text-blue-900 mr-2">
                Edit
              </button>
              <button className="text-red-600 hover:text-red-700">
                Remove
              </button>
            </div>
          </div>
          <p className="text-sm text-gray-700">Tax Specialist</p>
        </div>
        
        <button className="mt-4 flex items-center text-blue-800 hover:text-blue-900">
          <PlusCircle size={16} className="mr-1" />
          Add Team Member
        </button>
      </div>
    </div>
  );
}



================================================
File: client/src/components/website/ContactTab.jsx
================================================
// components/website/ContactTab.jsx
import React from 'react';

export default function ContactTab() {
  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold">Contact Information</h3>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Business Information</h4>
        
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Business Email
            </label>
            <input
              type="email"
              defaultValue="contact@wilcoxadvisors.com"
              className="w-full p-2 border rounded"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Phone Number
            </label>
            <input
              type="tel"
              defaultValue="(555) 123-4567"
              className="w-full p-2 border rounded"
            />
          </div>
        </div>
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Business Address</h4>
        
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Street Address
          </label>
          <input
            type="text"
            defaultValue="123 Business Avenue, Suite 400"
            className="w-full p-2 border rounded"
          />
        </div>
        
        <div className="grid grid-cols-3 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              City
            </label>
            <input
              type="text"
              defaultValue="Metropolis"
              className="w-full p-2 border rounded"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              State
            </label>
            <input
              type="text"
              defaultValue="NY"
              className="w-full p-2 border rounded"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              ZIP Code
            </label>
            <input
              type="text"
              defaultValue="10001"
              className="w-full p-2 border rounded"
            />
          </div>
        </div>
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Social Media Links</h4>
        
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              LinkedIn
            </label>
            <input
              type="url"
              defaultValue="https://linkedin.com/company/wilcox-advisors"
              className="w-full p-2 border rounded"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Twitter
            </label>
            <input
              type="url"
              defaultValue="https://twitter.com/wilcoxadvisors"
              className="w-full p-2 border rounded"
            />
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
File: client/src/components/website/GeneralTab.jsx
================================================
// components/website/GeneralTab.jsx
import React, { useState } from 'react';
import { Upload, Image } from 'lucide-react';

export default function GeneralTab() {
  const [logoFile, setLogoFile] = useState(null);
  
  const handleLogoChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setLogoFile(URL.createObjectURL(e.target.files[0]));
    }
  };
  
  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold">General Settings</h3>
      
      {/* Logo Upload */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Website Logo</h4>
        <div className="flex items-center space-x-4">
          <div className="w-32 h-32 bg-gray-200 flex items-center justify-center rounded border overflow-hidden">
            {logoFile ? (
              <img src={logoFile} alt="New logo preview" className="max-w-full max-h-full object-contain" />
            ) : (
              <div className="text-center text-gray-500">
                <Image size={32} className="mx-auto mb-1" />
                <p className="text-xs">Current Logo</p>
              </div>
            )}
          </div>
          <div>
            <div className="mb-2">
              <label className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 cursor-pointer">
                <Upload size={16} className="inline mr-2" />
                Select New Logo
                <input 
                  type="file" 
                  className="hidden" 
                  accept="image/*" 
                  onChange={handleLogoChange}
                />
              </label>
            </div>
            <p className="text-sm text-gray-500">Recommended size: 180x60 pixels, PNG or SVG format</p>
          </div>
        </div>
      </div>

      {/* Site Title & Meta */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Website Title & Meta Tags</h4>
        
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Site Title
          </label>
          <input
            type="text"
            defaultValue="Wilcox Advisors - Financial Solutions for Small Businesses"
            className="w-full p-2 border rounded"
          />
          <p className="text-xs text-gray-500 mt-1">Appears in browser tabs and search results</p>
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Meta Description
          </label>
          <textarea
            defaultValue="Wilcox Advisors provides professional financial and accounting services tailored for small businesses, helping you save money and drive business growth."
            className="w-full p-2 border rounded"
            rows={3}
          />
          <p className="text-xs text-gray-500 mt-1">Appears in search engine results</p>
        </div>
      </div>
      
      {/* Colors Section */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Brand Colors</h4>
        
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Primary Color
            </label>
            <div className="flex items-center">
              <input
                type="color"
                defaultValue="#1E3A8A"
                className="h-10 w-10 p-0 border-0"
              />
              <input
                type="text"
                defaultValue="#1E3A8A"
                className="ml-2 p-2 border rounded w-full"
              />
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Secondary Color
            </label>
            <div className="flex items-center">
              <input
                type="color"
                defaultValue="#0EA5E9"
                className="h-10 w-10 p-0 border-0"
              />
              <input
                type="text"
                defaultValue="#0EA5E9"
                className="ml-2 p-2 border rounded w-full"
              />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
File: client/src/components/website/HomePageTab.jsx
================================================
// components/website/HomePageTab.jsx
import React, { useState } from 'react';
import { Upload, Image, PlusCircle } from 'lucide-react';

export default function HomePageTab() {
  const [heroImage, setHeroImage] = useState(null);
  
  const handleImageChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setHeroImage(URL.createObjectURL(e.target.files[0]));
    }
  };
  
  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold">Home Page Content</h3>
      
      {/* Hero Section */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <div className="flex justify-between items-center mb-2">
          <h4 className="font-medium">Hero Section</h4>
        </div>
        
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Headline
          </label>
          <input
            type="text"
            defaultValue="Financial Expertise for Your Business Success"
            className="w-full p-2 border rounded"
          />
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Subheading
          </label>
          <textarea
            defaultValue="Professional accounting and financial services tailored for small businesses. We handle the numbers so you can focus on growth."
            className="w-full p-2 border rounded"
            rows={3}
          />
        </div>
      </div>
      
      {/* Hero Image */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Hero Background Image</h4>
        
        <div className="flex items-center space-x-4">
          <div className="w-32 h-24 bg-gray-200 rounded border overflow-hidden">
            {heroImage ? (
              <img src={heroImage} alt="Hero image preview" className="w-full h-full object-cover" />
            ) : (
              <div className="text-center pt-4 text-gray-500">
                <Image size={24} className="mx-auto mb-1" />
                <p className="text-xs">Current Image</p>
              </div>
            )}
          </div>
          <div>
            <div className="mb-2">
              <label className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 cursor-pointer">
                <Upload size={16} className="inline mr-2" />
                Select New Image
                <input 
                  type="file" 
                  className="hidden" 
                  accept="image/*" 
                  onChange={handleImageChange}
                />
              </label>
            </div>
            <p className="text-sm text-gray-500">Recommended size: 1920x600 pixels</p>
          </div>
        </div>
      </div>
      
      {/* Call to Action Buttons */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Call to Action Buttons</h4>
        
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Primary Button Text
            </label>
            <input
              type="text"
              defaultValue="Schedule Free Consultation"
              className="w-full p-2 border rounded"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Secondary Button Text
            </label>
            <input
              type="text"
              defaultValue="Learn More"
              className="w-full p-2 border rounded"
            />
          </div>
        </div>
      </div>
      
      {/* Featured Services Section */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Featured Services</h4>
        
        <div className="space-y-4">
          <div className="bg-white p-4 rounded border">
            <div className="flex justify-between">
              <p className="font-medium">Bookkeeping</p>
              <div>
                <button className="text-blue-800 hover:text-blue-900 mr-2">Edit</button>
                <button className="text-red-600 hover:text-red-700">Remove</button>
              </div>
            </div>
          </div>
          
          <div className="bg-white p-4 rounded border">
            <div className="flex justify-between">
              <p className="font-medium">Cash Flow Management</p>
              <div>
                <button className="text-blue-800 hover:text-blue-900 mr-2">Edit</button>
                <button className="text-red-600 hover:text-red-700">Remove</button>
              </div>
            </div>
          </div>
          
          <button className="flex items-center text-blue-800 hover:text-blue-900">
            <PlusCircle size={16} className="mr-1" /> Add Featured Service
          </button>
        </div>
      </div>
    </div>
  );
}



================================================
File: client/src/components/website/LearnMoreTab.jsx
================================================
// components/website/LearnMoreTab.jsx
import React, { useState } from 'react';
import { Upload, Image, PlusCircle } from 'lucide-react';

export default function LearnMoreTab() {
  const [featuredImage, setFeaturedImage] = useState(null);
  
  const handleImageChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setFeaturedImage(URL.createObjectURL(e.target.files[0]));
    }
  };
  
  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold">Learn More Page Content</h3>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Page Title</h4>
        <input
          type="text"
          defaultValue="Learn More About Our Services"
          className="w-full p-2 border rounded"
        />
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Main Content</h4>
        
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Paragraph 1
          </label>
          <textarea
            defaultValue="Wilcox Advisors specializes in providing top-tier financial and accounting services tailored for small businesses. Our expert team is dedicated to helping you save money, manage your finances effectively, and drive business growth."
            className="w-full p-2 border rounded"
            rows={4}
          />
        </div>
        
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Paragraph 2
          </label>
          <textarea
            defaultValue="Explore our comprehensive services, including bookkeeping, cash flow management, custom reporting, budgeting & forecasting, monthly financial packages, and outsourced controller/CFO support. Whether you're a startup or a growing company, we offer solutions designed to scale with your business needs. Contact us today to discover how we can help your business thrive!"
            className="w-full p-2 border rounded"
            rows={4}
          />
        </div>
        
        <button className="flex items-center text-blue-800 hover:text-blue-900">
          <PlusCircle size={16} className="mr-1" />
          Add Another Paragraph
        </button>
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Call to Action Button</h4>
        
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Button Text
            </label>
            <input
              type="text"
              defaultValue="Contact Us"
              className="w-full p-2 border rounded"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Button Action
            </label>
            <select className="w-full p-2 border rounded">
              <option value="contact">Scroll to Contact Form</option>
              <option value="consultation">Open Consultation Form</option>
              <option value="custom">Custom URL</option>
            </select>
          </div>
        </div>
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-2">Featured Image (Optional)</h4>
        
        <div className="flex items-center space-x-4">
          <div className="w-32 h-24 bg-gray-200 rounded border overflow-hidden">
            {featuredImage ? (
              <img src={featuredImage} alt="Featured image preview" className="w-full h-full object-cover" />
            ) : (
              <div className="text-center pt-4 text-gray-500">
                <Image size={24} className="mx-auto mb-1" />
                <p className="text-xs">No Image</p>
              </div>
            )}
          </div>
          <div>
            <div className="mb-2">
              <label className="bg-blue-800 text-white px-4 py-2 rounded hover:bg-blue-900 cursor-pointer">
                <Upload size={16} className="inline mr-2" />
                Upload Image
                <input 
                  type="file" 
                  className="hidden" 
                  accept="image/*" 
                  onChange={handleImageChange}
                />
              </label>
            </div>
            <p className="text-sm text-gray-500">Recommended size: 800x600 pixels</p>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
File: client/src/components/website/ServicesTab.jsx
================================================
// components/website/ServicesTab.jsx
import React from 'react';
import { PlusCircle } from 'lucide-react';

export default function ServicesTab() {
  return (
    <div className="space-y-6">
      <h3 className="text-xl font-semibold">Services Content</h3>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <div className="flex justify-between items-center mb-2">
          <h4 className="font-medium">Services Section Header</h4>
        </div>
        
        <div className="mb-4">
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Section Title
          </label>
          <input
            type="text"
            defaultValue="Our Small Business Services"
            className="w-full p-2 border rounded"
          />
        </div>
      </div>
      
      <div className="bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium mb-4">Service Items</h4>
        
        <div className="space-y-4">
          {[
            { title: 'Bookkeeping', description: 'Full-service bookkeeping including transaction coding and reconciliations' },
            { title: 'Monthly Financial Package', description: 'Comprehensive monthly financial statements with analysis' },
            { title: 'Cash Flow Management', description: 'Detailed cash flow tracking and forecasting' }
          ].map((service, index) => (
            <div key={index} className="bg-white p-4 rounded border">
              <div className="flex justify-between">
                <p className="font-medium">{service.title}</p>
                <div>
                  <button className="text-blue-800 hover:text-blue-900 mr-2">
                    Edit
                  </button>
                  <button className="text-red-600 hover:text-red-700">
                    Remove
                  </button>
                </div>
              </div>
              <p className="text-sm text-gray-700 mt-1">
                {service.description}
              </p>
            </div>
          ))}
        </div>
        
        <button className="mt-4 flex items-center text-blue-800 hover:text-blue-900">
          <PlusCircle size={16} className="mr-1" /> 
          Add Service
        </button>
      </div>
    </div>
  );
}



================================================
File: client/src/contexts/AuthContext.js
================================================
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [isLoggedIn, setIsLoggedIn] = useState(localStorage.getItem('token') !== null);
  const [isAdmin, setIsAdmin] = useState(localStorage.getItem('isAdmin') === 'true');
  const [user, setUser] = useState(null);

  useEffect(() => {
    if (isLoggedIn) {
      axios.defaults.headers.common['Authorization'] = `Bearer ${localStorage.getItem('token')}`;
    } else {
      delete axios.defaults.headers.common['Authorization'];
    }
  }, [isLoggedIn]);

  const login = (token, admin) => {
    console.log("AuthContext: Login called with:", { token: !!token, admin });
    localStorage.setItem('token', token);
    localStorage.setItem('isAdmin', admin);
    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
    setIsLoggedIn(true);
    setIsAdmin(admin);
  };

  const logout = async () => {
    console.log("AuthContext: Logout function called");
    try {
      // Optional: Call backend logout endpoint if it exists
      const API_URL = process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com';
      await axios.post(`${API_URL}/api/auth/logout`, {}, {
        headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
      });
      console.log("AuthContext: Backend logout successful");
    } catch (error) {
      console.warn("AuthContext: Backend logout failed, proceeding with local cleanup", error);
    }

    // Clear local state regardless of backend success
    localStorage.removeItem('token');
    localStorage.removeItem('isAdmin');
    delete axios.defaults.headers.common['Authorization'];
    setIsLoggedIn(false);
    setIsAdmin(false);
    setUser(null);
    console.log("AuthContext: Local state cleared, isLoggedIn:", false);
  };

  const value = {
    isLoggedIn,
    isAdmin,
    user,
    login,
    logout,
  };

  console.log("AuthContext state:", { isLoggedIn, isAdmin });
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}



================================================
File: client/src/contexts/UIContext.js
================================================
// src/contexts/UIContext.js
import React, { createContext, useContext, useState } from 'react';

// Create the context
const UIContext = createContext(null);

// Provider component
export function UIProvider({ children }) {
  const [showConsultationForm, setShowConsultationForm] = useState(false);
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [isChatOpen, setIsChatOpen] = useState(false);

  // Value object to be provided to consumers
  const value = {
    showConsultationForm,
    setShowConsultationForm,
    showLoginModal,
    setShowLoginModal,
    isChatOpen,
    setIsChatOpen
  };

  return <UIContext.Provider value={value}>{children}</UIContext.Provider>;
}

// Custom hook to use the UI context
export function useUI() {
  const context = useContext(UIContext);
  if (!context) {
    throw new Error('useUI must be used within a UIProvider');
  }
  return context;
}



================================================
File: client/src/hooks/useFormData.js
================================================
// src/hooks/useFormData.js
import { useState } from 'react';

export function useFormData(initialData) {
  const [formData, setFormData] = useState(initialData);
  
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  const resetForm = () => setFormData(initialData);
  
  return [formData, handleInputChange, setFormData, resetForm];
}



================================================
File: client/src/hooks/useJournalEntryForm.js
================================================
// src/hooks/useJournalEntryForm.js
import { useState, useEffect } from 'react';
import axios from 'axios';

export default function useJournalEntryForm(onSuccess) {
  const [journalData, setJournalData] = useState({
    date: '',
    transactionNo: '',
    description: '',
    entries: [
      { 
        id: 1, 
        accountNo: '', 
        accountTitle: '', 
        debit: '', 
        credit: '', 
        lineNo: '1', 
        vendor: '',
        documentNo: '',
        department: '',
        project: '',
        description: '' 
      },
      { 
        id: 2, 
        accountNo: '', 
        accountTitle: '', 
        debit: '', 
        credit: '', 
        lineNo: '2', 
        vendor: '',
        documentNo: '',
        department: '',
        project: '',
        description: '' 
      }
    ]
  });
  
  const [errors, setErrors] = useState({});
  const [entryErrors, setEntryErrors] = useState([]);
  const [statusMessage, setStatusMessage] = useState({ type: null, text: null });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [totals, setTotals] = useState({ debit: 0, credit: 0, isBalanced: false });
  const [supportingDocs, setSupportingDocs] = useState([]);
  const [accountsList, setAccountsList] = useState([]);

  // Fetch accounts when component mounts
  useEffect(() => {
    const fetchAccounts = async () => {
      try {
        const token = localStorage.getItem('token');
        const response = await axios.get(`${process.env.REACT_APP_API_URL || 'http://localhost:10000'}/api/accounting/accounts`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        setAccountsList(response.data.accounts);
      } catch (error) {
        console.error('Failed to fetch accounts:', error);
      }
    };
    
    fetchAccounts();
  }, []);

  // Calculate totals when entries change
  useEffect(() => {
    const debitTotal = journalData.entries.reduce((sum, entry) => {
      const value = parseFloat(entry.debit) || 0;
      return sum + value;
    }, 0);
    
    const creditTotal = journalData.entries.reduce((sum, entry) => {
      const value = parseFloat(entry.credit) || 0;
      return sum + value;
    }, 0);
    
    setTotals({
      debit: debitTotal,
      credit: creditTotal,
      isBalanced: debitTotal.toFixed(2) === creditTotal.toFixed(2) && debitTotal > 0
    });
  }, [journalData.entries]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setJournalData(prev => ({ ...prev, [name]: value }));
  };

  const handleEntryChange = (id, field, value) => {
    const updatedEntries = journalData.entries.map(entry => {
      if (entry.id === id) {
        if (field === 'debit' && value !== '' && entry.credit !== '') {
          return { ...entry, [field]: value, credit: '' };
        } else if (field === 'credit' && value !== '' && entry.debit !== '') {
          return { ...entry, [field]: value, debit: '' };
        } else {
          return { ...entry, [field]: value };
        }
      }
      return entry;
    });

    setJournalData({
      ...journalData,
      entries: updatedEntries
    });
    
    // Auto-fill account title if account number changes
    if (field === 'accountNo') {
      const selectedAccount = accountsList.find(a => a.accountNumber === value);
      if (selectedAccount) {
        handleEntryChange(id, 'accountTitle', selectedAccount.accountName);
      }
    }
  };

  const handleAccountSelect = (id, accountNo) => {
    const selectedAccount = accountsList.find(a => a.accountNumber === accountNo);
    if (selectedAccount) {
      handleEntryChange(id, 'accountTitle', selectedAccount.accountName);
    }
  };

  const addEntryRow = () => {
    const newId = journalData.entries.length > 0 
      ? Math.max(...journalData.entries.map(e => e.id)) + 1 
      : 1;
    
    const newLineNo = journalData.entries.length > 0
      ? (parseInt(journalData.entries[journalData.entries.length - 1].lineNo) + 1).toString()
      : '1';
      
    setJournalData({
      ...journalData,
      entries: [
        ...journalData.entries,
        { 
          id: newId, 
          accountNo: '', 
          accountTitle: '', 
          debit: '', 
          credit: '', 
          lineNo: newLineNo, 
          vendor: '',
          documentNo: '',
          department: '',
          project: '',
          description: '' 
        }
      ]
    });
    
    setEntryErrors([...entryErrors, {}]);
  };

  const removeEntryRow = (id) => {
    if (journalData.entries.length <= 1) return;
    
    const newEntries = journalData.entries.filter(entry => entry.id !== id);
    const entryIndex = journalData.entries.findIndex(entry => entry.id === id);
    
    const renumberedEntries = newEntries.map((entry, idx) => ({
      ...entry,
      lineNo: (idx + 1).toString()
    }));
    
    setJournalData({
      ...journalData,
      entries: renumberedEntries
    });
    
    const newEntryErrors = [...entryErrors];
    newEntryErrors.splice(entryIndex, 1);
    setEntryErrors(newEntryErrors);
  };

  const validateForm = () => {
    const newErrors = {};
    const newEntryErrors = journalData.entries.map(() => ({}));
    let isValid = true;
    
    if (!journalData.date) {
      newErrors.date = 'Date is required';
      isValid = false;
    }
    
    if (!journalData.description) {
      newErrors.description = 'Description is required';
      isValid = false;
    }
    
    journalData.entries.forEach((entry, index) => {
      if (!entry.accountNo) {
        newEntryErrors[index].accountNo = 'Account number is required';
        isValid = false;
      }
      
      if (!entry.accountTitle) {
        newEntryErrors[index].accountTitle = 'Account title is required';
        isValid = false;
      }
      
      if ((!entry.debit || entry.debit === '0') && (!entry.credit || entry.credit === '0')) {
        newEntryErrors[index].amount = 'Either debit or credit amount is required';
        isValid = false;
      }
    });
    
    if (totals.debit.toFixed(2) !== totals.credit.toFixed(2)) {
      newErrors.balance = 'Debits must equal credits';
      isValid = false;
    }
    
    setErrors(newErrors);
    setEntryErrors(newEntryErrors);
    return isValid;
  };

  const handleFileUpload = async (file) => {
    if (!file) return;
    
    setSupportingDocs(prev => [...prev, file]);
    
    const formData = new FormData();
    formData.append('file', file);
    
    try {
      const token = localStorage.getItem('token');
      await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:10000'}/api/upload`, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}` },
        body: formData
      });
      
      setStatusMessage({ type: 'success', text: `File "${file.name}" uploaded successfully!` });
    } catch (err) {
      setStatusMessage({ type: 'error', text: `Failed to upload file: ${err.message}` });
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    setIsSubmitting(true);
    
    const formattedData = {
      date: journalData.date,
      transactionNo: journalData.transactionNo,
      description: journalData.description,
      entries: journalData.entries.map(entry => ({
        accountNo: entry.accountNo,
        accountTitle: entry.accountTitle,
        amount: parseFloat(entry.debit || entry.credit),
        isDebit: entry.debit ? true : false,
        lineNo: entry.lineNo,
        vendor: entry.vendor,
        documentNo: entry.documentNo,
        department: entry.department,
        project: entry.project,
        description: entry.description
      })),
      supportingDocs: supportingDocs.map(doc => doc.name)
    };
    
    try {
      const token = localStorage.getItem('token');
      const response = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:10000'}/api/accounting/journal-entry`, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}` 
        },
        body: JSON.stringify(formattedData)
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to save journal entry');
      }
      
      const data = await response.json();
      
      setStatusMessage({ type: 'success', text: 'Journal entry saved successfully!' });
      
      setJournalData({
        date: '',
        transactionNo: '',
        description: '',
        entries: [
          { 
            id: 1, 
            accountNo: '', 
            accountTitle: '', 
            debit: '', 
            credit: '', 
            lineNo: '1', 
            vendor: '',
            documentNo: '',
            department: '',
            project: '',
            description: '' 
          },
          { 
            id: 2, 
            accountNo: '', 
            accountTitle: '', 
            debit: '', 
            credit: '', 
            lineNo: '2', 
            vendor: '',
            documentNo: '',
            department: '',
            project: '',
            description: '' 
          }
        ]
      });
      setSupportingDocs([]);
      
      if (onSuccess) onSuccess(data.journalEntry);
    } catch (err) {
      setStatusMessage({ type: 'error', text: err.message || 'Failed to save journal entry' });
    } finally {
      setIsSubmitting(false);
    }
  };

  return {
    journalData,
    errors,
    entryErrors,
    statusMessage,
    isSubmitting,
    totals,
    supportingDocs,
    accountsList,
    handleChange,
    handleEntryChange,
    handleAccountSelect,
    addEntryRow,
    removeEntryRow,
    handleFileUpload,
    handleSubmit,
    setSupportingDocs
  };
}



================================================
File: client/src/hooks/useMultiStepForm.js
================================================
// src/hooks/useMultiStepForm.js
import { useState } from 'react';

export default function useMultiStepForm(steps, initialData, onSubmit) {
  const [currentStep, setCurrentStep] = useState(0);
  const [formData, setFormData] = useState(initialData);

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleServiceToggle = (serviceId) => {
    setFormData(prev => ({
      ...prev,
      services: prev.services.includes(serviceId) 
        ? prev.services.filter(id => id !== serviceId) 
        : [...prev.services, serviceId],
    }));
  };

  const isStepValid = () => {
    const fields = steps[currentStep].fields;
    return fields.every(field => 
      field.required 
        ? (field.type === 'services' ? formData.services.length > 0 : formData[field.name]?.trim() !== '') 
        : true
    );
  };

  const nextStep = () => {
    if (currentStep < steps.length - 1 && isStepValid()) {
      setCurrentStep(currentStep + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (currentStep < steps.length - 1) {
      if (isStepValid()) nextStep();
    } else {
      await onSubmit(formData);
    }
  };

  return {
    currentStep,
    formData,
    handleInputChange,
    handleServiceToggle,
    isStepValid,
    nextStep,
    prevStep,
    handleSubmit
  };
}



================================================
File: client/src/pages/Home.jsx
================================================
// src/pages/Home.jsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { useUI } from '../contexts/UIContext';
import HeroSection from '../components/sections/HeroSection';
import ChecklistSection from '../components/sections/ChecklistSection';
import ServicesSection from '../components/sections/ServicesSection';
import BlogSection from '../components/sections/BlogSection';
import TestimonialsSection from '../components/sections/TestimonialsSection';
import AboutSection from '../components/sections/AboutSection';
import ContactSection from '../components/sections/ContactSection';
import ChecklistModal from '../components/modals/ChecklistModal';
import ChatWidget from '../components/common/ChatWidget';

const servicesList = [
  { id: 'bookkeeping', title: 'Bookkeeping', description: 'Full-service bookkeeping including transaction coding and reconciliations' },
  { id: 'monthlyFinancials', title: 'Monthly Financial Package', description: 'Comprehensive monthly financial statements with analysis' },
  { id: 'cashFlow', title: 'Cash Flow Management', description: 'Detailed cash flow tracking and forecasting' },
  { id: 'customReporting', title: 'Custom Reporting', description: 'Tailored financial reports for your specific needs' },
  { id: 'budgeting', title: 'Budgeting & Forecasting', description: 'Development and monitoring of budgets and forecasts' },
  { id: 'controllerCFO', title: 'Outsourced Controller/CFO Services', description: 'Strategic financial oversight and planning tailored to your business' },
];

// Sample blog posts for fallback when API is unavailable
const fallbackBlogPosts = [
  {
    _id: '1',
    title: 'Essential Financial Best Practices for Small Businesses',
    content: '<p>Managing finances effectively is crucial for small business success. This post covers the fundamental practices every business owner should implement.</p>'
  },
  {
    _id: '2',
    title: 'Understanding Cash Flow Forecasting',
    content: '<p>Learn how to predict your business\'s financial future and make informed decisions with effective cash flow forecasting techniques.</p>'
  }
];

function Home({ setShowConsultationForm }) {
  const [showChecklistForm, setShowChecklistForm] = useState(false);
  const [blogPosts, setBlogPosts] = useState(fallbackBlogPosts);
  const { isChatOpen, setIsChatOpen } = useUI();

  const dashboardData = {
    hero: { 
      headline: "Financial Expertise for Your Business Success", 
      subtext: "Professional accounting and financial services tailored for small businesses. We handle the numbers so you can focus on growth." 
    },
    about: "At Wilcox Advisors, we specialize in financial solutions for small businesses. From startups to growing companies, we provide the expertise you need to succeed—built to scale with you every step of the way.",
  };

  useEffect(() => {
    fetchBlogPosts();
  }, []);

  const fetchBlogPosts = async () => {
    try {
      // Define your API URL - use environment variable if available
      const API_URL = process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com';
      
      const response = await axios.get(`${API_URL}/api/blog`);
      
      // Only update state if the response contains data
      if (response.data && Array.isArray(response.data) && response.data.length > 0) {
        setBlogPosts(response.data);
      } else {
        console.log('Blog API returned empty data, using fallback content');
      }
    } catch (error) {
      console.error('Failed to fetch blog posts:', error);
      // Keep using fallback blog posts on error - no need to update state
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <HeroSection 
        dashboardData={dashboardData} 
        setShowConsultationForm={setShowConsultationForm} 
      />
      <ChecklistSection setShowChecklistForm={setShowChecklistForm} />
      <ServicesSection servicesList={servicesList} />
      <BlogSection blogPosts={blogPosts} />
      <TestimonialsSection />
      <AboutSection aboutText={dashboardData.about} />
      <ContactSection />
      {showChecklistForm && <ChecklistModal isOpen={showChecklistForm} onClose={() => setShowChecklistForm(false)} />}
      <ChatWidget isOpen={isChatOpen} setIsOpen={setIsChatOpen} />
    </div>
  );
}

export default Home;



================================================
File: client/src/pages/LearnMore.jsx
================================================
import React from 'react';
import { useNavigate } from 'react-router-dom';

function LearnMore() {
  const navigate = useNavigate();

  const handleContactClick = () => {
    // Navigate to home page first
    navigate('/');
    
    // Then scroll to contact section after a short delay to ensure page loads
    setTimeout(() => {
      const contactSection = document.getElementById('contact');
      if (contactSection) {
        contactSection.scrollIntoView({ behavior: 'smooth' });
      }
    }, 100);
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Main Content */}
      <main className="max-w-4xl mx-auto px-4 py-12">
        <section className="space-y-6">
          <p className="text-lg text-gray-700 leading-relaxed">
            Wilcox Advisors specializes in providing top-tier financial and accounting services tailored for small businesses. 
            Our expert team is dedicated to helping you save money, manage your finances effectively, and drive business growth.
          </p>
          <p className="text-lg text-gray-700 leading-relaxed">
            Explore our comprehensive services, including bookkeeping, cash flow management, custom reporting, budgeting & forecasting, 
            monthly financial packages, and outsourced controller/CFO support. Whether you're a startup or a growing company, 
            we offer solutions designed to scale with your business needs. Contact us today to discover how we can help your business thrive!
          </p>
          <div className="mt-8">
            <button
              onClick={handleContactClick}
              className="bg-blue-800 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-900 transition duration-200"
            >
              Contact Us
            </button>
          </div>
        </section>
      </main>
    </div>
  );
}

export default LearnMore;



================================================
File: client/src/utils/api.js
================================================
import axios from 'axios';

// Use environment variables for API URL
const API_URL = process.env.REACT_APP_API_URL || '';

// Configure axios instance
const api = axios.create({
  baseURL: API_URL,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Add interceptor to set CSRF token
api.interceptors.request.use(
  async (config) => {
    // Only add the X-CSRF-Token header for mutating requests
    if (['post', 'put', 'delete', 'patch'].includes(config.method?.toLowerCase())) {
      const csrfToken = localStorage.getItem('csrfToken');
      if (csrfToken) {
        config.headers['X-CSRF-Token'] = csrfToken;
      }
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Handle 403 CSRF errors by refreshing the token
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // If error is due to CSRF token and we haven't already retried
    if (error.response?.status === 403 && 
        error.response?.data?.message === 'Invalid CSRF token' && 
        !originalRequest._retry) {
      
      originalRequest._retry = true;
      
      try {
        // Fetch a new CSRF token
        const response = await axios.get(`${API_URL}/csrf-token`, { withCredentials: true });
        const token = response.data.csrfToken;
        
        // Store the new token
        localStorage.setItem('csrfToken', token);
        
        // Update the header and retry
        originalRequest.headers['X-CSRF-Token'] = token;
        return api(originalRequest);
      } catch (refreshError) {
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export default api;



================================================
File: client/src/utils/csrf.js
================================================
// src/utils/csrf.js
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'https://wilcox-advisors-backend.onrender.com';

export const getCsrfToken = async () => {
  try {
    // Add timestamp to prevent caching
    const response = await axios.get(`${API_URL}/api/csrf-token?t=${new Date().getTime()}`, {
      withCredentials: true
    });
    
    // Store the token
    if (response.data && response.data.csrfToken) {
      localStorage.setItem('csrfToken', response.data.csrfToken);
      return response.data.csrfToken;
    } else {
      throw new Error('No CSRF token received from server');
    }
  } catch (error) {
    console.error('CSRF Token Fetch Error:', error);
    throw error;
  }
};

export const setCsrfToken = (token) => {
  localStorage.setItem('csrfToken', token);
};

export const getStoredCsrfToken = () => {
  return localStorage.getItem('csrfToken');
};



================================================
File: server/accountService.js
================================================
// services/accountService.js
const Account = require('../models/account');
const AuditLog = require('../models/auditLog');
const logger = require('../utils/logger');

/**
 * Business logic for account operations
 */
exports.findAccountsByEntity = async (clientId, entityId, filters = {}) => {
  try {
    const query = { clientId, entityId };
    
    if (filters.type) query.accountType = filters.type;
    if (filters.subledger) query.subledgerType = filters.subledger;
    if (filters.active !== undefined) query.isActive = filters.active;
    
    return await Account.find(query).sort({ accountNumber: 1 });
  } catch (error) {
    logger.error('Account service error (findAccountsByEntity):', error);
    throw error;
  }
};

exports.createAccount = async (accountData, userId) => {
  try {
    const account = new Account(accountData);
    await account.save();
    
    // Log the account creation
    const auditLog = new AuditLog({
      clientId: accountData.clientId,
      action: 'CREATE_ACCOUNT',
      entityType: 'Account',
      entityId: account._id,
      userId,
      details: {
        accountNumber: accountData.accountNumber,
        accountName: accountData.accountName,
        accountType: accountData.accountType
      }
    });
    await auditLog.save();
    
    return account;
  } catch (error) {
    logger.error('Account service error (createAccount):', error);
    throw error;
  }
};



================================================
File: server/index.js
================================================
// index.js - Modular version
const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Create Express app
const app = express();

// Middleware
app.use(express.json());
app.use(cors({
  origin: process.env.CORS_ORIGIN || '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Basic route for testing
app.get('/', (req, res) => {
  res.status(200).json({ message: 'Wilcox Advisors API' });
});

// Import routes module (which loads all route files)
try {
  const routes = require('./routes/index');
  app.use('/api', routes);
  console.log('Routes loaded successfully');
} catch (error) {
  console.error('Failed to load routes:', error.message);
}

// Error handler
app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({ error: 'Server error', message: err.message });
});

// Start server
const PORT = process.env.PORT || 10000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  
  // Connect to MongoDB
  if (process.env.MONGO_URI) {
    mongoose.connect(process.env.MONGO_URI)
      .then(() => console.log('MongoDB Connected'))
      .catch(err => console.error('MongoDB Connection Error:', err));
  } else {
    console.error('MONGO_URI environment variable is not set');
  }
});



================================================
File: server/package.json
================================================
{
  "name": "wilcox-advisors-backend",
  "version": "1.0.0",
  "description": "Modular backend for Wilcox Advisors",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "jest"
  },
  "dependencies": {
    "aws-sdk": "^2.1562.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.1.3",
    "multer": "^1.4.5-lts.1",
    "nodemailer": "^6.9.10",
    "openai": "^4.38.1",
    "pdfkit": "^0.14.0",
    "cookie-parser": "^1.4.6",
    "csurf": "^1.11.0",
    "express-validator": "^7.0.1",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.1.0",
    "supertest": "^6.3.4"
  }
}



================================================
File: server/config/database.js
================================================
const mongoose = require('mongoose');
const logger = require('../utils/logger');

// Database connection
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    logger.info('MongoDB connected successfully');
  } catch (error) {
    logger.error('MongoDB connection error:', error);
    process.exit(1); // Exit process with failure
  }
};

module.exports = connectDB;



================================================
File: server/controllers/accountController.js
================================================
// controllers/accountController.js
const Account = require('../models/account');
const Transaction = require('../models/transaction');
const Entity = require('../models/entity');
const AuditLog = require('../models/auditLog');
const mongoose = require('mongoose');
const logger = require('../utils/logger');

// Get all accounts for an entity
exports.getAccounts = async (req, res, next) => {
  try {
    const { entityId, type, subledger, active } = req.query;
    const query = { 
      clientId: req.user.id
    };
    
    if (entityId) query.entityId = entityId;
    if (type) query.accountType = type;
    if (subledger) query.subledgerType = subledger;
    if (active !== undefined) query.isActive = active === 'true';
    
    const accounts = await Account.find(query).sort({ accountNumber: 1 });
    
    res.json({
      success: true,
      accounts: accounts.map(account => ({
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        subledgerType: account.subledgerType,
        isIntercompany: account.isIntercompany,
        currency: account.currency,
        balance: account.balance,
        isActive: account.isActive
      }))
    });
  } catch (error) {
    logger.error('Error fetching accounts:', error);
    next(error);
  }
};

// Get account by ID
exports.getAccountById = async (req, res, next) => {
  try {
    const account = await Account.findOne({
      _id: req.params.id,
      clientId: req.user.id
    });
    
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Account not found'
      });
    }
    
    res.json({
      success: true,
      account: {
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        subledgerType: account.subledgerType,
        description: account.description,
        isIntercompany: account.isIntercompany,
        currency: account.currency,
        balance: account.balance,
        isActive: account.isActive,
        parentAccount: account.parentAccount,
        createdAt: account.createdAt,
        updatedAt: account.updatedAt
      }
    });
  } catch (error) {
    logger.error('Error fetching account:', error);
    next(error);
  }
};

// Create new account
exports.createAccount = async (req, res, next) => {
  try {
    const { 
      entityId, 
      accountNumber, 
      accountName, 
      accountType, 
      subledgerType, 
      description,
      isIntercompany,
      currency,
      parentAccount
    } = req.body;
    
    // Verify entity exists and belongs to client
    const entity = await Entity.findOne({
      _id: entityId,
      clientId: req.user.id
    });
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found or you do not have permission'
      });
    }
    
    // Check if account number already exists for this entity
    const existingAccount = await Account.findOne({
      clientId: req.user.id,
      entityId,
      accountNumber
    });
    
    if (existingAccount) {
      return res.status(400).json({
        success: false,
        message: `Account with number ${accountNumber} already exists for this entity`
      });
    }
    
    // Check if parent account exists
    if (parentAccount) {
      const parent = await Account.findOne({
        _id: parentAccount,
        clientId: req.user.id,
        entityId
      });
      
      if (!parent) {
        return res.status(404).json({
          success: false,
          message: 'Parent account not found or does not belong to this entity'
        });
      }
    }
    
    const account = new Account({
      clientId: req.user.id,
      entityId,
      accountNumber,
      accountName,
      accountType,
      subledgerType: subledgerType || 'GL',
      description,
      isIntercompany: isIntercompany || false,
      currency: currency || entity.currency,
      parentAccount: parentAccount || null
    });
    
    await account.save();
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'CREATE_ACCOUNT',
      entityType: 'Account',
      entityId: account._id,
      userId: req.user.id,
      details: { 
        accountNumber, 
        accountName, 
        accountType,
        entityId 
      }
    });
    await auditLog.save();
    
    res.status(201).json({
      success: true,
      message: 'Account created successfully',
      account: {
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        subledgerType: account.subledgerType
      }
    });
  } catch (error) {
    logger.error('Error creating account:', error);
    next(error);
  }
};

// Update account
exports.updateAccount = async (req, res, next) => {
  try {
    const { 
      accountName, 
      description, 
      isActive,
      isIntercompany,
      parentAccount
    } = req.body;
    
    // Find account and make sure it belongs to this client
    const account = await Account.findOne({
      _id: req.params.id,
      clientId: req.user.id
    });
    
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Account not found'
      });
    }
    
    // Check if parent account exists
    if (parentAccount && parentAccount !== account.parentAccount?.toString()) {
      const parent = await Account.findOne({
        _id: parentAccount,
        clientId: req.user.id,
        entityId: account.entityId
      });
      
      if (!parent) {
        return res.status(404).json({
          success: false,
          message: 'Parent account not found or does not belong to this entity'
        });
      }
      
      // Prevent circular references
      if (parentAccount === account._id.toString()) {
        return res.status(400).json({
          success: false,
          message: 'An account cannot be its own parent'
        });
      }
    }
    
    // Update fields
    if (accountName) account.accountName = accountName;
    if (description !== undefined) account.description = description;
    if (isActive !== undefined) account.isActive = isActive;
    if (isIntercompany !== undefined) account.isIntercompany = isIntercompany;
    if (parentAccount !== undefined) account.parentAccount = parentAccount || null;
    
    await account.save();
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'UPDATE_ACCOUNT',
      entityType: 'Account',
      entityId: account._id,
      userId: req.user.id,
      details: { 
        accountName, 
        isActive
      }
    });
    await auditLog.save();
    
    res.json({
      success: true,
      message: 'Account updated successfully',
      account: {
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        subledgerType: account.subledgerType,
        isActive: account.isActive
      }
    });
  } catch (error) {
    logger.error('Error updating account:', error);
    next(error);
  }
};

// Delete account
exports.deleteAccount = async (req, res, next) => {
  const session = await mongoose.startSession();
  
  try {
    session.startTransaction();
    
    // Find account and make sure it belongs to this client
    const account = await Account.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Account not found'
      });
    }
    
    // Check if account has transactions
    const transactionCount = await Transaction.countDocuments({
      accountId: account._id
    }).session(session);
    
    if (transactionCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete account with associated transactions. Deactivate it instead.'
      });
    }
    
    // Check if account has child accounts
    const childAccountCount = await Account.countDocuments({
      parentAccount: account._id
    }).session(session);
    
    if (childAccountCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete account with child accounts. Remove parent reference from child accounts first.'
      });
    }
    
    // Delete the account
    await Account.deleteOne({ _id: account._id }).session(session);
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'DELETE_ACCOUNT',
      entityType: 'Account',
      entityId: account._id,
      userId: req.user.id,
      details: { 
        accountNumber: account.accountNumber, 
        accountName: account.accountName 
      }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Account deleted successfully'
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error deleting account:', error);
    next(error);
  } finally {
    session.endSession();
  }
};



================================================
File: server/controllers/chartOfAccountsController.js
================================================
// controllers/chartOfAccountsController.js
const ChartOfAccounts = require('../models/chartOfAccounts');
const Entity = require('../models/entity');
const Account = require('../models/account');
const AuditLog = require('../models/auditLog');
const mongoose = require('mongoose');
const logger = require('../utils/logger');

/**
 * Get all charts of accounts for a client
 */
exports.getAllChartOfAccounts = async (req, res, next) => {
  try {
    const { entityId, active } = req.query;
    const query = { clientId: req.user.id };
    
    if (entityId) {
      query.entityId = entityId;
    }
    
    if (active !== undefined) {
      query.isActive = active === 'true';
    }
    
    const chartOfAccounts = await ChartOfAccounts.find(query)
      .select('name description entityId isActive version updatedAt')
      .populate('entityId', 'name code')
      .sort({ name: 1 });
    
    res.json({
      success: true,
      chartOfAccounts
    });
  } catch (error) {
    logger.error('Error fetching charts of accounts:', error);
    next(error);
  }
};

/**
 * Get a single chart of accounts by ID
 */
exports.getChartOfAccountsById = async (req, res, next) => {
  try {
    const chartOfAccounts = await ChartOfAccounts.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).populate('entityId', 'name code');
    
    if (!chartOfAccounts) {
      return res.status(404).json({
        success: false,
        message: 'Chart of accounts not found'
      });
    }
    
    res.json({
      success: true,
      chartOfAccounts
    });
  } catch (error) {
    logger.error('Error fetching chart of accounts:', error);
    next(error);
  }
};

/**
 * Create a new chart of accounts
 */
exports.createChartOfAccounts = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const { 
      entityId, 
      name, 
      description, 
      accounts, 
      customFieldDefinitions,
      industry,
      defaultCurrency 
    } = req.body;
    
    // Verify entity exists and belongs to client
    const entity = await Entity.findOne({
      _id: entityId,
      clientId: req.user.id
    }).session(session);
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found or you do not have permission'
      });
    }
    
    // Check if a chart of accounts with the same name already exists for this entity
    const existingCOA = await ChartOfAccounts.findOne({
      clientId: req.user.id,
      entityId,
      name
    }).session(session);
    
    if (existingCOA) {
      return res.status(400).json({
        success: false,
        message: `Chart of accounts with name "${name}" already exists for this entity`
      });
    }
    
    // Create new chart of accounts
    const chartOfAccounts = new ChartOfAccounts({
      clientId: req.user.id,
      entityId,
      name,
      description,
      accounts: accounts || [],
      customFieldDefinitions: customFieldDefinitions || [],
      industry,
      defaultCurrency: defaultCurrency || entity.currency || 'USD'
    });
    
    // Validate account numbers are unique
    if (accounts && accounts.length > 0) {
      if (!chartOfAccounts.validateUniqueAccountNumbers()) {
        return res.status(400).json({
          success: false,
          message: 'Account numbers must be unique within the chart of accounts'
        });
      }
    }
    
    await chartOfAccounts.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'CREATE_CHART_OF_ACCOUNTS',
      entityType: 'ChartOfAccounts',
      entityId: chartOfAccounts._id,
      userId: req.user.id,
      details: { name, entityId }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.status(201).json({
      success: true,
      message: 'Chart of accounts created successfully',
      chartOfAccounts: {
        id: chartOfAccounts._id,
        name: chartOfAccounts.name,
        entityId: chartOfAccounts.entityId
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error creating chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};

/**
 * Create a default chart of accounts for an entity
 */
exports.createDefaultChartOfAccounts = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const { entityId, name } = req.body;
    
    // Verify entity exists and belongs to client
    const entity = await Entity.findOne({
      _id: entityId,
      clientId: req.user.id
    }).session(session);
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found or you do not have permission'
      });
    }
    
    // Check if a default chart of accounts already exists for this entity
    const existingCOA = await ChartOfAccounts.findOne({
      clientId: req.user.id,
      entityId,
      name: name || 'Default Chart of Accounts'
    }).session(session);
    
    if (existingCOA) {
      return res.status(400).json({
        success: false,
        message: `A chart of accounts named "${name || 'Default Chart of Accounts'}" already exists for this entity`
      });
    }
    
    // Create default chart of accounts
    const chartOfAccounts = await ChartOfAccounts.createDefault(
      req.user.id, 
      entityId,
      name || 'Default Chart of Accounts'
    );
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'CREATE_DEFAULT_CHART_OF_ACCOUNTS',
      entityType: 'ChartOfAccounts',
      entityId: chartOfAccounts._id,
      userId: req.user.id,
      details: { entityId }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.status(201).json({
      success: true,
      message: 'Default chart of accounts created successfully',
      chartOfAccounts: {
        id: chartOfAccounts._id,
        name: chartOfAccounts.name,
        entityId: chartOfAccounts.entityId,
        accountCount: chartOfAccounts.accounts.length
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error creating default chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};

/**
 * Update a chart of accounts
 */
exports.updateChartOfAccounts = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const { 
      name, 
      description, 
      isActive,
      customFieldDefinitions,
      defaultCurrency
    } = req.body;
    
    // Find chart of accounts and make sure it belongs to this client
    const chartOfAccounts = await ChartOfAccounts.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!chartOfAccounts) {
      return res.status(404).json({
        success: false,
        message: 'Chart of accounts not found'
      });
    }
    
    // Update fields
    if (name !== undefined) chartOfAccounts.name = name;
    if (description !== undefined) chartOfAccounts.description = description;
    if (isActive !== undefined) chartOfAccounts.isActive = isActive;
    if (customFieldDefinitions !== undefined) chartOfAccounts.customFieldDefinitions = customFieldDefinitions;
    if (defaultCurrency !== undefined) chartOfAccounts.defaultCurrency = defaultCurrency;
    
    // Increment version
    chartOfAccounts.version += 1;
    
    await chartOfAccounts.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'UPDATE_CHART_OF_ACCOUNTS',
      entityType: 'ChartOfAccounts',
      entityId: chartOfAccounts._id,
      userId: req.user.id,
      details: { 
        name, 
        isActive,
        version: chartOfAccounts.version
      }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Chart of accounts updated successfully',
      chartOfAccounts: {
        id: chartOfAccounts._id,
        name: chartOfAccounts.name,
        isActive: chartOfAccounts.isActive,
        version: chartOfAccounts.version
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error updating chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};

/**
 * Delete a chart of accounts
 */
exports.deleteChartOfAccounts = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Find chart of accounts and make sure it belongs to this client
    const chartOfAccounts = await ChartOfAccounts.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!chartOfAccounts) {
      return res.status(404).json({
        success: false,
        message: 'Chart of accounts not found'
      });
    }
    
    // Check if the chart of accounts is in use in real accounts
    const accountsUsingCOA = await Account.countDocuments({
      clientId: req.user.id,
      entityId: chartOfAccounts.entityId
    }).session(session);
    
    if (accountsUsingCOA > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete chart of accounts that is in use. Deactivate it instead.'
      });
    }
    
    // Delete the chart of accounts
    await ChartOfAccounts.deleteOne({ _id: chartOfAccounts._id }).session(session);
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'DELETE_CHART_OF_ACCOUNTS',
      entityType: 'ChartOfAccounts',
      entityId: chartOfAccounts._id,
      userId: req.user.id,
      details: { 
        name: chartOfAccounts.name,
        entityId: chartOfAccounts.entityId
      }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Chart of accounts deleted successfully'
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error deleting chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};

/**
 * Add an account to a chart of accounts
 */
exports.addAccount = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const {
      accountNumber,
      accountName,
      accountType,
      fslCategory,
      description,
      subledgerType,
      parentAccount,
      isIntercompany,
      currency,
      customFields,
      tags
    } = req.body;
    
    // Find chart of accounts and make sure it belongs to this client
    const chartOfAccounts = await ChartOfAccounts.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!chartOfAccounts) {
      return res.status(404).json({
        success: false,
        message: 'Chart of accounts not found'
      });
    }
    
    // Check if account number already exists
    const accountExists = chartOfAccounts.accounts.some(a => a.accountNumber === accountNumber);
    
    if (accountExists) {
      return res.status(400).json({
        success: false,
        message: `Account with number ${accountNumber} already exists in this chart of accounts`
      });
    }
    
    // Check if parent account exists if specified
    if (parentAccount) {
      const parentExists = chartOfAccounts.accounts.some(a => a.accountNumber === parentAccount);
      
      if (!parentExists) {
        return res.status(400).json({
          success: false,
          message: `Parent account ${parentAccount} does not exist in this chart of accounts`
        });
      }
    }
    
    // Create new account object
    const newAccount = {
      accountNumber,
      accountName,
      accountType,
      fslCategory,
      description,
      subledgerType: subledgerType || 'GL',
      parentAccount: parentAccount || null,
      isIntercompany: isIntercompany || false,
      currency: currency || chartOfAccounts.defaultCurrency || 'USD',
      customFields: customFields || {},
      tags: tags || []
    };
    
    // Add the account to the chart of accounts
    chartOfAccounts.accounts.push(newAccount);
    
    // Increment version
    chartOfAccounts.version += 1;
    
    await chartOfAccounts.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'ADD_ACCOUNT_TO_CHART',
      entityType: 'ChartOfAccounts',
      entityId: chartOfAccounts._id,
      userId: req.user.id,
      details: { 
        accountNumber,
        accountName,
        accountType,
        fslCategory,
        chartOfAccountsName: chartOfAccounts.name
      }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.status(201).json({
      success: true,
      message: 'Account added to chart of accounts successfully',
      account: newAccount
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error adding account to chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};

/**
 * Update an account in a chart of accounts
 */
exports.updateAccount = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const { accountNumber } = req.params;
    const {
      accountName,
      fslCategory,
      description,
      subledgerType,
      parentAccount,
      isIntercompany,
      isActive,
      currency,
      customFields,
      tags,
      displayOptions
    } = req.body;
    
    // Find chart of accounts and make sure it belongs to this client
    const chartOfAccounts = await ChartOfAccounts.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!chartOfAccounts) {
      return res.status(404).json({
        success: false,
        message: 'Chart of accounts not found'
      });
    }
    
    // Find the account to update
    const accountIndex = chartOfAccounts.accounts.findIndex(a => a.accountNumber === accountNumber);
    
    if (accountIndex === -1) {
      return res.status(404).json({
        success: false,
        message: `Account with number ${accountNumber} not found in this chart of accounts`
      });
    }
    
    // Check if parent account exists if specified and different from current
    if (parentAccount && parentAccount !== chartOfAccounts.accounts[accountIndex].parentAccount) {
      const parentExists = chartOfAccounts.accounts.some(a => a.accountNumber === parentAccount);
      
      if (!parentExists) {
        return res.status(400).json({
          success: false,
          message: `Parent account ${parentAccount} does not exist in this chart of accounts`
        });
      }
      
      // Prevent circular references
      if (parentAccount === accountNumber) {
        return res.status(400).json({
          success: false,
          message: 'An account cannot be its own parent'
        });
      }
    }
    
    // Update account fields
    const account = chartOfAccounts.accounts[accountIndex];
    
    if (accountName !== undefined) account.accountName = accountName;
    if (fslCategory !== undefined) account.fslCategory = fslCategory;
    if (description !== undefined) account.description = description;
    if (subledgerType !== undefined) account.subledgerType = subledgerType;
    if (parentAccount !== undefined) account.parentAccount = parentAccount;
    if (isIntercompany !== undefined) account.isIntercompany = isIntercompany;
    if (isActive !== undefined) account.isActive = isActive;
    if (currency !== undefined) account.currency = currency;
    if (customFields !== undefined) {
      account.customFields = new Map([...account.customFields, ...customFields]);
    }
    if (tags !== undefined) account.tags = tags;
    if (displayOptions !== undefined) account.displayOptions = {
      ...account.displayOptions,
      ...displayOptions
    };
    
    // Update the account in the chart of accounts
    chartOfAccounts.accounts[accountIndex] = account;
    
    // Increment version
    chartOfAccounts.version += 1;
    
    // Mark the document as modified
    chartOfAccounts.markModified('accounts');
    
    await chartOfAccounts.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'UPDATE_ACCOUNT_IN_CHART',
      entityType: 'ChartOfAccounts',
      entityId: chartOfAccounts._id,
      userId: req.user.id,
      details: { 
        accountNumber,
        accountName,
        chartOfAccountsName: chartOfAccounts.name
      }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Account updated successfully',
      account: chartOfAccounts.accounts[accountIndex]
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error updating account in chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};

/**
 * Delete an account from a chart of accounts
 */
exports.deleteAccount = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const { accountNumber } = req.params;
    
    // Find chart of accounts and make sure it belongs to this client
    const chartOfAccounts = await ChartOfAccounts.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!chartOfAccounts) {
      return res.status(404).json({
        success: false,
        message: 'Chart of accounts not found'
      });
    }
    
    // Find the account to delete
    const accountIndex = chartOfAccounts.accounts.findIndex(a => a.accountNumber === accountNumber);
    
    if (accountIndex === -1) {
      return res.status(404).json({
        success: false,
        message: `Account with number ${accountNumber} not found in this chart of accounts`
      });
    }
    
    // Check if this account is a parent of other accounts
    const isParent = chartOfAccounts.accounts.some(a => a.parentAccount === accountNumber);
    
    if (isParent) {
      return res.status(400).json({
        success: false,
        message: `Cannot delete account ${accountNumber} as it is a parent of other accounts`
      });
    }
    
    // Store account info for audit log
    const accountInfo = chartOfAccounts.accounts[accountIndex];
    
    // Remove the account from the chart of accounts
    chartOfAccounts.accounts.splice(accountIndex, 1);
    
    // Increment version
    chartOfAccounts.version += 1;
    
    await chartOfAccounts.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'DELETE_ACCOUNT_FROM_CHART',
      entityType: 'ChartOfAccounts',
      entityId: chartOfAccounts._id,
      userId: req.user.id,
      details: { 
        accountNumber,
        accountName: accountInfo.accountName,
        accountType: accountInfo.accountType,
        fslCategory: accountInfo.fslCategory,
        chartOfAccountsName: chartOfAccounts.name
      }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Account deleted from chart of accounts successfully'
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error deleting account from chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};

/**
 * Get FSLI categories by accountType
 */
exports.getFSLICategories = async (req, res, next) => {
  try {
    // Default FSLI categories by account type
    const defaultCategories = {
      Asset: [
        'Cash and Cash Equivalents',
        'Short-term Investments',
        'Accounts Receivable',
        'Inventory',
        'Prepaid Expenses',
        'Other Current Assets',
        'Property, Plant and Equipment',
        'Intangible Assets',
        'Long-term Investments',
        'Other Non-current Assets'
      ],
      Liability: [
        'Accounts Payable',
        'Short-term Debt',
        'Current Portion of Long-term Debt',
        'Accrued Liabilities',
        'Deferred Revenue',
        'Other Current Liabilities',
        'Long-term Debt',
        'Deferred Tax Liabilities',
        'Other Non-current Liabilities'
      ],
      Equity: [
        'Common Stock',
        'Preferred Stock',
        'Additional Paid-in Capital',
        'Treasury Stock',
        'Retained Earnings',
        'Accumulated Other Comprehensive Income',
        'Non-controlling Interest'
      ],
      Revenue: [
        'Revenue',
        'Service Revenue',
        'Product Revenue',
        'Other Revenue'
      ],
      Expense: [
        'Cost of Goods Sold',
        'Operating Expenses',
        'Sales and Marketing',
        'General and Administrative',
        'Research and Development',
        'Depreciation and Amortization',
        'Interest Expense',
        'Income Tax Expense',
        'Other Expenses'
      ]
    };
    
    // Get custom FSLI categories from existing charts of accounts
    const chartOfAccounts = await ChartOfAccounts.find({
      clientId: req.user.id,
      isActive: true
    });
    
    // Extract all FSLI categories used
    const customCategories = {};
    
    chartOfAccounts.forEach(coa => {
      coa.accounts.forEach(account => {
        if (!customCategories[account.accountType]) {
          customCategories[account.accountType] = new Set();
        }
        
        customCategories[account.accountType].add(account.fslCategory);
      });
    });
    
    // Merge default and custom categories
    const result = {};
    
    Object.keys(defaultCategories).forEach(type => {
      result[type] = defaultCategories[type];
      
      if (customCategories[type]) {
        // Add custom categories that aren't in the default list
        customCategories[type].forEach(category => {
          if (!result[type].includes(category)) {
            result[type].push(category);
          }
        });
      }
      
      // Sort categories alphabetically
      result[type].sort();
    });
    
    res.json({
      success: true,
      fsliCategories: result
    });
  } catch (error) {
    logger.error('Error fetching FSLI categories:', error);
    next(error);
  }
};

/**
 * Import accounts from another chart of accounts
 */
exports.importAccounts = async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const { sourceChartId } = req.body;
    
    // Find target chart of accounts
    const targetChart = await ChartOfAccounts.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!targetChart) {
      return res.status(404).json({
        success: false,
        message: 'Target chart of accounts not found'
      });
    }
    
    // Find source chart of accounts
    const sourceChart = await ChartOfAccounts.findOne({
      _id: sourceChartId,
      clientId: req.user.id
    }).session(session);
    
    if (!sourceChart) {
      return res.status(404).json({
        success: false,
        message: 'Source chart of accounts not found'
      });
    }
    
    // Get existing account numbers in target
    const existingAccountNumbers = new Set(targetChart.accounts.map(a => a.accountNumber));
    
    // Filter source accounts that don't already exist in target
    const accountsToImport = sourceChart.accounts.filter(a => !existingAccountNumbers.has(a.accountNumber));
    
    // Add accounts to target
    targetChart.accounts.push(...accountsToImport);
    
    // Increment version
    targetChart.version += 1;
    
    await targetChart.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'IMPORT_ACCOUNTS_TO_CHART',
      entityType: 'ChartOfAccounts',
      entityId: targetChart._id,
      userId: req.user.id,
      details: { 
        sourceChartId,
        sourceChartName: sourceChart.name,
        targetChartName: targetChart.name,
        accountCount: accountsToImport.length
      }
    });
    
    await auditLog.save({ session });
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: `Successfully imported ${accountsToImport.length} accounts`,
      importedAccounts: accountsToImport.map(a => ({
        accountNumber: a.accountNumber,
        accountName: a.accountName,
        accountType: a.accountType,
        fslCategory: a.fslCategory
      }))
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error importing accounts to chart of accounts:', error);
    next(error);
  } finally {
    session.endSession();
  }
};



================================================
File: server/controllers/entityController.js
================================================
// controllers/entityController.js
const Entity = require('../models/entity');
const AuditLog = require('../models/auditLog');
const Account = require('../models/account');
const mongoose = require('mongoose');
const logger = require('../utils/logger');

// Get all entities
exports.getEntities = async (req, res, next) => {
  try {
    const { active } = req.query;
    const query = { clientId: req.user.id };
    
    if (active !== undefined) {
      query.isActive = active === 'true';
    }
    
    const entities = await Entity.find(query).sort({ name: 1 });
    
    res.json({
      success: true,
      entities: entities.map(entity => ({
        id: entity._id,
        name: entity.name,
        code: entity.code,
        type: entity.type,
        currency: entity.currency,
        isActive: entity.isActive,
        parentEntityId: entity.parentEntityId
      }))
    });
  } catch (error) {
    logger.error('Error fetching entities:', error);
    next(error);
  }
};

// Get single entity by ID
exports.getEntityById = async (req, res, next) => {
  try {
    const entity = await Entity.findOne({
      _id: req.params.id,
      clientId: req.user.id
    });
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found'
      });
    }
    
    res.json({
      success: true,
      entity: {
        id: entity._id,
        name: entity.name,
        code: entity.code,
        type: entity.type,
        currency: entity.currency,
        isActive: entity.isActive,
        parentEntityId: entity.parentEntityId,
        metadata: entity.metadata,
        createdAt: entity.createdAt,
        updatedAt: entity.updatedAt
      }
    });
  } catch (error) {
    logger.error('Error fetching entity:', error);
    next(error);
  }
};

// Create new entity
exports.createEntity = async (req, res, next) => {
  try {
    const { name, code, type, currency, parentEntityId } = req.body;
    
    // Check if entity code already exists for this client
    const existingEntity = await Entity.findOne({
      clientId: req.user.id,
      code: code
    });
    
    if (existingEntity) {
      return res.status(400).json({
        success: false,
        message: `Entity with code ${code} already exists`
      });
    }
    
    const entity = new Entity({
      clientId: req.user.id,
      name,
      code,
      type: type || 'Operating',
      currency: currency || 'USD',
      parentEntityId: parentEntityId || null
    });
    
    await entity.save();
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'CREATE_ENTITY',
      entityType: 'Entity',
      entityId: entity._id,
      userId: req.user.id,
      details: { name, code, type }
    });
    await auditLog.save();
    
    res.status(201).json({
      success: true,
      message: 'Entity created successfully',
      entity: {
        id: entity._id,
        name: entity.name,
        code: entity.code,
        type: entity.type,
        currency: entity.currency
      }
    });
  } catch (error) {
    logger.error('Error creating entity:', error);
    next(error);
  }
};

// Update existing entity
exports.updateEntity = async (req, res, next) => {
  try {
    const { name, type, currency, isActive, metadata } = req.body;
    
    // Find entity and make sure it belongs to this client
    const entity = await Entity.findOne({
      _id: req.params.id,
      clientId: req.user.id
    });
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found'
      });
    }
    
    // Update fields
    if (name) entity.name = name;
    if (type) entity.type = type;
    if (currency) entity.currency = currency;
    if (isActive !== undefined) entity.isActive = isActive;
    if (metadata) entity.metadata = { ...entity.metadata, ...metadata };
    
    await entity.save();
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'UPDATE_ENTITY',
      entityType: 'Entity',
      entityId: entity._id,
      userId: req.user.id,
      details: { name, type, currency, isActive }
    });
    await auditLog.save();
    
    res.json({
      success: true,
      message: 'Entity updated successfully',
      entity: {
        id: entity._id,
        name: entity.name,
        code: entity.code,
        type: entity.type,
        currency: entity.currency,
        isActive: entity.isActive
      }
    });
  } catch (error) {
    logger.error('Error updating entity:', error);
    next(error);
  }
};

// Delete entity
exports.deleteEntity = async (req, res, next) => {
  const session = await mongoose.startSession();
  
  try {
    session.startTransaction();
    
    // Find entity and make sure it belongs to this client
    const entity = await Entity.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found'
      });
    }
    
    // Check if entity has accounts
    const accountCount = await Account.countDocuments({
      entityId: entity._id
    }).session(session);
    
    if (accountCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete entity with associated accounts. Deactivate it instead.'
      });
    }
    
    // Delete the entity
    await Entity.deleteOne({ _id: entity._id }).session(session);
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'DELETE_ENTITY',
      entityType: 'Entity',
      entityId: entity._id,
      userId: req.user.id,
      details: { name: entity.name, code: entity.code }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Entity deleted successfully'
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error deleting entity:', error);
    next(error);
  } finally {
    session.endSession();
  }
};



================================================
File: server/controllers/journalEntryController.js
================================================
// controllers/journalEntryController.js
const JournalEntry = require('../models/journalEntry');
const Transaction = require('../models/transaction');
const Account = require('../models/account');
const Entity = require('../models/entity');
const AuditLog = require('../models/auditLog');
const mongoose = require('mongoose');
const logger = require('../utils/logger');

// Get journal entries with filtering and pagination
exports.getJournalEntries = async (req, res, next) => {
  try {
    const { 
      entityId, 
      startDate, 
      endDate, 
      accountId, 
      status, 
      limit = 50, 
      page = 1 
    } = req.query;
    
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Build query filters
    const query = { 
      clientId: req.user.id,
      entityId
    };
    
    if (startDate || endDate) {
      query.date = {};
      if (startDate) query.date.$gte = new Date(startDate);
      if (endDate) query.date.$lte = new Date(endDate);
    }
    
    if (status) {
      query.status = status;
    }
    
    // If accountId is provided, find corresponding transactions
    if (accountId) {
      const transactionIds = await Transaction.find({
        clientId: req.user.id,
        entityId,
        accountId
      }).distinct('journalEntryId');
      
      query._id = { $in: transactionIds };
    }
    
    // Execute query with pagination
    const totalCount = await JournalEntry.countDocuments(query);
    const entries = await JournalEntry.find(query)
      .sort({ date: -1, _id: -1 })
      .limit(parseInt(limit))
      .skip(skip)
      .populate('entityId', 'name code')
      .lean();
    
    // Get transactions for these journal entries
    const journalEntryIds = entries.map(entry => entry._id);
    const transactions = await Transaction.find({
      clientId: req.user.id,
      journalEntryId: { $in: journalEntryIds }
    }).populate('accountId', 'accountNumber accountName')
      .lean();
    
    // Group transactions by journal entry
    const transactionsByEntry = {};
    transactions.forEach(transaction => {
      const journalId = transaction.journalEntryId.toString();
      if (!transactionsByEntry[journalId]) {
        transactionsByEntry[journalId] = [];
      }
      transactionsByEntry[journalId].push(transaction);
    });
    
    // Format response
    const formattedEntries = entries.map(entry => ({
      id: entry._id,
      entryNumber: entry.entryNumber,
      date: entry.date,
      entity: entry.entityId ? {
        id: entry.entityId._id,
        name: entry.entityId.name,
        code: entry.entityId.code
      } : null,
      description: entry.description,
      totalAmount: entry.totalAmount,
      status: entry.status,
      isIntercompany: entry.isIntercompany,
      transactions: (transactionsByEntry[entry._id.toString()] || []).map(t => ({
        id: t._id,
        account: t.accountId ? {
          id: t.accountId._id,
          number: t.accountId.accountNumber,
          name: t.accountId.accountName
        } : null,
        amount: t.amount,
        type: t.type,
        description: t.description
      }))
    }));
    
    res.json({
      success: true,
      entries: formattedEntries,
      pagination: {
        total: totalCount,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(totalCount / parseInt(limit))
      }
    });
  } catch (error) {
    logger.error('Error fetching journal entries:', error);
    next(error);
  }
};

// Get a single journal entry by ID
exports.getJournalEntryById = async (req, res, next) => {
  try {
    const entry = await JournalEntry.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).populate('entityId', 'name code');
    
    if (!entry) {
      return res.status(404).json({
        success: false,
        message: 'Journal entry not found'
      });
    }
    
    // Get related transactions
    const transactions = await Transaction.find({
      journalEntryId: entry._id
    }).populate('accountId', 'accountNumber accountName');
    
    res.json({
      success: true,
      entry: {
        id: entry._id,
        entryNumber: entry.entryNumber,
        date: entry.date,
        description: entry.description,
        entity: entry.entityId ? {
          id: entry.entityId._id,
          name: entry.entityId.name,
          code: entry.entityId.code
        } : null,
        totalAmount: entry.totalAmount,
        status: entry.status,
        transactions: transactions.map(t => ({
          id: t._id,
          account: t.accountId ? {
            id: t.accountId._id,
            number: t.accountId.accountNumber,
            name: t.accountId.accountName
          } : null,
          amount: t.amount,
          type: t.type,
          description: t.description || entry.description
        }))
      }
    });
  } catch (error) {
    logger.error('Error fetching journal entry:', error);
    next(error);
  }
};

// Create journal entry
exports.createJournalEntry = async (req, res, next) => {
  const session = await mongoose.startSession();
  
  try {
    session.startTransaction();
    
    const { entityId, date, description, entries, attachments } = req.body;
    
    // Verify entity exists and belongs to client
    const entity = await Entity.findOne({
      _id: entityId,
      clientId: req.user.id
    }).session(session);
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found or you do not have permission'
      });
    }
    
    // Calculate totals
    let totalDebits = 0;
    let totalCredits = 0;
    
    for (const entry of entries) {
      const amount = parseFloat(entry.amount);
      if (entry.type === 'debit') {
        totalDebits += amount;
      } else {
        totalCredits += amount;
      }
    }
    
    // Verify balanced entry
    if (Math.abs(totalDebits - totalCredits) > 0.01) {
      return res.status(400).json({
        success: false,
        message: 'Journal entries must be balanced',
        details: {
          totalDebits,
          totalCredits,
          difference: totalDebits - totalCredits
        }
      });
    }
    
    // Generate entry number (YYYY-MM-XXXXX)
    const entryDate = new Date(date);
    const year = entryDate.getFullYear();
    const month = String(entryDate.getMonth() + 1).padStart(2, '0');
    
    // Get count of entries this month for sequential numbering
    const entryCount = await JournalEntry.countDocuments({
      clientId: req.user.id,
      entityId,
      'period.year': year,
      'period.month': entryDate.getMonth() + 1
    }).session(session);
    
    const entryNumber = `${year}-${month}-${String(entryCount + 1).padStart(5, '0')}`;
    
    // Create journal entry
    const journalEntry = new JournalEntry({
      clientId: req.user.id,
      entityId,
      entryNumber,
      date: entryDate,
      description,
      totalAmount: totalDebits,
      status: 'posted',
      createdBy: req.user.id,
      currency: entity.currency,
      period: {
        year,
        month: entryDate.getMonth() + 1,
        quarter: Math.floor(entryDate.getMonth() / 3) + 1
      },
      isManual: true,
      attachments: []
    });
    
    // Handle attachments
    if (attachments && Array.isArray(attachments)) {
      journalEntry.attachments = attachments;
    }
    
    await journalEntry.save({ session });
    
    // Create transactions for each entry
    const transactions = [];
    for (const entry of entries) {
      // Verify account exists and belongs to client
      const account = await Account.findOne({
        _id: entry.accountId,
        clientId: req.user.id,
        entityId
      }).session(session);
      
      if (!account) {
        throw new Error(`Account ${entry.accountId} not found or does not belong to this entity`);
      }
      
      const transaction = new Transaction({
        clientId: req.user.id,
        entityId,
        accountId: entry.accountId,
        journalEntryId: journalEntry._id,
        date: entryDate,
        description: entry.description || description,
        amount: parseFloat(entry.amount),
        type: entry.type,
        transactionNo: entryNumber,
        lineNo: entry.lineNo || transactions.length + 1,
        documentNumber: entry.documentNumber,
        subledgerType: account.subledgerType,
        currency: entity.currency,
        isManual: true
      });
      
      transactions.push(transaction);
      
      // Update account balance
      const updateAmount = parseFloat(entry.amount);
      let balanceChange = 0;
      
      if (['Asset', 'Expense'].includes(account.accountType)) {
        // Debit increases, credit decreases
        balanceChange = entry.type === 'debit' ? updateAmount : -updateAmount;
      } else {
        // Credit increases, debit decreases
        balanceChange = entry.type === 'credit' ? updateAmount : -updateAmount;
      }
      
      await Account.findByIdAndUpdate(
        account._id,
        { 
          $inc: { balance: balanceChange },
          $set: { lastUpdated: new Date() }
        },
        { session }
      );
    }
    
    await Transaction.insertMany(transactions, { session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'CREATE_JOURNAL_ENTRY',
      entityType: 'JournalEntry',
      entityId: journalEntry._id,
      userId: req.user.id,
      details: { 
        entryNumber, 
        entityId, 
        date, 
        totalAmount: totalDebits,
        transactionCount: transactions.length
      }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.status(201).json({
      success: true,
      message: 'Journal entry created successfully',
      journalEntry: {
        id: journalEntry._id,
        entryNumber: journalEntry.entryNumber,
        date: journalEntry.date,
        description: journalEntry.description,
        totalAmount: journalEntry.totalAmount,
        transactions: transactions.map(t => ({
          id: t._id,
          accountId: t.accountId,
          amount: t.amount,
          type: t.type
        }))
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error creating journal entry:', error);
    
    if (error.message && error.message.includes('Account')) {
      return res.status(400).json({
        success: false,
        message: error.message
      });
    }
    
    next(error);
  } finally {
    session.endSession();
  }
};

// Delete/Reverse journal entry
exports.deleteJournalEntry = async (req, res, next) => {
  const session = await mongoose.startSession();
  
  try {
    session.startTransaction();
    
    const journalEntryId = req.params.id;
    
    // First, check if the entry exists and belongs to the user
    const journalEntry = await JournalEntry.findOne({
      _id: journalEntryId,
      clientId: req.user.id,
      status: { $ne: 'reversed' } // Cannot delete already reversed entries
    }).session(session);
    
    if (!journalEntry) {
      return res.status(404).json({ 
        success: false,
        message: 'Journal entry not found or already reversed'
      });
    }
    
    // Get transactions for this journal entry
    const transactions = await Transaction.find({
      journalEntryId: journalEntryId
    }).populate('accountId').session(session);
    
    // Reverse account balances
    for (const transaction of transactions) {
      if (!transaction.accountId) continue;
      
      const account = transaction.accountId;
      const updateAmount = transaction.amount;
      let balanceChange = 0;
      
      if (['Asset', 'Expense'].includes(account.accountType)) {
        // Reverse the effect: debit decreased, credit increased
        balanceChange = transaction.type === 'debit' ? -updateAmount : updateAmount;
      } else {
        // Reverse the effect: credit decreased, debit increased
        balanceChange = transaction.type === 'credit' ? -updateAmount : updateAmount;
      }
      
      await Account.findByIdAndUpdate(
        account._id,
        { 
          $inc: { balance: balanceChange },
          $set: { lastUpdated: new Date() }
        },
        { session }
      );
    }
    
    // Create reversal journal entry
    const reversalEntry = new JournalEntry({
      clientId: req.user.id,
      entityId: journalEntry.entityId,
      entryNumber: `REV-${journalEntry.entryNumber}`,
      date: new Date(),
      description: `Reversal of ${journalEntry.entryNumber}: ${journalEntry.description}`,
      totalAmount: journalEntry.totalAmount,
      status: 'posted',
      createdBy: req.user.id,
      reversalOf: journalEntry._id,
      currency: journalEntry.currency,
      period: {
        year: new Date().getFullYear(),
        month: new Date().getMonth() + 1,
        quarter: Math.floor(new Date().getMonth() / 3) + 1
      },
      isManual: true
    });
    
    await reversalEntry.save({ session });
    
    // Create reversal transactions
    const reversalTransactions = [];
    for (const transaction of transactions) {
      const reversalTransaction = new Transaction({
        clientId: req.user.id,
        entityId: transaction.entityId,
        accountId: transaction.accountId._id,
        journalEntryId: reversalEntry._id,
        date: new Date(),
        description: `Reversal of ${transaction.description}`,
        amount: transaction.amount,
        // Reverse the transaction type
        type: transaction.type === 'debit' ? 'credit' : 'debit',
        transactionNo: reversalEntry.entryNumber,
        lineNo: transaction.lineNo,
        subledgerType: transaction.subledgerType,
        currency: transaction.currency,
        isManual: true
      });
      
      reversalTransactions.push(reversalTransaction);
    }
    
    await Transaction.insertMany(reversalTransactions, { session });
    
    // Update original journal entry
    await JournalEntry.findByIdAndUpdate(
      journalEntry._id,
      { 
        $set: { 
          status: 'reversed',
          reversedBy: reversalEntry._id
        }
      },
      { session }
    );
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'REVERSE_JOURNAL_ENTRY',
      entityType: 'JournalEntry',
      entityId: journalEntry._id,
      userId: req.user.id,
      details: { 
        originalEntryNumber: journalEntry.entryNumber,
        reversalEntryNumber: reversalEntry.entryNumber,
        date: new Date(),
        amount: journalEntry.totalAmount
      }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.json({ 
      success: true,
      message: 'Journal entry reversed successfully',
      reversalEntry: {
        id: reversalEntry._id,
        entryNumber: reversalEntry.entryNumber
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error reversing journal entry:', error);
    next(error);
  } finally {
    session.endSession();
  }
};



================================================
File: server/controllers/reportController.js
================================================
// controllers/reportController.js
const Account = require('../models/account');
const Transaction = require('../models/transaction');
const logger = require('../utils/logger');

// Get Trial Balance
exports.getTrialBalance = async (req, res, next) => {
  try {
    const { entityId, startDate, endDate, level = 'detail' } = req.query;
    
    if (!entityId) {
      return res.status(400).json({ 
        success: false,
        message: 'Entity ID is required'
      });
    }

    // Validate date parameters
    const parsedStartDate = startDate ? new Date(startDate) : new Date(new Date().getFullYear(), 0, 1);
    const parsedEndDate = endDate ? new Date(endDate) : new Date();
    
    // Define account aggregation for Trial Balance
    const accounts = await Account.find({
      clientId: req.user.id,
      entityId: entityId,
      isActive: true
    }).sort({ accountNumber: 1 });
    
    // Get transactions for the period
    const transactions = await Transaction.find({
      clientId: req.user.id,
      entityId: entityId,
      date: { $gte: parsedStartDate, $lte: parsedEndDate }
    });
    
    // Calculate balances for each account
    const trialBalance = accounts.map(account => {
      const accountTransactions = transactions.filter(t => 
        t.accountId.toString() === account._id.toString()
      );
      
      const debits = accountTransactions
        .filter(t => t.type === 'debit')
        .reduce((sum, t) => sum + t.amount, 0);
        
      const credits = accountTransactions
        .filter(t => t.type === 'credit')
        .reduce((sum, t) => sum + t.amount, 0);
      
      // Calculate balance based on account type
      let balance = 0;
      if (['Asset', 'Expense'].includes(account.accountType)) {
        balance = debits - credits;
      } else {
        balance = credits - debits;
      }
      
      return {
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        debits,
        credits,
        balance
      };
    });
    
    // Summarize at parent account level if requested
    let result = trialBalance;
    if (level === 'summary') {
      // Group by first 2 digits of account number and summarize
      const summaryMap = {};
      trialBalance.forEach(account => {
        const prefix = account.accountNumber.substring(0, 2);
        if (!summaryMap[prefix]) {
          summaryMap[prefix] = {
            accountNumber: `${prefix}XX`,
            accountName: `${account.accountType} Summary (${prefix}XX)`,
            accountType: account.accountType,
            debits: 0,
            credits: 0,
            balance: 0
          };
        }
        summaryMap[prefix].debits += account.debits;
        summaryMap[prefix].credits += account.credits;
        summaryMap[prefix].balance += account.balance;
      });
      result = Object.values(summaryMap);
    }
    
    // Calculate totals
    const totals = {
      debits: result.reduce((sum, acc) => sum + acc.debits, 0),
      credits: result.reduce((sum, acc) => sum + acc.credits, 0),
      netIncome: result
        .filter(acc => ['Revenue', 'Expense'].includes(acc.accountType))
        .reduce((sum, acc) => sum + acc.balance, 0)
    };
    
    res.json({
      success: true,
      trialBalance: result,
      totals,
      period: {
        startDate: parsedStartDate,
        endDate: parsedEndDate
      },
      entityId
    });
  } catch (error) {
    logger.error('Trial Balance error:', error);
    next(error);
  }
};

// Get Balance Sheet
exports.getBalanceSheet = async (req, res, next) => {
  try {
    const { entityId, asOfDate } = req.query;
    
    if (!entityId) {
      return res.status(400).json({ 
        success: false,
        message: 'Entity ID is required'
      });
    }

    const parsedAsOfDate = asOfDate ? new Date(asOfDate) : new Date();
    
    // Get all accounts
    const accounts = await Account.find({
      clientId: req.user.id,
      entityId: entityId,
      isActive: true,
      accountType: { $in: ['Asset', 'Liability', 'Equity'] }
    }).sort({ accountNumber: 1 });
    
    // Get all transactions up to the as-of date
    const transactions = await Transaction.find({
      clientId: req.user.id,
      entityId: entityId,
      date: { $lte: parsedAsOfDate }
    });
    
    // Calculate balances for each account
    const balanceSheetAccounts = accounts.map(account => {
      const accountTransactions = transactions.filter(t => 
        t.accountId.toString() === account._id.toString()
      );
      
      const debits = accountTransactions
        .filter(t => t.type === 'debit')
        .reduce((sum, t) => sum + t.amount, 0);
        
      const credits = accountTransactions
        .filter(t => t.type === 'credit')
        .reduce((sum, t) => sum + t.amount, 0);
      
      // Calculate balance based on account type
      let balance = 0;
      if (account.accountType === 'Asset') {
        balance = debits - credits;
      } else {
        balance = credits - debits;
      }
      
      return {
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        balance
      };
    });
    
    // Organize by type and calculate totals
    const assets = balanceSheetAccounts.filter(a => a.accountType === 'Asset');
    const liabilities = balanceSheetAccounts.filter(a => a.accountType === 'Liability');
    const equity = balanceSheetAccounts.filter(a => a.accountType === 'Equity');
    
    const totalAssets = assets.reduce((sum, account) => sum + account.balance, 0);
    const totalLiabilities = liabilities.reduce((sum, account) => sum + account.balance, 0);
    const totalEquity = equity.reduce((sum, account) => sum + account.balance, 0);
    
    // Calculate Year-to-Date Income
    // Get income accounts
    const incomeAccounts = await Account.find({
      clientId: req.user.id,
      entityId: entityId,
      isActive: true,
      accountType: { $in: ['Revenue', 'Expense'] }
    });
    
    // Get current year start date
    const currentYear = parsedAsOfDate.getFullYear();
    const yearStartDate = new Date(currentYear, 0, 1);
    
    // Get income transactions for current year
    const incomeTransactions = await Transaction.find({
      clientId: req.user.id,
      entityId: entityId,
      accountId: { $in: incomeAccounts.map(a => a._id) },
      date: { $gte: yearStartDate, $lte: parsedAsOfDate }
    });
    
    // Calculate net income
    let netIncome = 0;
    incomeAccounts.forEach(account => {
      const accountTransactions = incomeTransactions.filter(t => 
        t.accountId.toString() === account._id.toString()
      );
      
      const debits = accountTransactions
        .filter(t => t.type === 'debit')
        .reduce((sum, t) => sum + t.amount, 0);
        
      const credits = accountTransactions
        .filter(t => t.type === 'credit')
        .reduce((sum, t) => sum + t.amount, 0);
      
      if (account.accountType === 'Revenue') {
        netIncome += (credits - debits);
      } else {
        netIncome -= (debits - credits);
      }
    });
    
    res.json({
      success: true,
      balanceSheet: {
        asOfDate: parsedAsOfDate,
        assets,
        liabilities,
        equity,
        netIncome,
        retainedEarnings: netIncome, // Simplified - would need more logic for real retained earnings
        totals: {
          assets: totalAssets,
          liabilities: totalLiabilities,
          equity: totalEquity + netIncome,
          liabilitiesAndEquity: totalLiabilities + totalEquity + netIncome
        }
      },
      entityId
    });
  } catch (error) {
    logger.error('Balance Sheet error:', error);
    next(error);
  }
};

// Get Income Statement
exports.getIncomeStatement = async (req, res, next) => {
  try {
    const { entityId, startDate, endDate } = req.query;
    
    if (!entityId) {
      return res.status(400).json({ 
        success: false,
        message: 'Entity ID is required'
      });
    }

    // Validate date parameters
    const parsedStartDate = startDate ? new Date(startDate) : new Date(new Date().getFullYear(), 0, 1);
    const parsedEndDate = endDate ? new Date(endDate) : new Date();
    
    // Get income accounts (Revenue and Expense)
    const accounts = await Account.find({
      clientId: req.user.id,
      entityId: entityId,
      isActive: true,
      accountType: { $in: ['Revenue', 'Expense'] }
    }).sort({ accountNumber: 1 });
    
    // Get transactions for the period
    const transactions = await Transaction.find({
      clientId: req.user.id,
      entityId: entityId,
      date: { $gte: parsedStartDate, $lte: parsedEndDate },
      accountId: { $in: accounts.map(a => a._id) }
    });
    
    // Calculate balances for each account
    const incomeAccounts = accounts.map(account => {
      const accountTransactions = transactions.filter(t => 
        t.accountId.toString() === account._id.toString()
      );
      
      const debits = accountTransactions
        .filter(t => t.type === 'debit')
        .reduce((sum, t) => sum + t.amount, 0);
        
      const credits = accountTransactions
        .filter(t => t.type === 'credit')
        .reduce((sum, t) => sum + t.amount, 0);
      
      // Calculate balance based on account type
      let balance = 0;
      if (account.accountType === 'Revenue') {
        balance = credits - debits;
      } else { // Expense
        balance = debits - credits;
      }
      
      return {
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        balance
      };
    });
    
    // Organize by type and calculate totals
    const revenue = incomeAccounts.filter(a => a.accountType === 'Revenue');
    const expenses = incomeAccounts.filter(a => a.accountType === 'Expense');
    
    const totalRevenue = revenue.reduce((sum, account) => sum + account.balance, 0);
    const totalExpenses = expenses.reduce((sum, account) => sum + account.balance, 0);
    const netIncome = totalRevenue - totalExpenses;
    
    res.json({
      success: true,
      incomeStatement: {
        period: {
          startDate: parsedStartDate,
          endDate: parsedEndDate
        },
        revenue,
        expenses,
        totals: {
          revenue: totalRevenue,
          expenses: totalExpenses,
          netIncome
        }
      },
      entityId
    });
  } catch (error) {
    logger.error('Income Statement error:', error);
    next(error);
  }
};



================================================
File: server/middleware/auth.js
================================================
// middleware/auth.js
const jwt = require('jsonwebtoken');
const User = require('../models/user');
const logger = require('../utils/logger');

/**
 * Authentication Middleware
 * Verifies JWT token from Authorization header and adds user to request
 */
exports.auth = async (req, res, next) => {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        status: 'error',
        message: 'Authorization denied. No valid token provided.'
      });
    }

    // Extract the token
    const token = authHeader.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({
        status: 'error',
        message: 'Authorization denied. Token is missing.'
      });
    }

    try {
      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Add user from payload to request
      req.user = decoded;
      
      // Check if token is about to expire (within 30 minutes)
      const tokenExp = new Date(decoded.exp * 1000);
      const now = new Date();
      const timeDiff = tokenExp.getTime() - now.getTime();
      const minutesLeft = Math.floor(timeDiff / 1000 / 60);
      
      // If token is about to expire (less than 30 minutes), refresh it
      if (minutesLeft < 30) {
        // Get user from database to ensure they still exist and their role hasn't changed
        const user = await User.findById(decoded.id).select('-password');
        
        if (user) {
          // Generate a new token
          const newToken = jwt.sign(
            { 
              id: user._id, 
              isAdmin: user.isAdmin,
              email: user.email
            },
            process.env.JWT_SECRET,
            { expiresIn: '24h' }
          );
          
          // Add token to response headers
          res.setHeader('x-auth-token', newToken);
        }
      }
      
      next();
    } catch (error) {
      logger.error(`Token verification error: ${error.message}`);
      
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
          status: 'error',
          message: 'Token has expired. Please log in again.'
        });
      }
      
      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({
          status: 'error',
          message: 'Invalid token. Please log in again.'
        });
      }
      
      return res.status(401).json({
        status: 'error',
        message: 'Token verification failed. Please log in again.'
      });
    }
  } catch (error) {
    logger.error(`Auth middleware error: ${error.message}`);
    return res.status(500).json({
      status: 'error',
      message: 'Server error in authentication.'
    });
  }
};

/**
 * Admin Authorization Middleware
 * Ensures the authenticated user has admin privileges
 */
exports.adminAuth = async (req, res, next) => {
  try {
    // Run the auth middleware first to verify token
    exports.auth(req, res, async () => {
      try {
        // Check if user exists and is an admin
        const user = await User.findById(req.user.id);
        
        if (!user) {
          return res.status(404).json({
            status: 'error',
            message: 'User not found.'
          });
        }
        
        if (!user.isAdmin) {
          logger.warn(`Non-admin user ${user.email} (${user._id}) attempted to access admin route`);
          return res.status(403).json({
            status: 'error',
            message: 'Access denied. Admin privileges required.'
          });
        }
        
        logger.info(`Admin access granted to ${user.email} (${user._id})`);
        next();
      } catch (error) {
        logger.error(`Admin auth error: ${error.message}`);
        return res.status(500).json({
          status: 'error',
          message: 'Server error in admin authorization.'
        });
      }
    });
  } catch (error) {
    logger.error(`Admin middleware error: ${error.message}`);
    return res.status(500).json({
      status: 'error',
      message: 'Server error in authorization.'
    });
  }
};

/**
 * Role-Based Access Control Middleware
 * Ensures the authenticated user has the required role
 * @param {Array} roles - Array of allowed roles
 */
exports.roleAuth = (roles) => {
  return async (req, res, next) => {
    try {
      // Run the auth middleware first to verify token
      exports.auth(req, res, async () => {
        try {
          // Check if user exists
          const user = await User.findById(req.user.id);
          
          if (!user) {
            return res.status(404).json({
              status: 'error',
              message: 'User not found.'
            });
          }
          
          // Check if user has the required role
          if (user.isAdmin) {
            // Admin can access all routes
            next();
          } else if (roles.includes('client')) {
            // User with client role can access this route
            next();
          } else {
            logger.warn(`User ${user.email} (${user._id}) lacks required role for this route`);
            return res.status(403).json({
              status: 'error',
              message: 'Access denied. Required role not found.'
            });
          }
        } catch (error) {
          logger.error(`Role auth error: ${error.message}`);
          return res.status(500).json({
            status: 'error',
            message: 'Server error in role authorization.'
          });
        }
      });
    } catch (error) {
      logger.error(`Role middleware error: ${error.message}`);
      return res.status(500).json({
        status: 'error',
        message: 'Server error in role authorization.'
      });
    }
  };
};



================================================
File: server/middleware/errorHandler.js
================================================
// middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const errors = {};
    
    for (const field in err.errors) {
      errors[field] = err.errors[field].message;
    }
    
    return res.status(400).json({ 
      message: 'Validation error', 
      errors 
    });
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({ message: 'Invalid token' });
  }

  if (err.name === 'TokenExpiredError') {
    return res.status(401).json({ message: 'Token expired' });
  }

  // Default to 500 server error
  res.status(err.statusCode || 500).json({
    message: err.message || 'Internal Server Error',
    error: process.env.NODE_ENV === 'development' ? err.message : 'An unexpected error occurred'
  });
};

module.exports = errorHandler;



================================================
File: server/middleware/requestValidator.js
================================================
// middleware/requestValidator.js
const { validationResult } = require('express-validator');

/**
 * Global validation middleware for express-validator
 * This checks for validation errors from any validation chain
 */
const validateRequest = (req, res, next) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  
  next();
};

module.exports = validateRequest;



================================================
File: server/models/account.js
================================================
// models/account.js
const mongoose = require('mongoose');

const AccountSchema = new mongoose.Schema({
  clientId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true 
  },
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true,
    index: true
  },
  accountNumber: { 
    type: String, 
    required: true,
    index: true
  },
  accountName: { 
    type: String, 
    required: true 
  },
  accountType: { 
    type: String, 
    required: true,
    enum: ['Asset', 'Liability', 'Equity', 'Revenue', 'Expense'],
    index: true
  },
  subledgerType: { 
    type: String,
    enum: ['GL', 'AP', 'AR', 'Payroll', 'Inventory', 'Assets', null],
    default: 'GL',
    index: true
  },
  description: { 
    type: String 
  },
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },
  parentAccount: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account',
    default: null
  },
  balance: {
    type: Number,
    default: 0
  },
  lastUpdated: {
    type: Date,
    default: Date.now
  },
  isManual: { 
    type: Boolean, 
    default: true 
  },
  // Multi-entity and consolidation fields
  isIntercompany: {
    type: Boolean,
    default: false,
    index: true
  },
  intercompanyPairAccount: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account'
  },
  eliminationCategory: {
    type: String,
    enum: ['Investment', 'Receivable-Payable', 'Revenue-Expense', 'Other', null],
    default: null,
    index: true
  },
  currency: {
    type: String,
    default: 'USD'
  },
  metadata: {
    type: Object,
    default: {}
  }
}, {
  timestamps: true
});

// Create unique compound index for clientId + entityId + accountNumber
AccountSchema.index({ clientId: 1, entityId: 1, accountNumber: 1 }, { unique: true });

module.exports = mongoose.model('Account', AccountSchema);



================================================
File: server/models/auditLog.js
================================================
const mongoose = require('mongoose');

const AuditLogSchema = new mongoose.Schema({
  clientId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  action: { type: String, required: true },
  entityType: { type: String, required: true },
  entityId: String,
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  timestamp: { type: Date, default: Date.now },
  details: { type: Object }
});

module.exports = mongoose.model('AuditLog', AuditLogSchema);



================================================
File: server/models/blog.js
================================================
const mongoose = require('mongoose');

const BlogSchema = new mongoose.Schema({
  title: String,
  content: String,
  isDraft: { type: Boolean, default: true },
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Blog', BlogSchema);



================================================
File: server/models/budget.js
================================================
const mongoose = require('mongoose');

const BudgetSchema = new mongoose.Schema({
  clientId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  accountNumber: { type: String, required: true },
  subledgerType: String,
  amount: { type: Number, required: true },
  period: { type: String, enum: ['monthly', 'quarterly'], required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
  isManual: { type: Boolean, default: true }
});

module.exports = mongoose.model('Budget', BudgetSchema);



================================================
File: server/models/cashFlowForecast.js
================================================
const mongoose = require('mongoose');

const CashFlowForecastSchema = new mongoose.Schema({
  clientId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  forecastPeriod: { type: Date, required: true },
  inflows: { type: Number, required: true },
  outflows: { type: Number, required: true },
  netCash: { type: Number, required: true },
  generatedAt: { type: Date, default: Date.now },
  aiRecommendations: { type: Object },
  isManual: { type: Boolean, default: true }
});

module.exports = mongoose.model('CashFlowForecast', CashFlowForecastSchema);



================================================
File: server/models/chartOfAccounts.js
================================================
const mongoose = require('mongoose');

const AccountTemplateSchema = new mongoose.Schema({
  accountNumber: { type: String, required: true, trim: true },
  accountName: { type: String, required: true, trim: true },
  accountType: {
    type: String,
    required: true,
    enum: ['Asset', 'Liability', 'Equity', 'Revenue', 'Expense']
  },
  fslCategory: { type: String, required: true, trim: true },
  isActive: { type: Boolean, default: true },
  parentAccount: { type: String, default: null },
  description: { type: String, trim: true },
  subledgerType: {
    type: String,
    enum: ['GL', 'AP', 'AR', 'Payroll', 'Inventory', 'Assets', null],
    default: 'GL'
  },
  isIntercompany: { type: Boolean, default: false },
  currency: { type: String, default: 'USD' },
  customFields: {
    type: Map,
    of: mongoose.Schema.Types.Mixed,
    default: {}
  },
  tags: [String],
  displayOptions: {
    color: String,
    icon: String,
    displayOrder: Number
  }
});

const ChartOfAccountsSchema = new mongoose.Schema({
  clientId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true,
    index: true
  },
  name: { type: String, required: true },
  description: String,
  accounts: [AccountTemplateSchema],
  isActive: { type: Boolean, default: true },
  version: { type: Number, default: 1 },
  defaultCurrency: { type: String, default: 'USD' },
  industry: { type: String, index: true },
  customFieldDefinitions: [{
    fieldName: String,
    fieldType: {
      type: String,
      enum: ['text', 'number', 'boolean', 'date', 'select']
    },
    required: Boolean,
    options: [String],
    defaultValue: mongoose.Schema.Types.Mixed
  }],
  reportingMappings: {
    type: Map,
    of: String
  }
}, {
  timestamps: true
});

// Removed duplicate index definitions (kept schema-level only)
ChartOfAccountsSchema.index({ clientId: 1, entityId: 1, name: 1 }, { unique: true });
ChartOfAccountsSchema.index({ 'accounts.accountNumber': 1 });
ChartOfAccountsSchema.index({ 'accounts.accountType': 1 });
ChartOfAccountsSchema.index({ 'accounts.fslCategory': 1 });

ChartOfAccountsSchema.methods.validateUniqueAccountNumbers = function() {
  const accountNumbers = this.accounts.map(a => a.accountNumber);
  const uniqueNumbers = new Set(accountNumbers);
  return accountNumbers.length === uniqueNumbers.size;
};

ChartOfAccountsSchema.statics.createDefault = async function(clientId, entityId, name = 'Default Chart of Accounts') {
  const defaultAccounts = [
    { accountNumber: '1000', accountName: 'Cash', accountType: 'Asset', fslCategory: 'Cash and Cash Equivalents' },
    { accountNumber: '1100', accountName: 'Accounts Receivable', accountType: 'Asset', fslCategory: 'Accounts Receivable', subledgerType: 'AR' },
    { accountNumber: '1200', accountName: 'Inventory', accountType: 'Asset', fslCategory: 'Inventory', subledgerType: 'Inventory' },
    { accountNumber: '1300', accountName: 'Prepaid Expenses', accountType: 'Asset', fslCategory: 'Prepaid Expenses' },
    { accountNumber: '1500', accountName: 'Fixed Assets', accountType: 'Asset', fslCategory: 'Property, Plant and Equipment', subledgerType: 'Assets' },
    { accountNumber: '1600', accountName: 'Accumulated Depreciation', accountType: 'Asset', fslCategory: 'Property, Plant and Equipment', subledgerType: 'Assets' },
    { accountNumber: '2000', accountName: 'Accounts Payable', accountType: 'Liability', fslCategory: 'Accounts Payable', subledgerType: 'AP' },
    { accountNumber: '2100', accountName: 'Accrued Liabilities', accountType: 'Liability', fslCategory: 'Accrued Liabilities' },
    { accountNumber: '2200', accountName: 'Payroll Liabilities', accountType: 'Liability', fslCategory: 'Payroll Liabilities', subledgerType: 'Payroll' },
    { accountNumber: '2300', accountName: 'Short-term Loans', accountType: 'Liability', fslCategory: 'Short-term Debt' },
    { accountNumber: '2700', accountName: 'Long-term Debt', accountType: 'Liability', fslCategory: 'Long-term Debt' },
    { accountNumber: '3000', accountName: 'Common Stock', accountType: 'Equity', fslCategory: 'Common Stock' },
    { accountNumber: '3100', accountName: 'Retained Earnings', accountType: 'Equity', fslCategory: 'Retained Earnings' },
    { accountNumber: '4000', accountName: 'Sales Revenue', accountType: 'Revenue', fslCategory: 'Revenue' },
    { accountNumber: '4900', accountName: 'Other Income', accountType: 'Revenue', fslCategory: 'Other Income' },
    { accountNumber: '5000', accountName: 'Cost of Goods Sold', accountType: 'Expense', fslCategory: 'Cost of Goods Sold' },
    { accountNumber: '6000', accountName: 'Salaries and Wages', accountType: 'Expense', fslCategory: 'Operating Expenses', subledgerType: 'Payroll' },
    { accountNumber: '6100', accountName: 'Rent Expense', accountType: 'Expense', fslCategory: 'Operating Expenses' },
    { accountNumber: '6200', accountName: 'Utilities Expense', accountType: 'Expense', fslCategory: 'Operating Expenses' },
    { accountNumber: '6300', accountName: 'Office Supplies', accountType: 'Expense', fslCategory: 'Operating Expenses' },
    { accountNumber: '6900', accountName: 'Depreciation Expense', accountType: 'Expense', fslCategory: 'Operating Expenses' },
    { accountNumber: '7000', accountName: 'Interest Expense', accountType: 'Expense', fslCategory: 'Interest Expense' },
    { accountNumber: '9000', accountName: 'Income Tax Expense', accountType: 'Expense', fslCategory: 'Income Tax Expense' }
  ];

  const coa = new this({
    clientId,
    entityId,
    name,
    description: 'Standard chart of accounts',
    accounts: defaultAccounts,
    customFieldDefinitions: [
      { fieldName: 'department', fieldType: 'text', required: false },
      { fieldName: 'location', fieldType: 'text', required: false }
    ]
  });

  await coa.save();
  return coa;
};

module.exports = mongoose.model('ChartOfAccounts', ChartOfAccountsSchema);



================================================
File: server/models/chat.js
================================================
const mongoose = require('mongoose');

const ChatSchema = new mongoose.Schema({
  userId: String, // Can be null for guest chats
  message: String,
  reply: String,
  isClientChat: Boolean,
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Chat', ChatSchema);



================================================
File: server/models/checklist.js
================================================
const mongoose = require('mongoose');

const ChecklistSchema = new mongoose.Schema({
  userId: String, // Optional for guests
  name: String,
  email: String,
  companyName: String,
  revenueRange: String,
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Checklist', ChecklistSchema);



================================================
File: server/models/consolidation.js
================================================
// models/consolidation.js
const mongoose = require('mongoose');

const ConsolidationSchema = new mongoose.Schema({
  clientId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  name: {
    type: String,
    required: true
  },
  period: {
    year: {
      type: Number,
      required: true
    },
    month: {
      type: Number,
      required: true
    },
    quarter: {
      type: Number
    },
    startDate: {
      type: Date,
      required: true
    },
    endDate: {
      type: Date,
      required: true
    }
  },
  consolidatedEntityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true
  },
  includedEntities: [{
    entityId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Entity'
    },
    ownershipPercentage: {
      type: Number,
      default: 100
    },
    consolidationMethod: {
      type: String,
      enum: ['Full', 'Proportional', 'Equity', 'Not Consolidated']
    }
  }],
  status: {
    type: String,
    enum: ['Draft', 'Processing', 'Completed', 'Error'],
    default: 'Draft'
  },
  eliminationEntries: [{
    journalEntryId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'JournalEntry'
    },
    description: String,
    amount: Number,
    category: String
  }],
  exchangeRates: [{
    sourceCurrency: String,
    targetCurrency: String,
    rate: Number,
    date: Date
  }],
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  processedAt: Date,
  metadata: {
    type: Object,
    default: {}
  }
}, {
  timestamps: true
});

ConsolidationSchema.index({ clientId: 1, 'period.year': 1, 'period.month': 1 });
ConsolidationSchema.index({ clientId: 1, consolidatedEntityId: 1, 'period.year': 1, 'period.month': 1 });

module.exports = mongoose.model('Consolidation', ConsolidationSchema);



================================================
File: server/models/consultation.js
================================================
const mongoose = require('mongoose');

const ConsultationSchema = new mongoose.Schema({
  userId: String, // Optional for guests
  companyName: String,
  industry: String,
  yearsInBusiness: String,
  revenueRange: String,
  services: [String],
  contactName: String,
  email: String,
  phone: String,
  preferredContact: String,
  preferredTime: String,
  notes: String,
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Consultation', ConsultationSchema);



================================================
File: server/models/contact.js
================================================
const mongoose = require('mongoose');

const ContactSchema = new mongoose.Schema({
  userId: String, // Optional for guests
  name: String,
  email: String,
  company: String,
  message: String,
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Contact', ContactSchema);



================================================
File: server/models/content.js
================================================
const mongoose = require('mongoose');

const ContentSchema = new mongoose.Schema({
  section: String,
  value: mongoose.Mixed,
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('Content', ContentSchema);



================================================
File: server/models/entity.js
================================================
// models/entity.js
const mongoose = require('mongoose');

const EntitySchema = new mongoose.Schema({
  name: { 
    type: String, 
    required: true 
  },
  code: { 
    type: String, 
    required: true,
    index: true
  },
  clientId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User',
    index: true
  },
  parentEntityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    default: null
  },
  type: {
    type: String,
    enum: ['Operating', 'Holding', 'Special Purpose', 'Elimination', 'Consolidated'],
    default: 'Operating',
    index: true
  },
  currency: {
    type: String,
    default: 'USD'
  },
  isActive: {
    type: Boolean,
    default: true,
    index: true
  },
  consolidationSettings: {
    isIncludedInConsolidation: {
      type: Boolean,
      default: true
    },
    ownershipPercentage: {
      type: Number,
      default: 100
    },
    consolidationMethod: {
      type: String,
      enum: ['Full', 'Proportional', 'Equity', 'Not Consolidated'],
      default: 'Full'
    },
    eliminationRules: [{
      sourceAccount: String,
      targetAccount: String,
      eliminationEntity: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Entity'
      },
      description: String,
      isAutomatic: Boolean
    }]
  },
  metadata: {
    type: Object,
    default: {}
  }
}, {
  timestamps: true
});

// Add unique compound index for clientId + code
EntitySchema.index({ clientId: 1, code: 1 }, { unique: true });

module.exports = mongoose.model('Entity', EntitySchema);



================================================
File: server/models/entityGroup.js
================================================
// models/entityGroup.js
const EntityGroupSchema = new mongoose.Schema({
  clientId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  name: { type: String, required: true },
  description: String,
  entities: [{ 
    entityId: { type: mongoose.Schema.Types.ObjectId, ref: 'Entity', required: true },
    ownership: { type: Number, default: 100 }, // percentage
    consolidationMethod: { type: String, enum: ['full', 'equity', 'proportional'], default: 'full' }
  }],
  eliminationRules: [{
    sourceAccount: String,
    targetAccount: String,
    description: String
  }]
});



================================================
File: server/models/file.js
================================================
const mongoose = require('mongoose');

const FileSchema = new mongoose.Schema({
  userId: String, // Required for authenticated users only
  fileName: String,
  s3Key: String,
  timestamp: { type: Date, default: Date.now },
});

module.exports = mongoose.model('File', FileSchema);



================================================
File: server/models/fixedAsset.js
================================================
// models/fixedAsset.js
const mongoose = require('mongoose');

const DepreciationScheduleSchema = new mongoose.Schema({
  period: { 
    type: Date, 
    required: true 
  },
  amount: { 
    type: Number, 
    required: true 
  },
  remainingValue: { 
    type: Number, 
    required: true 
  }
});

const FixedAssetSchema = new mongoose.Schema({
  clientId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true,
    index: true
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  assetNumber: {
    type: String,
    trim: true,
    index: true
  },
  assetCategory: {
    type: String,
    required: true,
    enum: ['equipment', 'furniture', 'vehicles', 'buildings', 'land', 'computers', 'software', 'other'],
    index: true
  },
  location: {
    type: String,
    trim: true
  },
  acquisitionDate: {
    type: Date,
    required: true,
    index: true
  },
  acquisitionCost: {
    type: Number,
    required: true
  },
  depreciationMethod: {
    type: String,
    enum: ['straight-line', 'declining-balance', 'units-of-production'],
    default: 'straight-line'
  },
  usefulLife: {
    type: Number, // in months
    required: true
  },
  salvageValue: {
    type: Number,
    default: 0
  },
  currentBookValue: {
    type: Number,
    required: true
  },
  lastDepreciationDate: {
    type: Date
  },
  depreciationSchedule: [DepreciationScheduleSchema],
  disposed: {
    type: Boolean,
    default: false,
    index: true
  },
  disposalDate: {
    type: Date
  },
  disposalValue: {
    type: Number
  },
  journalEntryIds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'JournalEntry'
  }],
  accountId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account'
  },
  depreciationAccountId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account'
  },
  accumulatedDepreciationAccountId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account'
  },
  notes: {
    type: String
  },
  attachments: [{
    fileId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'File'
    },
    fileName: String,
    uploadDate: Date
  }],
  metadata: {
    type: Object,
    default: {}
  }
}, {
  timestamps: true
});

// Create compound indexes
FixedAssetSchema.index({ clientId: 1, entityId: 1, assetCategory: 1 });
FixedAssetSchema.index({ clientId: 1, entityId: 1, disposed: 1 });
FixedAssetSchema.index({ clientId: 1, entityId: 1, acquisitionDate: 1 });

// Pre-save middleware to set currentBookValue if not provided
FixedAssetSchema.pre('save', function(next) {
  if (this.isNew && this.currentBookValue === undefined) {
    this.currentBookValue = this.acquisitionCost;
  }
  next();
});

// Method to calculate depreciation
FixedAssetSchema.methods.calculateDepreciation = function(toDate) {
  const endDate = toDate || new Date();
  const startDate = this.lastDepreciationDate || this.acquisitionDate;
  
  // Don't calculate if the asset is disposed or not enough time has passed
  if (this.disposed || startDate >= endDate) {
    return 0;
  }
  
  let depreciationAmount = 0;
  
  switch(this.depreciationMethod) {
    case 'straight-line':
      // Monthly depreciation = (Cost - Salvage) / Useful life (in months)
      const monthlyDepreciation = (this.acquisitionCost - this.salvageValue) / this.usefulLife;
      
      // Calculate months between dates
      const startDateObj = new Date(startDate);
      const endDateObj = new Date(endDate);
      const months = (endDateObj.getFullYear() - startDateObj.getFullYear()) * 12 + 
                     (endDateObj.getMonth() - startDateObj.getMonth());
      
      depreciationAmount = monthlyDepreciation * months;
      break;
      
    case 'declining-balance':
      // Implement declining balance calculation
      // This is a more complex calculation that would need to be implemented based on specific requirements
      break;
      
    case 'units-of-production':
      // Units of production would require tracking the actual usage/production
      // This would need additional fields and calculation logic
      break;
  }
  
  // Ensure we don't depreciate below salvage value
  const maxAllowableDepreciation = this.currentBookValue - this.salvageValue;
  depreciationAmount = Math.min(depreciationAmount, maxAllowableDepreciation);
  depreciationAmount = Math.max(depreciationAmount, 0); // Ensure non-negative
  
  return depreciationAmount;
};

// Static method to run monthly depreciation for all assets
FixedAssetSchema.statics.runMonthlyDepreciation = async function(clientId, entityId, date = new Date()) {
  const assets = await this.find({
    clientId,
    entityId,
    disposed: false
  });
  
  const results = [];
  
  for (const asset of assets) {
    const depreciationAmount = asset.calculateDepreciation(date);
    
    if (depreciationAmount > 0) {
      // Update the asset
      asset.currentBookValue -= depreciationAmount;
      asset.lastDepreciationDate = date;
      
      // Add to depreciation schedule
      asset.depreciationSchedule.push({
        period: date,
        amount: depreciationAmount,
        remainingValue: asset.currentBookValue
      });
      
      await asset.save();
      
      results.push({
        assetId: asset._id,
        assetName: asset.name,
        depreciationAmount,
        currentBookValue: asset.currentBookValue
      });
    }
  }
  
  return results;
};

module.exports = mongoose.model('FixedAsset', FixedAssetSchema);

// routes/fixedAssets.js
const express = require('express');
const router = express.Router();
const { body, param, query, validationResult } = require('express-validator');
const FixedAsset = require('../models/fixedAsset');
const Entity = require('../models/entity');
const Account = require('../models/account');
const AuditLog = require('../models/auditLog');
const { auth, adminAuth } = require('../middleware/auth');
const mongoose = require('mongoose');
const logger = require('../utils/logger');

// Get all fixed assets
router.get('/', auth, async (req, res, next) => {
  try {
    const { entityId, category, disposed, search } = req.query;
    
    // Build query
    const query = { clientId: req.user.id };
    
    if (entityId) {
      query.entityId = entityId;
    }
    
    if (category) {
      query.assetCategory = category;
    }
    
    if (disposed !== undefined) {
      query.disposed = disposed === 'true';
    }
    
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { assetNumber: { $regex: search, $options: 'i' } }
      ];
    }
    
    const assets = await FixedAsset.find(query)
      .sort({ acquisitionDate: -1 })
      .populate('entityId', 'name code')
      .populate('accountId', 'accountNumber accountName')
      .lean();
    
    res.json({
      success: true,
      assets
    });
  } catch (error) {
    logger.error('Error fetching fixed assets:', error);
    next(error);
  }
});

// Get a single fixed asset
router.get('/:id', auth, async (req, res, next) => {
  try {
    const asset = await FixedAsset.findOne({
      _id: req.params.id,
      clientId: req.user.id
    })
      .populate('entityId', 'name code')
      .populate('accountId', 'accountNumber accountName')
      .populate('depreciationAccountId', 'accountNumber accountName')
      .populate('accumulatedDepreciationAccountId', 'accountNumber accountName')
      .lean();
    
    if (!asset) {
      return res.status(404).json({
        success: false,
        message: 'Fixed asset not found'
      });
    }
    
    res.json({
      success: true,
      asset
    });
  } catch (error) {
    logger.error('Error fetching fixed asset:', error);
    next(error);
  }
});

// Create a new fixed asset
router.post('/', auth, [
  body('entityId')
    .isMongoId()
    .withMessage('Valid entity ID is required'),
  body('name')
    .notEmpty()
    .withMessage('Asset name is required'),
  body('assetCategory')
    .isIn(['equipment', 'furniture', 'vehicles', 'buildings', 'land', 'computers', 'software', 'other'])
    .withMessage('Valid asset category is required'),
  body('acquisitionDate')
    .isDate()
    .withMessage('Valid acquisition date is required'),
  body('acquisitionCost')
    .isFloat({ min: 0 })
    .withMessage('Acquisition cost must be a positive number'),
  body('depreciationMethod')
    .isIn(['straight-line', 'declining-balance', 'units-of-production'])
    .withMessage('Valid depreciation method is required'),
  body('usefulLife')
    .isInt({ min: 1 })
    .withMessage('Useful life must be a positive integer'),
  body('salvageValue')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Salvage value must be a positive number')
], async (req, res, next) => {
  // Check for validation errors
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const {
      entityId,
      name,
      description,
      assetNumber,
      assetCategory,
      location,
      acquisitionDate,
      acquisitionCost,
      depreciationMethod,
      usefulLife,
      salvageValue = 0,
      accountId,
      depreciationAccountId,
      accumulatedDepreciationAccountId,
      notes
    } = req.body;
    
    // Verify entity exists and belongs to client
    const entity = await Entity.findOne({
      _id: entityId,
      clientId: req.user.id
    }).session(session);
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found or you do not have permission'
      });
    }
    
    // Validate account IDs if provided
    if (accountId) {
      const account = await Account.findOne({
        _id: accountId,
        clientId: req.user.id,
        entityId
      }).session(session);
      
      if (!account) {
        return res.status(404).json({
          success: false,
          message: 'Asset account not found or does not belong to this entity'
        });
      }
    }
    
    if (depreciationAccountId) {
      const depAccount = await Account.findOne({
        _id: depreciationAccountId,
        clientId: req.user.id,
        entityId
      }).session(session);
      
      if (!depAccount) {
        return res.status(404).json({
          success: false,
          message: 'Depreciation account not found or does not belong to this entity'
        });
      }
    }
    
    if (accumulatedDepreciationAccountId) {
      const accDepAccount = await Account.findOne({
        _id: accumulatedDepreciationAccountId,
        clientId: req.user.id,
        entityId
      }).session(session);
      
      if (!accDepAccount) {
        return res.status(404).json({
          success: false,
          message: 'Accumulated depreciation account not found or does not belong to this entity'
        });
      }
    }
    
    // Create the fixed asset
    const asset = new FixedAsset({
      clientId: req.user.id,
      entityId,
      name,
      description,
      assetNumber,
      assetCategory,
      location,
      acquisitionDate,
      acquisitionCost,
      depreciationMethod,
      usefulLife,
      salvageValue,
      currentBookValue: acquisitionCost, // Initial book value is the acquisition cost
      accountId,
      depreciationAccountId,
      accumulatedDepreciationAccountId,
      notes
    });
    
    await asset.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'CREATE_FIXED_ASSET',
      entityType: 'FixedAsset',
      entityId: asset._id,
      userId: req.user.id,
      details: {
        name,
        assetCategory,
        acquisitionDate,
        acquisitionCost
      }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.status(201).json({
      success: true,
      message: 'Fixed asset created successfully',
      asset: {
        id: asset._id,
        name: asset.name,
        assetCategory: asset.assetCategory,
        acquisitionDate: asset.acquisitionDate,
        acquisitionCost: asset.acquisitionCost,
        currentBookValue: asset.currentBookValue
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error creating fixed asset:', error);
    next(error);
  } finally {
    session.endSession();
  }
});

// Update a fixed asset
router.put('/:id', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid asset ID format'),
  body('name')
    .optional()
    .notEmpty()
    .withMessage('Asset name cannot be empty'),
  body('assetCategory')
    .optional()
    .isIn(['equipment', 'furniture', 'vehicles', 'buildings', 'land', 'computers', 'software', 'other'])
    .withMessage('Valid asset category is required'),
  body('acquisitionDate')
    .optional()
    .isDate()
    .withMessage('Valid acquisition date is required'),
  body('acquisitionCost')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Acquisition cost must be a positive number'),
  body('depreciationMethod')
    .optional()
    .isIn(['straight-line', 'declining-balance', 'units-of-production'])
    .withMessage('Valid depreciation method is required'),
  body('usefulLife')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Useful life must be a positive integer'),
  body('salvageValue')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Salvage value must be a positive number')
], async (req, res, next) => {
  // Check for validation errors
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Find asset and make sure it belongs to this client
    const asset = await FixedAsset.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!asset) {
      return res.status(404).json({
        success: false,
        message: 'Fixed asset not found'
      });
    }
    
    // Cannot modify disposed assets
    if (asset.disposed) {
      return res.status(400).json({
        success: false,
        message: 'Cannot modify a disposed asset'
      });
    }
    
    const updateFields = [
      'name', 'description', 'assetNumber', 'assetCategory', 'location',
      'acquisitionDate', 'acquisitionCost', 'depreciationMethod', 'usefulLife',
      'salvageValue', 'accountId', 'depreciationAccountId', 'accumulatedDepreciationAccountId',
      'notes'
    ];
    
    // Update fields
    updateFields.forEach(field => {
      if (req.body[field] !== undefined) {
        asset[field] = req.body[field];
      }
    });
    
    // If acquisition cost, useful life, or salvage value changed, recalculate book value
    if (
      req.body.acquisitionCost !== undefined ||
      req.body.usefulLife !== undefined ||
      req.body.salvageValue !== undefined
    ) {
      // This is a simplified recalculation - in a real system, you'd need to handle
      // past depreciation, etc. more carefully
      if (asset.depreciationSchedule.length === 0) {
        // If no depreciation has been recorded yet, just reset to acquisition cost
        asset.currentBookValue = asset.acquisitionCost;
      } else {
        // Otherwise, we'd need a more complex recalculation based on depreciation history
        // This is just a placeholder - real implementation would be more complex
        logger.warn('Asset parameters changed after depreciation started - book value may need adjustment');
      }
    }
    
    await asset.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'UPDATE_FIXED_ASSET',
      entityType: 'FixedAsset',
      entityId: asset._id,
      userId: req.user.id,
      details: req.body
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Fixed asset updated successfully',
      asset: {
        id: asset._id,
        name: asset.name,
        assetCategory: asset.assetCategory,
        acquisitionDate: asset.acquisitionDate,
        acquisitionCost: asset.acquisitionCost,
        currentBookValue: asset.currentBookValue
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error updating fixed asset:', error);
    next(error);
  } finally {
    session.endSession();
  }
});

// Dispose of a fixed asset
router.put('/:id/dispose', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid asset ID format'),
  body('disposalDate')
    .isDate()
    .withMessage('Valid disposal date is required'),
  body('disposalValue')
    .isFloat({ min: 0 })
    .withMessage('Disposal value must be a positive number')
], async (req, res, next) => {
  // Check for validation errors
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const { disposalDate, disposalValue } = req.body;
    
    // Find asset and make sure it belongs to this client
    const asset = await FixedAsset.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!asset) {
      return res.status(404).json({
        success: false,
        message: 'Fixed asset not found'
      });
    }
    
    // Cannot dispose of an already disposed asset
    if (asset.disposed) {
      return res.status(400).json({
        success: false,
        message: 'Asset has already been disposed'
      });
    }
    
    // Update asset
    asset.disposed = true;
    asset.disposalDate = disposalDate;
    asset.disposalValue = disposalValue;
    
    await asset.save({ session });
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'DISPOSE_FIXED_ASSET',
      entityType: 'FixedAsset',
      entityId: asset._id,
      userId: req.user.id,
      details: {
        disposalDate,
        disposalValue,
        bookValueAtDisposal: asset.currentBookValue
      }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Asset marked as disposed',
      asset: {
        id: asset._id,
        name: asset.name,
        disposalDate: asset.disposalDate,
        disposalValue: asset.disposalValue,
        bookValueAtDisposal: asset.currentBookValue
      }
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error disposing fixed asset:', error);
    next(error);
  } finally {
    session.endSession();
  }
});

// Delete a fixed asset
router.delete('/:id', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid asset ID format')
], async (req, res, next) => {
  // Check for validation errors
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Find asset and make sure it belongs to this client
    const asset = await FixedAsset.findOne({
      _id: req.params.id,
      clientId: req.user.id
    }).session(session);
    
    if (!asset) {
      return res.status(404).json({
        success: false,
        message: 'Fixed asset not found'
      });
    }
    
    // Delete the asset
    await FixedAsset.deleteOne({ _id: asset._id }).session(session);
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'DELETE_FIXED_ASSET',
      entityType: 'FixedAsset',
      entityId: asset._id,
      userId: req.user.id,
      details: {
        name: asset.name,
        assetCategory: asset.assetCategory,
        acquisitionCost: asset.acquisitionCost,
        currentBookValue: asset.currentBookValue
      }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.json({
      success: true,
      message: 'Fixed asset deleted successfully'
    });
  } catch (error) {
    await session.abortTransaction();
    logger.error('Error deleting fixed asset:', error);
    next(error);
  } finally {
    session.endSession();
  }
});

// Run depreciation for all assets (admin only)
router.post('/run-depreciation', adminAuth, [
  body('entityId')
    .isMongoId()
    .withMessage('Valid entity ID is required'),
  body('date')
    .optional()
    .isDate()
    .withMessage('Valid date is required')
], async (req, res, next) => {
  // Check for validation errors
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  
  try {
    const { entityId, date } = req.body;
    
    // Verify entity exists and belongs to client
    const entity = await Entity.findOne({
      _id: entityId,
      clientId: req.user.id
    });
    
    if (!entity) {
      return res.status(404).json({
        success: false,
        message: 'Entity not found or you do not have permission'
      });
    }
    
    // Run depreciation
    const depreciationResults = await FixedAsset.runMonthlyDepreciation(
      req.user.id,
      entityId,
      date ? new Date(date) : new Date()
    );
    
    res.json({
      success: true,
      message: `Depreciation completed for ${depreciationResults.length} assets`,
      results: depreciationResults
    });
  } catch (error) {
    logger.error('Error running depreciation:', error);
    next(error);
  }
});

module.exports = router;



================================================
File: server/models/invoice.js
================================================
// models/invoice.js
const mongoose = require('mongoose');

const InvoiceLineItemSchema = new mongoose.Schema({
  description: {
    type: String,
    required: true,
    trim: true
  },
  quantity: {
    type: Number,
    required: true,
    default: 1
  },
  unitPrice: {
    type: Number,
    required: true
  },
  amount: {
    type: Number,
    required: true
  },
  taxRate: {
    type: Number,
    default: 0
  },
  taxAmount: {
    type: Number,
    default: 0
  },
  accountId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account'
  }
});

const InvoiceSchema = new mongoose.Schema({
  clientId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true,
    index: true
  },
  invoiceType: {
    type: String,
    enum: ['ar', 'ap'], // AR = Customer Invoice, AP = Vendor Bill
    required: true,
    index: true
  },
  invoiceNumber: {
    type: String,
    required: true,
    trim: true,
    index: true
  },
  reference: {
    type: String,
    trim: true
  },
  issueDate: {
    type: Date,
    required: true,
    index: true
  },
  dueDate: {
    type: Date,
    required: true,
    index: true
  },
  // For AR invoices (customer)
  customerId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Customer',
    index: true
  },
  // For AP invoices (vendor bills)
  vendorId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vendor',
    index: true
  },
  items: [InvoiceLineItemSchema],
  subtotal: {
    type: Number,
    required: true
  },
  taxTotal: {
    type: Number,
    default: 0
  },
  total: {
    type: Number,
    required: true
  },
  amountPaid: {
    type: Number,
    default: 0
  },
  balanceDue: {
    type: Number,
    default: function() {
      return this.total;
    }
  },
  currency: {
    type: String,
    default: 'USD',
    trim: true
  },
  status: {
    type: String,
    enum: ['draft', 'pending', 'sent', 'partially_paid', 'paid', 'overdue', 'void', 'cancelled'],
    default: 'draft',
    index: true
  },
  paymentTerms: {
    type: String,
    default: 'Net 30',
    trim: true
  },
  notes: {
    type: String,
    trim: true
  },
  memo: {
    type: String,
    trim: true
  },
  // Associated journal entry
  journalEntryId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'JournalEntry'
  },
  payments: [{
    date: { type: Date },
    amount: { type: Number },
    paymentMethod: { type: String },
    reference: { type: String },
    notes: { type: String }
  }],
  tags: [String],
  documents: [{
    fileId: { 
      type: mongoose.Schema.Types.ObjectId, 
      ref: 'File' 
    },
    fileName: { type: String },
    uploadDate: { type: Date, default: Date.now }
  }]
}, {
  timestamps: true
});

// Compound indexes
InvoiceSchema.index({ clientId: 1, entityId: 1, invoiceType: 1, status: 1 });
InvoiceSchema.index({ clientId: 1, customerId: 1, status: 1 });
InvoiceSchema.index({ clientId: 1, vendorId: 1, status: 1 });
InvoiceSchema.index({ dueDate: 1, status: 1 });

// Methods
InvoiceSchema.methods.addPayment = function(paymentData) {
  this.payments.push(paymentData);
  this.amountPaid += paymentData.amount;
  this.balanceDue = Math.max(0, this.total - this.amountPaid);
  
  // Update status based on payment
  if (this.balanceDue === 0) {
    this.status = 'paid';
  } else if (this.amountPaid > 0) {
    this.status = 'partially_paid';
  }
  
  return this;
};

// Update status based on due date
InvoiceSchema.methods.updateStatus = function() {
  if (this.status === 'paid' || this.status === 'void' || this.status === 'cancelled') {
    return this;
  }
  
  const today = new Date();
  if (this.dueDate < today && this.balanceDue > 0) {
    this.status = 'overdue';
  }
  
  return this;
};

module.exports = mongoose.model('Invoice', InvoiceSchema);



================================================
File: server/models/journalEntry.js
================================================
// models/journalEntry.js
const mongoose = require('mongoose');

const JournalEntrySchema = new mongoose.Schema({
  clientId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true,
    index: true
  },
  entryNumber: {
    type: String,
    index: true
  },
  date: { 
    type: Date, 
    required: true,
    index: true
  },
  postingDate: {
    type: Date,
    default: Date.now,
    index: true
  },
  transactionNo: {
    type: String,
    index: true
  },
  description: String,
  totalAmount: {
    type: Number,
    required: true
  },
  status: {
    type: String,
    enum: ['draft', 'posted', 'reversed'],
    default: 'posted',
    index: true
  },
  reversalOf: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'JournalEntry',
    default: null
  },
  reversedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'JournalEntry',
    default: null
  },
  createdBy: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User' 
  },
  approvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  approvalDate: Date,
  subledgerType: {
    type: String,
    index: true
  },
  journalType: {
    type: String,
    index: true
  },
  isIntercompany: {
    type: Boolean,
    default: false,
    index: true
  },
  relatedEntityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    index: true
  },
  eliminationReference: {
    type: String,
    index: true
  },
  currency: {
    type: String,
    default: 'USD'
  },
  exchangeRate: {
    type: Number,
    default: 1
  },
  consolidationId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Consolidation'
    // Removed index: true here to avoid duplicate
  },
  recurring: {
    isRecurring: {
      type: Boolean,
      default: false
    },
    frequency: {
      type: String,
      enum: ['daily', 'weekly', 'monthly', 'quarterly', 'annually', null],
      default: null
    },
    nextDate: Date,
    endDate: Date
  },
  period: {
    year: {
      type: Number,
      index: true
    },
    month: {
      type: Number,
      index: true
    },
    quarter: {
      type: Number,
      index: true
    }
  },
  isManual: { 
    type: Boolean, 
    default: true 
  },
  metadata: {
    type: mongoose.Schema.Types.Mixed, // Changed from Object to Mixed
    default: {}
  },
  attachments: [{
    fileId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'File'
    },
    fileName: String,
    uploadDate: Date
  }],
  auditTrail: [{
    action: String,
    performedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    details: mongoose.Schema.Types.Mixed // Changed from Object to Mixed
  }]
}, {
  timestamps: true
});

// Create compound indexes for performance
JournalEntrySchema.index({ clientId: 1, entityId: 1, date: -1 });
JournalEntrySchema.index({ clientId: 1, entityId: 1, 'period.year': 1, 'period.month': 1 });
JournalEntrySchema.index({ clientId: 1, entityId: 1, subledgerType: 1, date: -1 });
JournalEntrySchema.index({ clientId: 1, isIntercompany: 1, relatedEntityId: 1 });
JournalEntrySchema.index({ consolidationId: 1 });

module.exports = mongoose.model('JournalEntry', JournalEntrySchema);



================================================
File: server/models/payrollEntry.js
================================================
const mongoose = require('mongoose');

const PayrollEntrySchema = new mongoose.Schema({
  clientId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  employeeId: String,
  date: { type: Date, required: true },
  amount: { type: Number, required: true },
  type: { type: String, enum: ['salary', 'bonus', 'deduction'], required: true },
  status: String,
  subledgerType: String,
  isManual: { type: Boolean, default: true }
});

module.exports = mongoose.model('PayrollEntry', PayrollEntrySchema);



================================================
File: server/models/report.js
================================================
// models/report.js
const ReportSchema = new mongoose.Schema({
  clientId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  entityId: { type: mongoose.Schema.Types.ObjectId, ref: 'Entity', required: true },
  name: { type: String, required: true },
  type: { type: String, enum: ['standard', 'custom'], default: 'standard' },
  reportType: { type: String, enum: ['balance-sheet', 'income-statement', 'cash-flow', 'custom'], required: true },
  customDefinition: {
    fields: [String],
    filters: Object,
    groupBy: [String],
    calculations: [Object]
  },
  layout: Object,
  lastGenerated: Date,
  schedule: {
    isScheduled: { type: Boolean, default: false },
    frequency: { type: String, enum: ['daily', 'weekly', 'monthly', 'quarterly'] },
    nextRun: Date
  }
});



================================================
File: server/models/transaction.js
================================================
// models/transaction.js
const mongoose = require('mongoose');

const TransactionSchema = new mongoose.Schema({
  clientId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true,
    index: true
  },
  accountId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Account', 
    required: true,
    index: true
  },
  journalEntryId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'JournalEntry',
    required: true,
    index: true
  },
  date: { 
    type: Date, 
    required: true,
    index: true
  },
  postingDate: {
    type: Date,
    default: Date.now,
    index: true
  },
  transactionNo: {
    type: String,
    index: true
  },
  lineNo: Number,
  documentNumber: {
    type: String,
    index: true
  },
  description: String,
  amount: { 
    type: Number, 
    required: true 
  },
  type: { 
    type: String, 
    enum: ['debit', 'credit'], 
    required: true 
  },
  category: String,
  subledgerType: {
    type: String,
    index: true
  },
  journalType: String,
  vendorId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vendor',
    index: true
  },
  vendorName: String,
  customerId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Customer',
    index: true
  },
  employeeId: {
    type: String,
    index: true
  },
  projectId: {
    type: String,
    index: true
  },
  departmentId: {
    type: String,
    index: true
  },
  isIntercompany: {
    type: Boolean,
    default: false,
    index: true
  },
  relatedEntityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    index: true
  },
  eliminationReference: {
    type: String,
    index: true
  },
  currency: {
    type: String,
    default: 'USD'
  },
  exchangeRate: {
    type: Number,
    default: 1
  },
  originalAmount: {
    type: Number
  },
  originalCurrency: {
    type: String
  },
  isReconciled: {
    type: Boolean,
    default: false,
    index: true
  },
  reconciledDate: Date,
  reconciledBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  isManual: { 
    type: Boolean, 
    default: true 
  },
  consolidationId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Consolidation'
    // Removed index: true here to avoid duplicate
  },
  metadata: {
    type: mongoose.Schema.Types.Mixed, // Changed from Object to Mixed
    default: {}
  },
  attachments: [{
    fileId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'File'
    },
    fileName: String,
    uploadDate: Date
  }],
  auditTrail: [{
    action: String,
    performedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    details: mongoose.Schema.Types.Mixed // Changed from Object to Mixed
  }]
}, {
  timestamps: true
});

// Create compound indexes for performance
TransactionSchema.index({ clientId: 1, entityId: 1, date: -1 });
TransactionSchema.index({ clientId: 1, entityId: 1, accountId: 1, date: -1 });
TransactionSchema.index({ clientId: 1, entityId: 1, subledgerType: 1, date: -1 });
TransactionSchema.index({ clientId: 1, isIntercompany: 1, relatedEntityId: 1 });
TransactionSchema.index({ consolidationId: 1 });

module.exports = mongoose.model('Transaction', TransactionSchema);



================================================
File: server/models/user.js
================================================
// models/user.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

/**
 * User Schema
 * Includes fields for email, password, admin status, and account security
 */
const UserSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Please provide a valid email address']
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters long'],
    select: false // Don't include password in queries by default
  },
  isAdmin: {
    type: Boolean,
    default: false
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  lastLogin: {
    type: Date
  },
  resetPasswordToken: String,
  resetPasswordExpire: Date,
  loginAttempts: {
    type: Number,
    default: 0
  },
  lockUntil: {
    type: Date
  },
  active: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

/**
 * Pre-save middleware to hash password
 */
UserSchema.pre('save', async function(next) {
  // Only hash the password if it's modified (or new)
  if (!this.isModified('password')) {
    return next();
  }

  try {
    // Generate salt
    const salt = await bcrypt.genSalt(10);
    
    // Hash password with salt
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

/**
 * Method to compare passwords
 * @param {string} candidatePassword - The password to compare
 * @returns {boolean} - Whether the password matches
 */
UserSchema.methods.comparePassword = async function(candidatePassword) {
  try {
    // Check if candidate password is provided
    if (!candidatePassword) {
      throw new Error('Password is required for comparison');
    }

    // Check if this.password exists
    if (!this.password) {
      // We need to fetch the password from the database since it might not be included
      const user = await mongoose.model('User').findById(this._id).select('+password');
      if (!user || !user.password) {
        throw new Error('User password not found in database');
      }
      // Use bcrypt to compare the provided password with the stored hash
      return await bcrypt.compare(candidatePassword, user.password);
    }
    
    // Use bcrypt to compare the provided password with the stored hash
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    console.error('Password comparison error:', error);
    throw error;
  }
};

/**
 * Method to generate and hash password reset token
 * @returns {string} - The password reset token
 */
UserSchema.methods.getResetPasswordToken = function() {
  // Generate token
  const resetToken = crypto.randomBytes(20).toString('hex');

  // Hash token and set to resetPasswordToken field
  this.resetPasswordToken = crypto
    .createHash('sha256')
    .update(resetToken)
    .digest('hex');

  // Set expire (10 minutes)
  this.resetPasswordExpire = Date.now() + 10 * 60 * 1000;

  return resetToken;
};

/**
 * Method to handle failed login attempts and account locking
 * Increments loginAttempts and locks account after 5 consecutive failed attempts
 */
UserSchema.methods.failedLogin = async function() {
  // Increment login attempts
  this.loginAttempts += 1;
  
  // Lock account if more than 5 consecutive failed attempts
  if (this.loginAttempts >= 5) {
    // Lock for 30 minutes
    this.lockUntil = Date.now() + 30 * 60 * 1000;
  }
  
  await this.save();
};

/**
 * Method to reset login attempts after successful login
 */
UserSchema.methods.successfulLogin = async function() {
  // Reset login attempts and lock
  this.loginAttempts = 0;
  this.lockUntil = undefined;
  this.lastLogin = Date.now();
  
  await this.save();
};

/**
 * Method to check if account is locked
 * @returns {boolean} - Whether the account is currently locked
 */
UserSchema.methods.isLocked = function() {
  // Check if account is locked
  return this.lockUntil && this.lockUntil > Date.now();
};

// Virtual to check if account is locked
UserSchema.virtual('locked').get(function() {
  return this.isLocked();
});

// Create User model from schema
const User = mongoose.model('User', UserSchema);

module.exports = User;



================================================
File: server/models/vendor.js
================================================
// models/vendor.js
const mongoose = require('mongoose');

const VendorSchema = new mongoose.Schema({
  clientId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true,
    index: true
  },
  entityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Entity',
    required: true,
    index: true
  },
  name: {
    type: String,
    required: true,
    trim: true,
    index: true
  },
  vendorId: {
    type: String,
    trim: true,
    index: true
  },
  email: {
    type: String,
    trim: true,
    lowercase: true
  },
  phone: {
    type: String,
    trim: true
  },
  website: {
    type: String,
    trim: true
  },
  taxId: {
    type: String,
    trim: true
  },
  address: {
    street: { type: String, trim: true },
    city: { type: String, trim: true },
    state: { type: String, trim: true },
    zip: { type: String, trim: true },
    country: { type: String, trim: true, default: 'USA' }
  },
  remitToAddress: {
    street: { type: String, trim: true },
    city: { type: String, trim: true },
    state: { type: String, trim: true },
    zip: { type: String, trim: true },
    country: { type: String, trim: true, default: 'USA' }
  },
  contactPerson: {
    name: { type: String, trim: true },
    email: { type: String, trim: true, lowercase: true },
    phone: { type: String, trim: true },
    position: { type: String, trim: true }
  },
  paymentTerms: {
    type: String,
    default: 'Net 30',
    trim: true
  },
  currentBalance: {
    type: Number,
    default: 0
  },
  currency: {
    type: String,
    default: 'USD',
    trim: true
  },
  preferredPaymentMethod: {
    type: String,
    enum: ['check', 'ach', 'wire', 'credit_card', 'other'],
    default: 'check'
  },
  bankInfo: {
    bankName: { type: String, trim: true },
    accountNumber: { type: String, trim: true },
    routingNumber: { type: String, trim: true },
    accountType: { type: String, enum: ['checking', 'savings'], default: 'checking' }
  },
  taxForm: {
    type: String,
    enum: ['W-9', 'W-8BEN', 'W-8BEN-E', 'other', 'none'],
    default: 'none'
  },
  taxFormReceived: {
    type: Boolean,
    default: false
  },
  category: {
    type: String,
    trim: true
  },
  notes: {
    type: String,
    trim: true
  },
  status: {
    type: String,
    enum: ['active', 'inactive', 'on_hold'],
    default: 'active'
  },
  defaultGLAccount: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account'
  },
  defaultExpenseAccount: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Account'
  },
  paymentSchedule: {
    frequency: { 
      type: String, 
      enum: ['weekly', 'biweekly', 'monthly', 'as_needed'], 
      default: 'as_needed' 
    },
    dayOfWeek: { type: Number }, // 0 = Sunday, 6 = Saturday
    dayOfMonth: { type: Number }
  },
  1099Eligible: {
    type: Boolean,
    default: false
  },
  vendorSince: {
    type: Date,
    default: Date.now
  },
  lastBillDate: {
    type: Date
  },
  lastPaymentDate: {
    type: Date
  },
  lastPaymentAmount: {
    type: Number
  },
  earlyPaymentDiscount: {
    available: { type: Boolean, default: false },
    percentage: { type: Number, default: 0 },
    days: { type: Number, default: 10 }
  },
  creditScore: {
    type: Number
  },
  tags: [String],
  metadata: {
    type: Object,
    default: {}
  },
  documents: [{
    fileId: { 
      type: mongoose.Schema.Types.ObjectId, 
      ref: 'File' 
    },
    fileName: { type: String },
    documentType: { type: String },
    uploadDate: { type: Date, default: Date.now }
  }]
}, {
  timestamps: true
});

// Create compound indexes for better query performance
VendorSchema.index({ clientId: 1, entityId: 1, name: 1 });
VendorSchema.index({ clientId: 1, entityId: 1, status: 1 });
VendorSchema.index({ clientId: 1, entityId: 1, category: 1 });

// Virtual for getting total outstanding bills (to be populated by application logic)
VendorSchema.virtual('outstandingBills').get(function() {
  // This would typically be calculated on demand by querying related bills
  return this.currentBalance;
});

// Check if vendor has early payment discount
VendorSchema.methods.hasEarlyPaymentDiscount = function() {
  return this.earlyPaymentDiscount.available && 
         this.earlyPaymentDiscount.percentage > 0 && 
         this.earlyPaymentDiscount.days > 0;
};

// Calculate discount amount for a specific bill amount
VendorSchema.methods.calculateEarlyPaymentDiscount = function(billAmount) {
  if (!this.hasEarlyPaymentDiscount()) return 0;
  return billAmount * (this.earlyPaymentDiscount.percentage / 100);
};

module.exports = mongoose.model('Vendor', VendorSchema);



================================================
File: server/routes/accounting.js
================================================
// routes/accounting.js
const express = require('express');
const { body, param, query, validationResult } = require('express-validator');
const router = express.Router();
const JournalEntry = require('../models/journalEntry');
const Transaction = require('../models/transaction');
const Account = require('../models/account');
const Entity = require('../models/entity');
const AuditLog = require('../models/auditLog');
const File = require('../models/file');
const { auth } = require('../middleware/auth');

// Journal entry validation middleware
const journalEntryValidation = [
 body('date')
   .isDate()
   .withMessage('Valid date is required'),
 body('entityId')
   .isMongoId()
   .withMessage('Valid entity ID is required'),
 body('description')
   .notEmpty()
   .withMessage('Description is required')
   .trim(),
 body('entries')
   .isArray({ min: 1 })
   .withMessage('At least one entry is required'),
 body('entries.*.accountId')
   .isMongoId()
   .withMessage('Valid account ID is required'),
 body('entries.*.amount')
   .isFloat({ gt: 0 })
   .withMessage('Amount must be greater than zero'),
 body('entries.*.type')
   .isIn(['debit', 'credit'])
   .withMessage('Type must be either debit or credit')
];

// Get entities validation
const getEntitiesValidation = [
 query('active')
   .optional()
   .isBoolean()
   .withMessage('Active must be a boolean')
];

// Get accounts validation
const getAccountsValidation = [
 query('entityId')
   .isMongoId()
   .withMessage('Valid entity ID is required'),
 query('type')
   .optional()
   .isString()
   .withMessage('Account type must be a string'),
 query('subledger')
   .optional()
   .isString()
   .withMessage('Subledger type must be a string'),
 query('active')
   .optional()
   .isBoolean()
   .withMessage('Active must be a boolean')
];

// Get journal entries validation
const getJournalEntriesValidation = [
 query('entityId')
   .isMongoId()
   .withMessage('Valid entity ID is required'),
 query('startDate')
   .optional()
   .isDate()
   .withMessage('Start date must be a valid date'),
 query('endDate')
   .optional()
   .isDate()
   .withMessage('End date must be a valid date'),
 query('accountId')
   .optional()
   .isMongoId()
   .withMessage('Account ID must be valid'),
 query('status')
   .optional()
   .isIn(['draft', 'posted', 'reversed'])
   .withMessage('Status must be draft, posted, or reversed'),
 query('limit')
   .optional()
   .isInt({ min: 1, max: 100 })
   .withMessage('Limit must be between 1 and 100'),
 query('page')
   .optional()
   .isInt({ min: 1 })
   .withMessage('Page must be a positive integer')
];

// Delete journal entry validation
const deleteJournalEntryValidation = [
 param('id')
   .isMongoId()
   .withMessage('Invalid journal entry ID format')
];

// Get entities
router.get('/entities', auth, getEntitiesValidation, async (req, res, next) => {
 // Check for validation errors
 const errors = validationResult(req);
 if (!errors.isEmpty()) {
   return res.status(400).json({ 
     success: false,
     message: 'Validation failed', 
     errors: errors.array() 
   });
 }
 
 try {
   const { active } = req.query;
   const query = { clientId: req.user.id };
   
   if (active !== undefined) {
     query.isActive = active === 'true';
   }
   
   const entities = await Entity.find(query).sort({ name: 1 });
   
   res.json({
     success: true,
     entities: entities.map(entity => ({
       id: entity._id,
       name: entity.name,
       code: entity.code,
       type: entity.type,
       currency: entity.currency,
       isActive: entity.isActive,
       parentEntityId: entity.parentEntityId
     }))
   });
 } catch (error) {
   console.error('Error fetching entities:', error);
   next(error);
 }
});

// Create entity
router.post('/entities', auth, async (req, res, next) => {
 try {
   const { name, code, type, currency, parentEntityId } = req.body;
   
   // Check if entity code already exists
   const existingEntity = await Entity.findOne({ 
     clientId: req.user.id, 
     code: code 
   });
   
   if (existingEntity) {
     return res.status(400).json({
       success: false,
       message: `Entity with code ${code} already exists`
     });
   }
   
   const entity = new Entity({
     clientId: req.user.id,
     name,
     code,
     type: type || 'Operating',
     currency: currency || 'USD',
     parentEntityId: parentEntityId || null
   });
   
   await entity.save();
   
   // Create audit log
   const auditLog = new AuditLog({
     clientId: req.user.id,
     action: 'CREATE_ENTITY',
     entityType: 'Entity',
     entityId: entity._id,
     userId: req.user.id,
     details: { name, code, type }
   });
   await auditLog.save();
   
   res.status(201).json({
     success: true,
     message: 'Entity created successfully',
     entity: {
       id: entity._id,
       name: entity.name,
       code: entity.code,
       type: entity.type,
       currency: entity.currency,
       isActive: entity.isActive,
       parentEntityId: entity.parentEntityId
     }
   });
 } catch (error) {
   console.error('Error creating entity:', error);
   next(error);
 }
});

// Get accounts
router.get('/accounts', auth, getAccountsValidation, async (req, res, next) => {
 // Check for validation errors
 const errors = validationResult(req);
 if (!errors.isEmpty()) {
   return res.status(400).json({ 
     success: false,
     message: 'Validation failed', 
     errors: errors.array() 
   });
 }
 
 try {
   const { entityId, type, subledger, active } = req.query;
   const query = { 
     clientId: req.user.id,
     entityId
   };
   
   if (type) {
     query.accountType = type;
   }
   
   if (subledger) {
     query.subledgerType = subledger;
   }
   
   if (active !== undefined) {
     query.isActive = active === 'true';
   }
   
   const accounts = await Account.find(query).sort({ accountNumber: 1 });
   
   res.json({
     success: true,
     accounts: accounts.map(account => ({
       id: account._id,
       accountNumber: account.accountNumber,
       accountName: account.accountName,
       accountType: account.accountType,
       subledgerType: account.subledgerType,
       isIntercompany: account.isIntercompany,
       currency: account.currency,
       balance: account.balance,
       isActive: account.isActive
     }))
   });
 } catch (error) {
   console.error('Error fetching accounts:', error);
   next(error);
 }
});

// Create account
router.post('/accounts', auth, async (req, res, next) => {
 try {
   const { 
     entityId, 
     accountNumber, 
     accountName, 
     accountType, 
     subledgerType, 
     description,
     isIntercompany,
     currency
   } = req.body;
   
   // Check if entity exists
   const entity = await Entity.findOne({ 
     _id: entityId,
     clientId: req.user.id
   });
   
   if (!entity) {
     return res.status(404).json({
       success: false,
       message: 'Entity not found'
     });
   }
   
   // Check if account already exists
   const existingAccount = await Account.findOne({ 
     clientId: req.user.id,
     entityId,
     accountNumber
   });
   
   if (existingAccount) {
     return res.status(400).json({
       success: false,
       message: `Account with number ${accountNumber} already exists for this entity`
     });
   }
   
   const account = new Account({
     clientId: req.user.id,
     entityId,
     accountNumber,
     accountName,
     accountType,
     subledgerType: subledgerType || 'GL',
     description,
     isIntercompany: isIntercompany || false,
     currency: currency || entity.currency
   });
   
   await account.save();
   
   // Create audit log
   const auditLog = new AuditLog({
     clientId: req.user.id,
     action: 'CREATE_ACCOUNT',
     entityType: 'Account',
     entityId: account._id,
     userId: req.user.id,
     details: { accountNumber, accountName, accountType }
   });
   await auditLog.save();
   
   res.status(201).json({
     success: true,
     message: 'Account created successfully',
     account: {
       id: account._id,
       accountNumber: account.accountNumber,
       accountName: account.accountName,
       accountType: account.accountType,
       subledgerType: account.subledgerType,
       isIntercompany: account.isIntercompany,
       currency: account.currency
     }
   });
 } catch (error) {
   console.error('Error creating account:', error);
   next(error);
 }
});

// Get journal entries
router.get('/journal-entries', auth, getJournalEntriesValidation, async (req, res, next) => {
 // Check for validation errors
 const errors = validationResult(req);
 if (!errors.isEmpty()) {
   return res.status(400).json({ 
     success: false,
     message: 'Validation failed', 
     errors: errors.array() 
   });
 }
 
 try {
   const { 
     entityId, 
     startDate, 
     endDate, 
     accountId, 
     status, 
     limit = 50, 
     page = 1 
   } = req.query;
   
   const skip = (parseInt(page) - 1) * parseInt(limit);
   
   // Build query filters
   const query = { 
     clientId: req.user.id,
     entityId
   };
   
   if (startDate || endDate) {
     query.date = {};
     if (startDate) query.date.$gte = new Date(startDate);
     if (endDate) query.date.$lte = new Date(endDate);
   }
   
   if (status) {
     query.status = status;
   }
   
   // If accountId is provided, find corresponding transactions
   if (accountId) {
     const transactionIds = await Transaction.find({
       clientId: req.user.id,
       entityId,
       accountId
     }).distinct('journalEntryId');
     
     query._id = { $in: transactionIds };
   }
   
   // Execute query with pagination
   const totalCount = await JournalEntry.countDocuments(query);
   const entries = await JournalEntry.find(query)
     .sort({ date: -1, _id: -1 })
     .limit(parseInt(limit))
     .skip(skip)
     .populate('entityId', 'name code')
     .lean();
   
   // Get transactions for these journal entries
   const journalEntryIds = entries.map(entry => entry._id);
   const transactions = await Transaction.find({
     clientId: req.user.id,
     journalEntryId: { $in: journalEntryIds }
   }).populate('accountId', 'accountNumber accountName')
     .lean();
   
   // Group transactions by journal entry
   const transactionsByEntry = {};
   transactions.forEach(transaction => {
     const journalId = transaction.journalEntryId.toString();
     if (!transactionsByEntry[journalId]) {
       transactionsByEntry[journalId] = [];
     }
     transactionsByEntry[journalId].push(transaction);
   });
   
   // Format response
   const formattedEntries = entries.map(entry => ({
     id: entry._id,
     entryNumber: entry.entryNumber,
     date: entry.date,
     entity: entry.entityId ? {
       id: entry.entityId._id,
       name: entry.entityId.name,
       code: entry.entityId.code
     } : null,
     description: entry.description,
     totalAmount: entry.totalAmount,
     status: entry.status,
     isIntercompany: entry.isIntercompany,
     transactions: (transactionsByEntry[entry._id.toString()] || []).map(t => ({
       id: t._id,
       account: t.accountId ? {
         id: t.accountId._id,
         number: t.accountId.accountNumber,
         name: t.accountId.accountName
       } : null,
       amount: t.amount,
       type: t.type,
       description: t.description
     }))
   }));
   
   res.json({
     success: true,
     entries: formattedEntries,
     pagination: {
       total: totalCount,
       page: parseInt(page),
       limit: parseInt(limit),
       pages: Math.ceil(totalCount / parseInt(limit))
     }
   });
 } catch (error) {
   console.error('Error fetching journal entries:', error);
   next(error);
 }
});

// Create journal entry
router.post('/journal-entry', auth, journalEntryValidation, async (req, res, next) => {
 // Check for validation errors
 const errors = validationResult(req);
 if (!errors.isEmpty()) {
   return res.status(400).json({ 
     success: false,
     message: 'Validation failed', 
     errors: errors.array() 
   });
 }

 const { entityId, date, description, entries, attachments } = req.body;
 const session = await mongoose.startSession();
 
 try {
   session.startTransaction();
   
   // Verify entity exists and belongs to client
   const entity = await Entity.findOne({
     _id: entityId,
     clientId: req.user.id
   }).session(session);
   
   if (!entity) {
     return res.status(404).json({
       success: false,
       message: 'Entity not found or you do not have permission'
     });
   }
   
   // Calculate totals
   let totalDebits = 0;
   let totalCredits = 0;
   
   for (const entry of entries) {
     const amount = parseFloat(entry.amount);
     if (entry.type === 'debit') {
       totalDebits += amount;
     } else {
       totalCredits += amount;
     }
   }
   
   // Verify balanced entry
   if (Math.abs(totalDebits - totalCredits) > 0.01) {
     return res.status(400).json({
       success: false,
       message: 'Journal entries must be balanced',
       details: {
         totalDebits,
         totalCredits,
         difference: totalDebits - totalCredits
       }
     });
   }
   
   // Generate entry number (YYYY-MM-XXXXX)
   const entryDate = new Date(date);
   const year = entryDate.getFullYear();
   const month = String(entryDate.getMonth() + 1).padStart(2, '0');
   
   // Get count of entries this month for sequential numbering
   const entryCount = await JournalEntry.countDocuments({
     clientId: req.user.id,
     entityId,
     'period.year': year,
     'period.month': entryDate.getMonth() + 1
   }).session(session);
   
   const entryNumber = `${year}-${month}-${String(entryCount + 1).padStart(5, '0')}`;
   
   // Create journal entry
   const journalEntry = new JournalEntry({
     clientId: req.user.id,
     entityId,
     entryNumber,
     date: entryDate,
     description,
     totalAmount: totalDebits,
     status: 'posted',
     createdBy: req.user.id,
     currency: entity.currency,
     period: {
       year,
       month: entryDate.getMonth() + 1,
       quarter: Math.floor(entryDate.getMonth() / 3) + 1
     },
     isManual: true,
     attachments: []
   });
   
   // Handle attachments
   if (attachments && Array.isArray(attachments)) {
     for (const attachmentId of attachments) {
       const file = await File.findOne({
         _id: attachmentId,
         userId: req.user.id
       }).session(session);
       
       if (file) {
         journalEntry.attachments.push({
           fileId: file._id,
           fileName: file.fileName,
           uploadDate: file.createdAt
         });
       }
     }
   }
   
   await journalEntry.save({ session });
   
   // Create transactions for each entry
   const transactions = [];
   for (const entry of entries) {
     // Verify account exists and belongs to client
     const account = await Account.findOne({
       _id: entry.accountId,
       clientId: req.user.id,
       entityId
     }).session(session);
     
     if (!account) {
       throw new Error(`Account ${entry.accountId} not found or does not belong to this entity`);
     }
     
     const transaction = new Transaction({
       clientId: req.user.id,
       entityId,
       accountId: entry.accountId,
       journalEntryId: journalEntry._id,
       date: entryDate,
       description: entry.description || description,
       amount: parseFloat(entry.amount),
       type: entry.type,
       transactionNo: entryNumber,
       lineNo: entry.lineNo || transactions.length + 1,
       documentNumber: entry.documentNumber,
       subledgerType: account.subledgerType,
       currency: entity.currency,
       isManual: true
     });
     
     transactions.push(transaction);
     
     // Update account balance
     const updateAmount = parseFloat(entry.amount);
     let balanceChange = 0;
     
     if (['Asset', 'Expense'].includes(account.accountType)) {
       // Debit increases, credit decreases
       balanceChange = entry.type === 'debit' ? updateAmount : -updateAmount;
     } else {
       // Credit increases, debit decreases
       balanceChange = entry.type === 'credit' ? updateAmount : -updateAmount;
     }
     
     await Account.findByIdAndUpdate(
       account._id,
       { 
         $inc: { balance: balanceChange },
         $set: { lastUpdated: new Date() }
       },
       { session }
     );
   }
   
   await Transaction.insertMany(transactions, { session });
   
   // Create audit log
   const auditLog = new AuditLog({
     clientId: req.user.id,
     action: 'CREATE_JOURNAL_ENTRY',
     entityType: 'JournalEntry',
     entityId: journalEntry._id,
     userId: req.user.id,
     details: { 
       entryNumber, 
       entityId, 
       date, 
       totalAmount: totalDebits,
       transactionCount: transactions.length
     }
   });
   await auditLog.save({ session });
   
   await session.commitTransaction();
   
   res.status(201).json({
     success: true,
     message: 'Journal entry created successfully',
     journalEntry: {
       id: journalEntry._id,
       entryNumber: journalEntry.entryNumber,
       date: journalEntry.date,
       description: journalEntry.description,
       totalAmount: journalEntry.totalAmount,
       transactions: transactions.map(t => ({
         id: t._id,
         accountId: t.accountId,
         amount: t.amount,
         type: t.type
       }))
     }
   });
 } catch (error) {
   await session.abortTransaction();
   console.error('Error creating journal entry:', error);
   
   if (error.message && error.message.includes('Account')) {
     return res.status(400).json({
       success: false,
       message: error.message
     });
   }
   
   next(error);
 } finally {
   session.endSession();
 }
});

// Get Trial Balance endpoint
router.get('/trial-balance', auth, async (req, res, next) => {
 try {
   const { entityId, startDate, endDate, level = 'detail' } = req.query;
   
   if (!entityId) {
     return res.status(400).json({ 
       success: false,
       message: 'Entity ID is required'
     });
   }

   // Validate date parameters
   const parsedStartDate = startDate ? new Date(startDate) : new Date(new Date().getFullYear(), 0, 1);
   const parsedEndDate = endDate ? new Date(endDate) : new Date();
   
   // Define account aggregation for Trial Balance
   const accounts = await Account.find({
     clientId: req.user.id,
     entityId: entityId,
     isActive: true
   }).sort({ accountNumber: 1 });
   
   // Get transactions for the period
   const transactions = await Transaction.find({
     clientId: req.user.id,
     entityId: entityId,
     date: { $gte: parsedStartDate, $lte: parsedEndDate }
   });
   
   // Calculate balances for each account
   const trialBalance = accounts.map(account => {
     const accountTransactions = transactions.filter(t => 
       t.accountId.toString() === account._id.toString()
     );
     
     const debits = accountTransactions
       .filter(t => t.type === 'debit')
       .reduce((sum, t) => sum + t.amount, 0);
       
     const credits = accountTransactions
       .filter(t => t.type === 'credit')
       .reduce((sum, t) => sum + t.amount, 0);
     
     // Calculate balance based on account type
     let balance = 0;
     if (['Asset', 'Expense'].includes(account.accountType)) {
       balance = debits - credits;
     } else {
       balance = credits - debits;
     }
     
     return {
       id: account._id,
       accountNumber: account.accountNumber,
       accountName: account.accountName,
       accountType: account.accountType,
       debits,
       credits,
       balance
     };
   });
   
   // Summarize at parent account level if requested
   let result = trialBalance;
   if (level === 'summary') {
     // Group by first 2 digits of account number and summarize
     const summaryMap = {};
     trialBalance.forEach(account => {
       const prefix = account.accountNumber.substring(0, 2);
       if (!summaryMap[prefix]) {
         summaryMap[prefix] = {
           accountNumber: `${prefix}XX`,
           accountName: `${account.accountType} Summary (${prefix}XX)`,
           accountType: account.accountType,
           debits: 0,
           credits: 0,
           balance: 0
         };
       }
       summaryMap[prefix].debits += account.debits;
       summaryMap[prefix].credits += account.credits;
       summaryMap[prefix].balance += account.balance;
     });
     result = Object.values(summaryMap);
   }
   
   // Calculate totals
   const totals = {
     debits: result.reduce((sum, acc) => sum + acc.debits, 0),
     credits: result.reduce((sum, acc) => sum + acc.credits, 0),
     netIncome: result
       .filter(acc => ['Revenue', 'Expense'].includes(acc.accountType))
       .reduce((sum, acc) => sum + acc.balance, 0)
   };
   
   res.json({
     success: true,
     trialBalance: result,
     totals,
     period: {
       startDate: parsedStartDate,
       endDate: parsedEndDate
     },
     entityId
   });
 } catch (error) {
   console.error('Trial Balance error:', error);
   next(error);
 }
});

// Get Balance Sheet endpoint
router.get('/balance-sheet', auth, async (req, res, next) => {
 try {
   const { entityId, asOfDate } = req.query;
   
   if (!entityId) {
     return res.status(400).json({ 
       success: false,
       message: 'Entity ID is required'
     });
   }

   const parsedAsOfDate = asOfDate ? new Date(asOfDate) : new Date();
   
   // Get all accounts
   const accounts = await Account.find({
     clientId: req.user.id,
     entityId: entityId,
     isActive: true,
     accountType: { $in: ['Asset', 'Liability', 'Equity'] }
   }).sort({ accountNumber: 1 });
   
   // Get all transactions up to the as-of date
   const transactions = await Transaction.find({
     clientId: req.user.id,
     entityId: entityId,
     date: { $lte: parsedAsOfDate }
   });
   
   // Calculate balances for each account
   const balanceSheetAccounts = accounts.map(account => {
     const accountTransactions = transactions.filter(t => 
       t.accountId.toString() === account._id.toString()
     );
     
     const debits = accountTransactions
       .filter(t => t.type === 'debit')
       .reduce((sum, t) => sum + t.amount, 0);
       
     const credits = accountTransactions
       .filter(t => t.type === 'credit')
       .reduce((sum, t) => sum + t.amount, 0);
     
     // Calculate balance based on account type
     let balance = 0;
     if (account.accountType === 'Asset') {
       balance = debits - credits;
     } else {
       balance = credits - debits;
     }
     
     return {
       id: account._id,
       accountNumber: account.accountNumber,
       accountName: account.accountName,
       accountType: account.accountType,
       balance
     };
   });
   
   // Organize by type and calculate totals
   const assets = balanceSheetAccounts.filter(a => a.accountType === 'Asset');
   const liabilities = balanceSheetAccounts.filter(a => a.accountType === 'Liability');
   const equity = balanceSheetAccounts.filter(a => a.accountType === 'Equity');
   
   const totalAssets = assets.reduce((sum, account) => sum + account.balance, 0);
   const totalLiabilities = liabilities.reduce((sum, account) => sum + account.balance, 0);
   const totalEquity = equity.reduce((sum, account) => sum + account.balance, 0);
   
   // Calculate Year-to-Date Income
   // Get income accounts
   const incomeAccounts = await Account.find({
     clientId: req.user.id,
     entityId: entityId,
     isActive: true,
     accountType: { $in: ['Revenue', 'Expense'] }
   });
   
   // Get current year start date
   const currentYear = parsedAsOfDate.getFullYear();
   const yearStartDate = new Date(currentYear, 0, 1);
   
   // Get income transactions for current year
   const incomeTransactions = await Transaction.find({
     clientId: req.user.id,
     entityId: entityId,
     accountId: { $in: incomeAccounts.map(a => a._id) },
     date: { $gte: yearStartDate, $lte: parsedAsOfDate }
   });
   
   // Calculate net income
   let netIncome = 0;
   incomeAccounts.forEach(account => {
     const accountTransactions = incomeTransactions.filter(t => 
       t.accountId.toString() === account._id.toString()
     );
     
     const debits = accountTransactions
       .filter(t => t.type === 'debit')
       .reduce((sum, t) => sum + t.amount, 0);
       
     const credits = accountTransactions
       .filter(t => t.type === 'credit')
       .reduce((sum, t) => sum + t.amount, 0);
     
     if (account.accountType === 'Revenue') {
       netIncome += (credits - debits);
     } else {
       netIncome -= (debits - credits);
     }
   });
   
   res.json({
     success: true,
     balanceSheet: {
       asOfDate: parsedAsOfDate,
       assets,
       liabilities,
       equity,
       netIncome,
       retainedEarnings: netIncome, // Simplified - would need more logic for real retained earnings
       totals: {
         assets: totalAssets,
         liabilities: totalLiabilities,
         equity: totalEquity + netIncome,
         liabilitiesAndEquity: totalLiabilities + totalEquity + netIncome
       }
     },
     entityId
   });
 } catch (error) {
   console.error('Balance Sheet error:', error);
   next(error);
 }
});

// Get Income Statement endpoint
router.get('/income-statement', auth, async (req, res, next) => {
 try {
   const { entityId, startDate, endDate } = req.query;
   
   if (!entityId) {
     return res.status(400).json({ 
       success: false,
       message: 'Entity ID is required'
     });
   }

   // Validate date parameters
   const parsedStartDate = startDate ? new Date(startDate) : new Date(new Date().getFullYear(), 0, 1);
   const parsedEndDate = endDate ? new Date(endDate) : new Date();
   
   // Get income accounts (Revenue and Expense)
   const accounts = await Account.find({
     clientId: req.user.id,
     entityId: entityId,
     isActive: true,
     accountType: { $in: ['Revenue', 'Expense'] }
   }).sort({ accountNumber: 1 });
   
   // Get transactions for the period
   const transactions = await Transaction.find({
     clientId: req.user.id,
     entityId: entityId,
     date: { $gte: parsedStartDate, $lte: parsedEndDate },
     accountId: { $in: accounts.map(a => a._id) }
   });
   
   // Calculate balances for each account
   const incomeAccounts = accounts.map(account => {
     const accountTransactions = transactions.filter(t => 
       t.accountId.toString() === account._id.toString()
     );
     
     const debits = accountTransactions
       .filter(t => t.type === 'debit')
       .reduce((sum, t) => sum + t.amount, 0);
       
     const credits = accountTransactions
        .filter(t => t.type === 'credit')
        .reduce((sum, t) => sum + t.amount, 0);
      
      // Calculate balance based on account type
      let balance = 0;
      if (account.accountType === 'Revenue') {
        balance = credits - debits;
      } else { // Expense
        balance = debits - credits;
      }
      
      return {
        id: account._id,
        accountNumber: account.accountNumber,
        accountName: account.accountName,
        accountType: account.accountType,
        balance
      };
    });
    
    // Organize by type and calculate totals
    const revenue = incomeAccounts.filter(a => a.accountType === 'Revenue');
    const expenses = incomeAccounts.filter(a => a.accountType === 'Expense');
    
    const totalRevenue = revenue.reduce((sum, account) => sum + account.balance, 0);
    const totalExpenses = expenses.reduce((sum, account) => sum + account.balance, 0);
    const netIncome = totalRevenue - totalExpenses;
    
    res.json({
      success: true,
      incomeStatement: {
        period: {
          startDate: parsedStartDate,
          endDate: parsedEndDate
        },
        revenue,
        expenses,
        totals: {
          revenue: totalRevenue,
          expenses: totalExpenses,
          netIncome
        }
      },
      entityId
    });
  } catch (error) {
    console.error('Income Statement error:', error);
    next(error);
  }
});

// Delete journal entry
router.delete('/journal-entries/:id', auth, deleteJournalEntryValidation, async (req, res, next) => {
  // Check for validation errors
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ 
      success: false,
      message: 'Validation failed', 
      errors: errors.array() 
    });
  }
  
  const session = await mongoose.startSession();
  
  try {
    session.startTransaction();
    
    const journalEntryId = req.params.id;
    
    // First, check if the entry exists and belongs to the user
    const journalEntry = await JournalEntry.findOne({
      _id: journalEntryId,
      clientId: req.user.id,
      status: { $ne: 'reversed' } // Cannot delete already reversed entries
    }).session(session);
    
    if (!journalEntry) {
      return res.status(404).json({ 
        success: false,
        message: 'Journal entry not found or already reversed'
      });
    }
    
    // Get transactions for this journal entry
    const transactions = await Transaction.find({
      journalEntryId: journalEntryId
    }).populate('accountId').session(session);
    
    // Reverse account balances
    for (const transaction of transactions) {
      if (!transaction.accountId) continue;
      
      const account = transaction.accountId;
      const updateAmount = transaction.amount;
      let balanceChange = 0;
      
      if (['Asset', 'Expense'].includes(account.accountType)) {
        // Reverse the effect: debit decreased, credit increased
        balanceChange = transaction.type === 'debit' ? -updateAmount : updateAmount;
      } else {
        // Reverse the effect: credit decreased, debit increased
        balanceChange = transaction.type === 'credit' ? -updateAmount : updateAmount;
      }
      
      await Account.findByIdAndUpdate(
        account._id,
        { 
          $inc: { balance: balanceChange },
          $set: { lastUpdated: new Date() }
        },
        { session }
      );
    }
    
    // Create reversal journal entry
    const reversalEntry = new JournalEntry({
      clientId: req.user.id,
      entityId: journalEntry.entityId,
      entryNumber: `REV-${journalEntry.entryNumber}`,
      date: new Date(),
      description: `Reversal of ${journalEntry.entryNumber}: ${journalEntry.description}`,
      totalAmount: journalEntry.totalAmount,
      status: 'posted',
      createdBy: req.user.id,
      reversalOf: journalEntry._id,
      currency: journalEntry.currency,
      period: {
        year: new Date().getFullYear(),
        month: new Date().getMonth() + 1,
        quarter: Math.floor(new Date().getMonth() / 3) + 1
      },
      isManual: true
    });
    
    await reversalEntry.save({ session });
    
    // Create reversal transactions
    const reversalTransactions = [];
    for (const transaction of transactions) {
      const reversalTransaction = new Transaction({
        clientId: req.user.id,
        entityId: transaction.entityId,
        accountId: transaction.accountId._id,
        journalEntryId: reversalEntry._id,
        date: new Date(),
        description: `Reversal of ${transaction.description}`,
        amount: transaction.amount,
        // Reverse the transaction type
        type: transaction.type === 'debit' ? 'credit' : 'debit',
        transactionNo: reversalEntry.entryNumber,
        lineNo: transaction.lineNo,
        subledgerType: transaction.subledgerType,
        currency: transaction.currency,
        isManual: true
      });
      
      reversalTransactions.push(reversalTransaction);
    }
    
    await Transaction.insertMany(reversalTransactions, { session });
    
    // Update original journal entry
    await JournalEntry.findByIdAndUpdate(
      journalEntry._id,
      { 
        $set: { 
          status: 'reversed',
          reversedBy: reversalEntry._id
        }
      },
      { session }
    );
    
    // Create audit log
    const auditLog = new AuditLog({
      clientId: req.user.id,
      action: 'REVERSE_JOURNAL_ENTRY',
      entityType: 'JournalEntry',
      entityId: journalEntry._id,
      userId: req.user.id,
      details: { 
        originalEntryNumber: journalEntry.entryNumber,
        reversalEntryNumber: reversalEntry.entryNumber,
        date: new Date(),
        amount: journalEntry.totalAmount
      }
    });
    await auditLog.save({ session });
    
    await session.commitTransaction();
    
    res.json({ 
      success: true,
      message: 'Journal entry reversed successfully',
      reversalEntry: {
        id: reversalEntry._id,
        entryNumber: reversalEntry.entryNumber
      }
    });
  } catch (error) {
    await session.abortTransaction();
    console.error('Error reversing journal entry:', error);
    next(error);
  } finally {
    session.endSession();
  }
});

module.exports = router;



================================================
File: server/routes/accounts.js
================================================
// routes/accounts.js
const express = require('express');
const router = express.Router();
const { 
  getAccounts, 
  getAccountById, 
  createAccount, 
  updateAccount,
  deleteAccount 
} = require('../controllers/accountController');
const { 
  validateCreateAccount, 
  validateUpdateAccount,
  validateAccountId 
} = require('../validators/accountValidator');
const { auth } = require('../middleware/auth');

// Get all accounts
router.get('/', auth, getAccounts);

// Get account by ID
router.get('/:id', auth, validateAccountId, getAccountById);

// Create new account
router.post('/', auth, validateCreateAccount, createAccount);

// Update account
router.put('/:id', auth, validateUpdateAccount, updateAccount);

// Delete account
router.delete('/:id', auth, validateAccountId, deleteAccount);

module.exports = router;



================================================
File: server/routes/admin.js
================================================
const express = require('express');
const router = express.Router();
const { OpenAI } = require('openai');
const Blog = require('../models/blog');
const Content = require('../models/content');
const Consultation = require('../models/consultation');
const Checklist = require('../models/checklist');
const Contact = require('../models/contact');
const Chat = require('../models/chat');
const File = require('../models/file');
const { adminAuth } = require('../middleware/auth');

// Configure OpenAI
const openai = new OpenAI({
  apiKey: process.env.XAI_API_KEY,
  baseURL: "https://api.x.ai/v1", // xAI API endpoint
});

// Get admin dashboard data
router.get('/dashboard', adminAuth, async (req, res, next) => {
  try {
    const consultations = await Consultation.find();
    const checklists = await Checklist.find();
    const contacts = await Contact.find();
    const chats = await Chat.find();
    const files = await File.find();

    // Generate blog draft based on recent trends
    const trends = `Latest trends: High interest in ${
      consultations.map(c => c.services).flat().reduce((acc, curr) => { 
        acc[curr] = (acc[curr] || 0) + 1; 
        return acc; 
      }, {})
    } Customer questions: ${chats.map(c => c.message).join(', ')}.`;
    
    const blogDraft = await openai.chat.completions.create({
      model: 'grok-2-latest',
      messages: [
        {
          role: 'user',
          content: `Generate a blog post draft for Wilcox Advisors, focusing on our services (Bookkeeping, Monthly Financial Package, Cash Flow Management, Custom Reporting, Budgeting & Forecasting, Outsourced Controller/CFO Services) based on: ${trends}. Keep it relevant to our business and customer questions.`,
        },
      ],
      max_tokens: 500,
      temperature: 0,
    }).then(res => ({ 
      title: 'Latest Financial Insights for Your Business', 
      content: res.choices[0].message.content.trim() 
    }));

    // Get site content or use defaults
    const heroContent = (await Content.findOne({ section: 'hero' })) || { 
      section: 'hero', 
      value: { 
        headline: 'Financial Solutions for Small Businesses', 
        subtext: 'Wilcox Advisors helps small businesses like yours grow smarter with tailored financial expertise.' 
      } 
    };
    
    const aboutContent = (await Content.findOne({ section: 'about' })) || { 
      section: 'about', 
      value: 'At Wilcox Advisors, we specialize in financial solutions for small businesses. From startups to growing companies, we provide the expertise you need to succeed—built to scale with you every step of the way.' 
    };

    res.json({
      blogDrafts: [blogDraft],
      hero: heroContent.value,
      about: aboutContent.value,
      stats: {
        consultations: consultations.length,
        checklists: checklists.length,
        contacts: contacts.length,
        chats: chats.length,
        files: files.length
      }
    });
  } catch (error) {
    next(error);
  }
});

// Update site content
router.post('/content', adminAuth, async (req, res, next) => {
  const { section, value } = req.body;
  try {
    await Content.findOneAndUpdate(
      { section }, 
      { section, value }, 
      { upsert: true }
    );
    res.json({ message: 'Content updated successfully' });
  } catch (error) {
    next(error);
  }
});

// Get all consultations
router.get('/consultations', adminAuth, async (req, res, next) => {
  try {
    const consultations = await Consultation.find().sort({ timestamp: -1 });
    res.json(consultations);
  } catch (error) {
    next(error);
  }
});

// Get all checklists
router.get('/checklists', adminAuth, async (req, res, next) => {
  try {
    const checklists = await Checklist.find().sort({ timestamp: -1 });
    res.json(checklists);
  } catch (error) {
    next(error);
  }
});

// Get all contacts
router.get('/contacts', adminAuth, async (req, res, next) => {
  try {
    const contacts = await Contact.find().sort({ timestamp: -1 });
    res.json(contacts);
  } catch (error) {
    next(error);
  }
});

module.exports = router;



================================================
File: server/routes/auth.js
================================================
// routes/auth.js
const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const User = require('../models/user');

/**
 * @desc    Login user
 * @route   POST /api/auth/login
 * @access  Public
 */
router.post('/login', [
  body('email')
    .isEmail()
    .withMessage('Please provide a valid email address')
    .normalizeEmail(),
  body('password')
    .isLength({ min: 6 })
    .withMessage('Password must be at least 6 characters long')
], async (req, res, next) => {
  try {
    // Validate request
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { email, password } = req.body;

    // Check if email and password are provided
    if (!email || !password) {
      return res.status(400).json({
        status: 'error',
        message: 'Please provide email and password'
      });
    }

    // Find user by email, explicitly include password
    const user = await User.findOne({ email }).select('+password');
    
    // If user doesn't exist
    if (!user) {
      console.warn(`Login attempt with invalid email: ${email}`);
      return res.status(401).json({
        status: 'error',
        message: 'Invalid credentials'
      });
    }

    try {
      // Check if password matches
      const isMatch = await bcrypt.compare(password, user.password);
      
      if (!isMatch) {
        console.warn(`Failed login attempt for user: ${email}`);
        return res.status(401).json({
          status: 'error',
          message: 'Invalid credentials'
        });
      }

      // Create JWT token
      const token = jwt.sign(
        { 
          id: user._id, 
          // Handle string "true" vs boolean true
          isAdmin: user.isAdmin === true || user.isAdmin === "true",
          email: user.email
        },
        process.env.JWT_SECRET || 'fallback_secret_do_not_use_in_production',
        { expiresIn: '24h' }
      );

      // Log successful login
      console.info(`User logged in: ${user.email} (${user._id})`);

      // Return success response
      res.status(200).json({
        status: 'success',
        message: 'Login successful',
        token,
        // Handle string "true" vs boolean true
        isAdmin: user.isAdmin === true || user.isAdmin === "true",
        userId: user._id
      });
    } catch (passwordError) {
      console.error(`Password comparison error: ${passwordError.message}`);
      return res.status(500).json({
        status: 'error',
        message: 'Server error during authentication'
      });
    }
  } catch (error) {
    console.error(`Login error: ${error.message}`);
    next(error);
  }
});

/**
 * @desc    Register user (admin only)
 * @route   POST /api/auth/register
 * @access  Admin
 */
router.post('/register', [
  body('email')
    .isEmail()
    .withMessage('Please provide a valid email address')
    .normalizeEmail(),
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters long')
    .matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*])/)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),
  body('isAdmin')
    .isBoolean()
    .optional()
], async (req, res, next) => {
  try {
    // Validate request
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { email, password, isAdmin = false } = req.body;

    // Check if user exists
    let user = await User.findOne({ email });
    
    if (user) {
      return res.status(400).json({
        status: 'error',
        message: 'User already exists'
      });
    }

    // Create new user
    user = new User({
      email,
      password, // Will be hashed in pre-save middleware
      isAdmin
    });

    // Save user to database
    await user.save();

    console.info(`New user registered: ${email} (${user._id})`);

    // Return success response
    res.status(201).json({
      status: 'success',
      message: 'User registered successfully',
      userId: user._id
    });
  } catch (error) {
    console.error(`Registration error: ${error.message}`);
    next(error);
  }
});

/**
 * @desc    Verify JWT token
 * @route   GET /api/auth/verify
 * @access  Public
 */
router.get('/verify', async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({
        status: 'error',
        message: 'No token provided'
      });
    }

    try {
      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback_secret_do_not_use_in_production');
      
      // Check if user still exists
      const user = await User.findById(decoded.id).select('-password');
      
      if (!user) {
        return res.status(401).json({
          status: 'error',
          message: 'Invalid token - user does not exist'
        });
      }

      // Return success response
      res.status(200).json({
        status: 'success',
        isValid: true,
        user: {
          id: user._id,
          email: user.email,
          // Handle string "true" vs boolean true
          isAdmin: user.isAdmin === true || user.isAdmin === "true"
        }
      });
    } catch (verifyError) {
      // Token invalid or expired
      return res.status(401).json({
        status: 'error',
        message: 'Invalid or expired token',
        isValid: false
      });
    }
  } catch (error) {
    console.error(`Token verification error: ${error.message}`);
    next(error);
  }
});

/**
 * @desc    Logout user (stateless, just for API completeness)
 * @route   POST /api/auth/logout
 * @access  Public
 */
router.post('/logout', (req, res) => {
  // Since we're using JWT, server-side logout isn't necessary
  // Just return a success response
  res.status(200).json({
    status: 'success',
    message: 'Logged out successfully'
  });
});

module.exports = router;



================================================
File: server/routes/blog.js
================================================
// routes/blog.js
const express = require('express');
const router = express.Router();
const Blog = require('../models/blog');
const { adminAuth } = require('../middleware/auth');

/**
 * @route   GET /api/blog
 * @desc    Get all published blog posts
 * @access  Public
 */
router.get('/', async (req, res, next) => {
  try {
    // Find all published blog posts
    const posts = await Blog.find({ isDraft: false }).sort({ timestamp: -1 });
    
    res.json(posts);
  } catch (error) {
    console.error('Error fetching blog posts:', error);
    next(error);
  }
});

/**
 * @route   POST /api/blog
 * @desc    Create a new blog post
 * @access  Admin only
 */
router.post('/', adminAuth, async (req, res, next) => {
  try {
    const blog = new Blog({ ...req.body });
    await blog.save();
    
    res.status(201).json({ 
      message: 'Blog post created successfully',
      blog
    });
  } catch (error) {
    console.error('Error creating blog post:', error);
    next(error);
  }
});

/**
 * @route   PUT /api/blog/:id
 * @desc    Update a blog post
 * @access  Admin only
 */
router.put('/:id', adminAuth, async (req, res, next) => {
  try {
    const updatedBlog = await Blog.findByIdAndUpdate(
      req.params.id,
      { ...req.body },
      { new: true }
    );
    
    if (!updatedBlog) {
      return res.status(404).json({ message: 'Blog post not found' });
    }
    
    res.json({ 
      message: 'Blog post updated successfully',
      blog: updatedBlog
    });
  } catch (error) {
    console.error('Error updating blog post:', error);
    next(error);
  }
});

/**
 * @route   DELETE /api/blog/:id
 * @desc    Delete a blog post
 * @access  Admin only
 */
router.delete('/:id', adminAuth, async (req, res, next) => {
  try {
    const deletedBlog = await Blog.findByIdAndDelete(req.params.id);
    
    if (!deletedBlog) {
      return res.status(404).json({ message: 'Blog post not found' });
    }
    
    res.json({ message: 'Blog post deleted successfully' });
  } catch (error) {
    console.error('Error deleting blog post:', error);
    next(error);
  }
});

module.exports = router;



================================================
File: server/routes/chartOfAccounts.js
================================================
// routes/chartOfAccounts.js
const express = require('express');
const router = express.Router();
const { body, param, query, validationResult } = require('express-validator');
const { 
  getAllChartOfAccounts,
  getChartOfAccountsById,
  createChartOfAccounts,
  createDefaultChartOfAccounts,
  updateChartOfAccounts,
  deleteChartOfAccounts,
  addAccount,
  updateAccount,
  deleteAccount,
  getFSLICategories,
  importAccounts
} = require('../controllers/chartOfAccountsController');
const { auth } = require('../middleware/auth');
const validateRequest = require('../middleware/requestValidator');

/**
 * Base validation for chart of accounts
 */
const chartOfAccountsValidation = [
  body('entityId')
    .isMongoId()
    .withMessage('Valid entity ID is required'),
  body('name')
    .notEmpty()
    .withMessage('Name is required')
    .trim(),
  validateRequest
];

/**
 * Base validation for account in chart of accounts
 */
const accountValidation = [
  body('accountNumber')
    .notEmpty()
    .withMessage('Account number is required')
    .trim()
    .matches(/^[0-9A-Za-z-_]{1,20}$/)
    .withMessage('Account number must be 1-20 alphanumeric characters, hyphens, or underscores'),
  body('accountName')
    .notEmpty()
    .withMessage('Account name is required')
    .trim(),
  body('accountType')
    .isIn(['Asset', 'Liability', 'Equity', 'Revenue', 'Expense'])
    .withMessage('Valid account type is required'),
  body('fslCategory')
    .notEmpty()
    .withMessage('FSLI category is required')
    .trim(),
  validateRequest
];

/**
 * Routes for chart of accounts
 */

// Get all charts of accounts
router.get('/', auth, getAllChartOfAccounts);

// Get FSLI categories
router.get('/fsli-categories', auth, getFSLICategories);

// Get a single chart of accounts
router.get('/:id', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid chart of accounts ID format'),
  validateRequest
], getChartOfAccountsById);

// Create a new chart of accounts
router.post('/', auth, chartOfAccountsValidation, createChartOfAccounts);

// Create a default chart of accounts
router.post('/default', auth, [
  body('entityId')
    .isMongoId()
    .withMessage('Valid entity ID is required'),
  body('name')
    .optional()
    .trim(),
  validateRequest
], createDefaultChartOfAccounts);

// Update a chart of accounts
router.put('/:id', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid chart of accounts ID format'),
  body('name')
    .optional()
    .notEmpty()
    .withMessage('Name cannot be empty')
    .trim(),
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean'),
  validateRequest
], updateChartOfAccounts);

// Delete a chart of accounts
router.delete('/:id', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid chart of accounts ID format'),
  validateRequest
], deleteChartOfAccounts);

// Add an account to a chart of accounts
router.post('/:id/accounts', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid chart of accounts ID format'),
  ...accountValidation
], addAccount);

// Update an account in a chart of accounts
router.put('/:id/accounts/:accountNumber', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid chart of accounts ID format'),
  param('accountNumber')
    .notEmpty()
    .withMessage('Account number is required'),
  validateRequest
], updateAccount);

// Delete an account from a chart of accounts
router.delete('/:id/accounts/:accountNumber', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid chart of accounts ID format'),
  param('accountNumber')
    .notEmpty()
    .withMessage('Account number is required'),
  validateRequest
], deleteAccount);

// Import accounts from another chart of accounts
router.post('/:id/import', auth, [
  param('id')
    .isMongoId()
    .withMessage('Invalid chart of accounts ID format'),
  body('sourceChartId')
    .isMongoId()
    .withMessage('Valid source chart ID is required'),
  validateRequest
], importAccounts);

module.exports = router;



================================================
File: server/routes/chat.js
================================================
// routes/chat.js
const express = require('express');
const router = express.Router();
const { OpenAI } = require('openai');
const Chat = require('../models/chat');
const jwt = require('jsonwebtoken'); // Added missing import

// Configure OpenAI/xAI
const openai = new OpenAI({
  apiKey: process.env.XAI_API_KEY,
  baseURL: "https://api.x.ai/v1", // xAI API endpoint
});

// Public chat endpoint
router.post('/', async (req, res, next) => {
  const { message } = req.body;
  try {
    // Extract token if available
    const token = req.headers['authorization']?.split(' ')[1];
    let userId = null;
    
    if (token) {
      try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        userId = decoded.id;
      } catch (error) {
        if (error.name !== 'TokenExpiredError') {
          console.warn('Invalid token, proceeding as guest:', error.message);
        }
      }
    }
    
    // Get AI response
    const completion = await openai.chat.completions.create({
      model: 'grok-2-latest',
      messages: [
        {
          role: 'system',
          content: "You are Grok, a chatbot acting as an assistant for Wilcox Advisors, a financial services provider specializing in small businesses. Your responses must be concise, professional, and strictly limited to information about Wilcox Advisors' website and services, including Bookkeeping, Monthly Financial Package, Cash Flow Management, Custom Reporting, Budgeting & Forecasting, and Outsourced Controller/CFO Services. Do not provide free detailed advice or general knowledge outside these services. Encourage users to schedule a consultation for specific guidance or detailed information."
        },
        {
          role: 'user',
          content: `Respond to: "${message}" with a concise answer focused only on Wilcox Advisors' services and website. Avoid free detailed advice and suggest a consultation if the user seeks specifics.`
        },
      ],
      stream: false,
      max_tokens: 100,
      temperature: 0,
    });
    
    const reply = completion.choices[0].message.content.trim();
    
    // Save the chat
    const chat = new Chat({ message, reply, userId, isClientChat: false });
    await chat.save();
    
    res.json({ reply });
  } catch (error) {
    console.error('Chat API error:', error.message);
    // Send a fallback response if AI fails
    res.json({ reply: "I'd be happy to help with your financial questions! For detailed assistance, please contact us through our form." });
  }
});

// Client chat endpoint (for authenticated clients)
router.post('/client', async (req, res, next) => {
  const { message } = req.body;
  try {
    // Extract token if available
    const token = req.headers['authorization']?.split(' ')[1];
    let userId = null;
    
    if (token) {
      try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        userId = decoded.id;
      } catch (error) {
        if (error.name !== 'TokenExpiredError') {
          console.warn('Invalid token, proceeding as guest:', error.message);
        }
      }
    }
    
    // Get AI response
    const completion = await openai.chat.completions.create({
      model: 'grok-2-latest',
      messages: [
        {
          role: 'system',
          content: "You are Grok, a chatbot acting as an assistant for Wilcox Advisors, a financial services provider specializing in small businesses. Your responses must be concise, professional, and strictly limited to information about Wilcox Advisors' website and services, including Bookkeeping, Monthly Financial Package, Cash Flow Management, Custom Reporting, Budgeting & Forecasting, and Outsourced Controller/CFO Services. Do not provide free detailed advice or general knowledge outside these services. Suggest a consultation for specific guidance or detailed information."
        },
        {
          role: 'user',
          content: `Respond to: "${message}" with a concise answer focused only on Wilcox Advisors' services and website. Avoid free detailed advice and recommend a consultation for specifics.`
        },
      ],
      stream: false,
      max_tokens: 100,
      temperature: 0,
    });
    
    const reply = completion.choices[0].message.content.trim();
    
    // Save the chat
    const chat = new Chat({ message, reply, userId, isClientChat: true });
    await chat.save();
    
    res.json({ reply });
  } catch (error) {
    console.error('Chat API error:', error.message);
    // Send a fallback response if AI fails
    res.json({ reply: "I'd be happy to help with your financial questions! For detailed assistance, please contact us through our form." });
  }
});

module.exports = router;



================================================
File: server/routes/checklists.js
================================================
const express = require('express');
const router = express.Router();
const path = require('path');
const fs = require('fs');
const PDFDocument = require('pdfkit');
const Checklist = require('../models/checklist');
const { auth } = require('../middleware/auth');
const { sendNotificationEmail } = require('../utils/emailService');

// Submit checklist request and generate PDF
router.post('/', auth, async (req, res, next) => {
  try {
    const checklist = new Checklist({ 
      ...req.body, 
      userId: req.user?.id 
    });
    await checklist.save();
    
    // Create PDF directory if it doesn't exist
    const pdfDir = path.join(__dirname, '..', 'public', 'pdfs');
    if (!fs.existsSync(pdfDir)) {
      fs.mkdirSync(pdfDir, { recursive: true });
    }
    
    // Generate unique filename
    const filename = `financial-checklist-${Date.now()}.pdf`;
    const pdfPath = path.join(pdfDir, filename);
    
    // Create PDF
    const doc = new PDFDocument({ margin: 50 });
    doc.pipe(fs.createWriteStream(pdfPath));
    
    // Add content to PDF
    doc.fontSize(25).text('Financial Checklist for Small Businesses', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(`Prepared for: ${req.body.name} (${req.body.companyName})`, { align: 'center' });
    doc.moveDown(2);
    
    // Add checklist items
    const checklistItems = [
      'Set up separate business bank accounts and credit cards',
      'Establish a reliable bookkeeping system',
      'Track all business expenses with proper documentation',
      'Create a realistic budget with monthly, quarterly, and annual projections',
      'Plan for taxes by setting aside appropriate funds',
      'Review financial statements monthly',
      'Reconcile accounts regularly',
      'Create a cash flow management system',
      'Establish proper invoicing and accounts receivable procedures',
      'Review pricing structure regularly to ensure profitability',
      'Build relationships with financial professionals',
      'Develop an emergency fund for unexpected expenses',
      'Consider insurance options to protect your business',
      'Plan for retirement and investment options',
      'Review financial goals quarterly and adjust as needed'
    ];
    
    checklistItems.forEach((item, index) => {
      doc.fontSize(12).text(`${index + 1}. ${item}`);
      doc.moveDown();
    });
    
    doc.moveDown();
    doc.fontSize(14).text('Need help implementing these steps?', { align: 'center' });
    doc.fontSize(14).text('Contact Wilcox Advisors for a free consultation!', { align: 'center' });
    
    doc.end();
    
    // Send checklist email
    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: req.body.email,
      subject: 'Your Financial Checklist - Wilcox Advisors',
      html: `
        <h2>Thank you for requesting our Financial Checklist!</h2>
        <p>Hello ${req.body.name},</p>
        <p>We've attached your personalized Small Business Financial Checklist. This document includes essential steps to help manage your business finances more effectively.</p>
        <p>If you have any questions or would like assistance implementing these steps, please don't hesitate to contact us for a free consultation.</p>
        <p>Regards,<br>The Wilcox Advisors Team</p>
      `,
      attachments: [
        {
          filename: 'Financial-Checklist.pdf',
          path: pdfPath
        }
      ]
    };
    
    // Non-blocking email sending
    sendNotificationEmail(mailOptions).catch(error => {
      console.error('Failed to send checklist email:', error);
    });
    
    // Send notification email
    const notificationOptions = {
      from: process.env.EMAIL_USER,
      to: process.env.NOTIFICATION_EMAIL,
      subject: 'New Checklist Request - Wilcox Advisors',
      html: `
        <h2>New Checklist Request</h2>
        <p><strong>Name:</strong> ${req.body.name}</p>
        <p><strong>Email:</strong> ${req.body.email}</p>
        <p><strong>Company:</strong> ${req.body.companyName}</p>
        <p><strong>Revenue Range:</strong> ${req.body.revenueRange}</p>
      `
    };
    
    // Non-blocking email sending
    sendNotificationEmail(notificationOptions).catch(error => {
      console.error('Failed to send checklist notification email:', error);
    });
    
    res.status(201).json({ message: 'Checklist sent to your email' });
  } catch (error) {
    next(error);
  }
});

module.exports = router;



================================================
File: server/routes/client.js
================================================
const express = require('express');
const router = express.Router();
const { auth } = require('../middleware/auth');
const Chat = require('../models/chat');
const File = require('../models/file');

// Get client dashboard data
router.get('/dashboard', auth, async (req, res, next) => {
  try {
    // Get client's chat history
    const clientChat = await Chat.find({ 
      userId: req.user.id, 
      isClientChat: true 
    }).sort({ timestamp: -1 });
    
    // Get client's files
    const files = await File.find({ 
      userId: req.user.id 
    }).sort({ timestamp: -1 });
    
    // Mock financial data (to be replaced with real data from GL in future phases)
    const financialData = {
      profitLoss: { 
        revenue: 50000, 
        expenses: 30000, 
        netIncome: 20000 
      }, 
      balanceSheet: { 
        assets: 100000, 
        liabilities: 40000, 
        equity: 60000 
      },
      cashFlow: { 
        labels: ['Jan', 'Feb', 'Mar'], 
        data: [10000, 15000, 12000] 
      },
      reports: ['Sales by Category', 'Expense Breakdown'],
      gl: [{ date: '2025-02-01', description: 'Sales', amount: 5000 }]
    };

    res.json({
      financials: {
        profitLoss: financialData.profitLoss,
        balanceSheet: financialData.balanceSheet
      },
      cashFlow: financialData.cashFlow,
      reports: financialData.reports,
      gl: financialData.gl,
      clientChat,
      files
    });
  } catch (error) {
    next(error);
  }
});

module.exports = router;



================================================
File: server/routes/consultations.js
================================================
const express = require('express');
const router = express.Router();
const Consultation = require('../models/consultation');
const { auth } = require('../middleware/auth');
const { sendNotificationEmail } = require('../utils/emailService');

// Submit consultation request
router.post('/', auth, async (req, res, next) => {
  try {
    const consultation = new Consultation({ 
      ...req.body, 
      userId: req.user?.id 
    });
    await consultation.save();
    
    // Send email notification
    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: process.env.NOTIFICATION_EMAIL,
      subject: 'New Consultation Request - Wilcox Advisors',
      html: `
        <h2>New Consultation Request</h2>
        <p><strong>Company:</strong> ${req.body.companyName}</p>
        <p><strong>Industry:</strong> ${req.body.industry}</p>
        <p><strong>Years in Business:</strong> ${req.body.yearsInBusiness}</p>
        <p><strong>Revenue Range:</strong> ${req.body.revenueRange}</p>
        <p><strong>Services:</strong> ${req.body.services.join(', ')}</p>
        <p><strong>Contact:</strong> ${req.body.contactName}</p>
        <p><strong>Email:</strong> ${req.body.email}</p>
        <p><strong>Phone:</strong> ${req.body.phone || 'Not provided'}</p>
        <p><strong>Preferred Contact:</strong> ${req.body.preferredContact}</p>
        <p><strong>Best Time:</strong> ${req.body.preferredTime}</p>
        <p><strong>Notes:</strong> ${req.body.notes || 'None'}</p>
      `
    };
    
    // Non-blocking email sending
    sendNotificationEmail(mailOptions).catch(error => {
      console.error('Failed to send consultation notification email:', error);
    });
    
    res.status(201).json({ message: 'Consultation submitted' });
  } catch (error) {
    next(error);
  }
});

module.exports = router;



================================================
File: server/routes/contacts.js
================================================
const express = require('express');
const router = express.Router();
const Contact = require('../models/contact');
const { auth } = require('../middleware/auth');
const { sendNotificationEmail } = require('../utils/emailService');

// Submit contact form
router.post('/', auth, async (req, res, next) => {
  try {
    const contact = new Contact({ 
      ...req.body, 
      userId: req.user?.id 
    });
    await contact.save();
    
    // Send email notification
    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: process.env.NOTIFICATION_EMAIL,
      subject: 'New Contact Form Submission - Wilcox Advisors',
      html: `
        <h2>New Contact Form Submission</h2>
        <p><strong>Name:</strong> ${req.body.name}</p>
        <p><strong>Email:</strong> ${req.body.email}</p>
        <p><strong>Company:</strong> ${req.body.company}</p>
        <p><strong>Message:</strong> ${req.body.message}</p>
      `
    };
    
    // Non-blocking email sending
    sendNotificationEmail(mailOptions).catch(error => {
      console.error('Failed to send contact form notification email:', error);
    });
    
    res.status(201).json({ message: 'Contact form submitted' });
  } catch (error) {
    next(error);
  }
});

module.exports = router;



================================================
File: server/routes/entities.js
================================================
// routes/entities.js
const express = require('express');
const router = express.Router();
const { 
  getEntities, 
  getEntityById, 
  createEntity, 
  updateEntity,
  deleteEntity
} = require('../controllers/entityController');
const { 
  validateCreateEntity, 
  validateUpdateEntity,
  validateEntityId
} = require('../validators/entityValidator');
const { auth } = require('../middleware/auth');

// Get all entities
router.get('/', auth, getEntities);

// Get entity by ID
router.get('/:id', auth, validateEntityId, getEntityById);

// Create new entity
router.post('/', auth, validateCreateEntity, createEntity);

// Update entity
router.put('/:id', auth, validateUpdateEntity, updateEntity);

// Delete entity
router.delete('/:id', auth, validateEntityId, deleteEntity);

module.exports = router;



================================================
File: server/routes/files.js
================================================
// routes/files.js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const AWS = require('aws-sdk');
const File = require('../models/file');
const { auth } = require('../middleware/auth');
const logger = require('../utils/logger');

// Configure AWS S3
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION,
});

// Configure multer with file size limits and filtering
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'text/csv',
      'image/jpeg',
      'image/png'
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only PDF, Word, Excel, CSV, and image files are allowed.'), false);
    }
  }
});

// Upload file to S3 with better error handling
router.post('/upload', auth, upload.single('file'), async (req, res, next) => {
  try {
    if (!req.file) {
      return res.status(400).json({ 
        success: false,
        message: 'No file uploaded' 
      });
    }

    // Generate a unique filename to prevent collisions
    const uniqueFilename = `${Date.now()}-${req.file.originalname.replace(/\s+/g, '-')}`;
    const params = {
      Bucket: process.env.S3_BUCKET,
      Key: `${req.user.id}/${uniqueFilename}`,
      Body: req.file.buffer,
      ContentType: req.file.mimetype,
      ContentDisposition: 'inline',
    };

    // Upload to S3 with promise handling
    const uploadResult = await s3.upload(params).promise();
    
    // Save file metadata to database
    const file = new File({ 
      userId: req.user.id, 
      fileName: req.file.originalname,
      fileType: req.file.mimetype,
      fileSize: req.file.size,
      s3Key: uploadResult.Key,
      s3Url: uploadResult.Location
    });
    
    await file.save();
    
    res.status(201).json({ 
      success: true,
      message: 'File uploaded successfully',
      file: {
        id: file._id,
        fileName: file.fileName,
        fileType: file.fileType,
        fileSize: file.fileSize,
        uploadDate: file.createdAt,
        url: uploadResult.Location
      }
    });
  } catch (error) {
    logger.error(`File upload error: ${error.message}`);
    
    // Return user-friendly error messages
    if (error.name === 'MulterError') {
      if (error.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({
          success: false,
          message: 'File too large. Maximum file size is 10MB.'
        });
      }
    }
    
    return res.status(500).json({
      success: false,
      message: 'File upload failed. Please try again later.',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Get user's files with pagination
router.get('/files', auth, async (req, res, next) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;
    
    const totalFiles = await File.countDocuments({ userId: req.user.id });
    const files = await File.find({ userId: req.user.id })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);
    
    res.json({
      success: true,
      files: files.map(file => ({
        id: file._id,
        fileName: file.fileName,
        fileType: file.fileType,
        fileSize: file.fileSize,
        uploadDate: file.createdAt,
        url: file.s3Url
      })),
      pagination: {
        total: totalFiles,
        page,
        pages: Math.ceil(totalFiles / limit)
      }
    });
  } catch (error) {
    logger.error(`Get files error: ${error.message}`);
    next(error);
  }
});

// Delete file
router.delete('/files/:id', auth, async (req, res, next) => {
  try {
    const file = await File.findOne({ 
      _id: req.params.id,
      userId: req.user.id 
    });
    
    if (!file) {
      return res.status(404).json({
        success: false,
        message: 'File not found or you do not have permission to delete it'
      });
    }
    
    // Delete from S3
    const params = {
      Bucket: process.env.S3_BUCKET,
      Key: file.s3Key
    };
    
    await s3.deleteObject(params).promise();
    
    // Delete from database
    await File.deleteOne({ _id: req.params.id });
    
    res.json({
      success: true,
      message: 'File deleted successfully'
    });
  } catch (error) {
    logger.error(`Delete file error: ${error.message}`);
    next(error);
  }
});

module.exports = router;



================================================
File: server/routes/index.js
================================================
const express = require('express');
const router = express.Router();

// Import route modules
const authRoutes = require('./auth');
const consultationsRoutes = require('./consultations');
const checklistsRoutes = require('./checklists');
const contactsRoutes = require('./contacts');
const chatRoutes = require('./chat');
const filesRoutes = require('./files');
const accountingRoutes = require('./accounting');
const adminRoutes = require('./admin');
const clientRoutes = require('./client');
const blogRoutes = require('./blog');
const chartOfAccountsRoutes = require('./chartOfAccounts');

// Register routes
router.use('/auth', authRoutes);
router.use('/consultations', consultationsRoutes);
router.use('/checklists', checklistsRoutes);
router.use('/contacts', contactsRoutes);
router.use('/chat', chatRoutes);
router.use('/files', filesRoutes);
router.use('/accounting', accountingRoutes);
router.use('/admin', adminRoutes);
router.use('/client', clientRoutes);
router.use('/blog', blogRoutes);
router.use('/chart-of-accounts', chartOfAccountsRoutes);

module.exports = router;



================================================
File: server/routes/journalEntries.js
================================================
// routes/journalEntries.js
const express = require('express');
const router = express.Router();
const { 
  getJournalEntries, 
  getJournalEntryById,
  createJournalEntry,
  deleteJournalEntry
} = require('../controllers/journalEntryController');
const { 
  validateJournalEntry,
  validateJournalEntryId
} = require('../validators/journalEntryValidator');
const { auth } = require('../middleware/auth');

// Get all journal entries with filtering
router.get('/', auth, getJournalEntries);

// Get a single journal entry by ID
router.get('/:id', auth, validateJournalEntryId, getJournalEntryById);

// Create a new journal entry
router.post('/', auth, validateJournalEntry, createJournalEntry);

// Delete (reverse) a journal entry
router.delete('/:id', auth, validateJournalEntryId, deleteJournalEntry);

module.exports = router;



================================================
File: server/routes/reports.js
================================================
// routes/reports.js
const express = require('express');
const router = express.Router();
const { auth } = require('../middleware/auth');
const { 
  getTrialBalance, 
  getBalanceSheet, 
  getIncomeStatement 
} = require('../controllers/reportController');

// Get Trial Balance endpoint
router.get('/trial-balance', auth, getTrialBalance);

// Get Balance Sheet endpoint
router.get('/balance-sheet', auth, getBalanceSheet);

// Get Income Statement endpoint
router.get('/income-statement', auth, getIncomeStatement);

module.exports = router;



================================================
File: server/utils/api.js
================================================
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:10000';

// Configure axios instance
const api = axios.create({
  baseURL: API_URL,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Add error handling
api.interceptors.response.use(
  response => response,
  error => {
    console.error('API Error:', error.message);
    return Promise.reject(error);
  }
);

export default api;



================================================
File: server/utils/emailService.js
================================================
const nodemailer = require('nodemailer');

// Email transporter instance
let emailTransporter;

// Create email transporter
const createTransporter = () => {
  try {
    // Create a transporter with Gmail settings
    emailTransporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASSWORD
      },
      tls: {
        rejectUnauthorized: false // For development environments
      }
    });
    
    // Verify the connection
    emailTransporter.verify(function(error, success) {
      if (error) {
        console.error('Email transporter verification failed:', error);
      } else {
        console.log('Email server is ready to take our messages');
      }
    });
  } catch (error) {
    console.error('Failed to create email transporter:', error);
  }
};

// Initialize the transporter
createTransporter();

// Helper function to send emails with fallback logging
const sendNotificationEmail = async (options) => {
  try {
    if (!emailTransporter) {
      createTransporter(); // Try to recreate transporter if it doesn't exist
    }
    
    const info = await emailTransporter.sendMail(options);
    console.log('Email sent successfully:', info.messageId);
    return true;
  } catch (error) {
    console.error('Email sending failed:', error);
    
    // Log the email content for backup
    console.log('--- Email Content (Fallback) ---');
    console.log('To:', options.to);
    console.log('Subject:', options.subject);
    console.log('Body:', options.html ? 'HTML Content' : options.text);
    console.log('--- End Email Content ---');
    
    return false;
  }
};

module.exports = { 
  sendNotificationEmail,
  createTransporter
};



================================================
File: server/utils/logger.js
================================================
// utils/logger.js
const winston = require('winston');
const fs = require('fs');
const path = require('path');

// Create logs directory if it doesn't exist
const logDir = path.join(__dirname, '..', 'logs');
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true });
}

// Define log file paths
const errorLogPath = path.join(logDir, 'error.log');
const combinedLogPath = path.join(logDir, 'combined.log');
const accessLogPath = path.join(logDir, 'access.log');

// Define custom format
const customFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.printf(info => {
    const { timestamp, level, message, ...meta } = info;
    const metaString = Object.keys(meta).length ? JSON.stringify(meta) : '';
    return `[${timestamp}] ${level.toUpperCase()}: ${message} ${metaString}`;
  })
);

// Create the logger
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'development' ? 'debug' : 'info',
  format: customFormat,
  defaultMeta: { service: 'wilcox-advisors' },
  transports: [
    // Write logs with level 'error' and below to error.log
    new winston.transports.File({ 
      filename: errorLogPath, 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    // Write all logs to combined.log
    new winston.transports.File({ 
      filename: combinedLogPath,
      maxsize: 10485760, // 10MB
      maxFiles: 5
    })
  ],
  // Handle uncaught exceptions and rejections
  exceptionHandlers: [
    new winston.transports.File({ filename: path.join(logDir, 'exceptions.log') })
  ],
  rejectionHandlers: [
    new winston.transports.File({ filename: path.join(logDir, 'rejections.log') })
  ]
});

// Add console transport in development environment
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

// Create a stream for Morgan HTTP logger
logger.stream = {
  write: (message) => {
    logger.info(message.trim());
  }
};

module.exports = logger;



================================================
File: server/validators/accountValidator.js
================================================
// validators/accountValidator.js
const { body, param, validationResult } = require('express-validator');

// Validation middleware for account creation
exports.validateCreateAccount = [
  body('entityId')
    .isMongoId()
    .withMessage('Valid entity ID is required'),
  body('accountNumber')
    .notEmpty()
    .withMessage('Account number is required')
    .trim()
    .matches(/^[0-9]{3,6}$/)
    .withMessage('Account number must be 3-6 digits'),
  body('accountName')
    .notEmpty()
    .withMessage('Account name is required')
    .trim(),
  body('accountType')
    .isIn(['Asset', 'Liability', 'Equity', 'Revenue', 'Expense'])
    .withMessage('Valid account type is required'),
  body('subledgerType')
    .optional()
    .isIn(['GL', 'AP', 'AR', 'Payroll', 'Inventory', 'Assets'])
    .withMessage('Valid subledger type is required'),
  body('parentAccount')
    .optional()
    .isMongoId()
    .withMessage('Valid parent account ID required'),
    
  // Validation result middleware
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed', 
        errors: errors.array() 
      });
    }
    next();
  }
];

// Validation middleware for account update
exports.validateUpdateAccount = [
  param('id')
    .isMongoId()
    .withMessage('Invalid account ID format'),
  body('accountName')
    .optional()
    .notEmpty()
    .withMessage('Account name cannot be empty')
    .trim(),
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean'),
  body('isIntercompany')
    .optional()
    .isBoolean()
    .withMessage('isIntercompany must be a boolean'),
  body('parentAccount')
    .optional()
    .custom(value => {
      if (value === null) return true;
      return /^[0-9a-fA-F]{24}$/.test(value); // Simple MongoDB ObjectId validation
    })
    .withMessage('parentAccount must be a valid MongoDB ID or null'),
    
  // Validation result middleware
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed', 
        errors: errors.array() 
      });
    }
    next();
  }
];

// Validation middleware for account ID
exports.validateAccountId = [
  param('id')
    .isMongoId()
    .withMessage('Invalid account ID format'),
  
  // Validation result middleware
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed', 
        errors: errors.array() 
      });
    }
    next();
  }
];



================================================
File: server/validators/entityValidator.js
================================================
// validators/entityValidator.js
const { body, param } = require('express-validator');
const validateRequest = require('../middleware/requestValidator');

// Validation middleware for entity creation
exports.validateCreateEntity = [
  body('name')
    .notEmpty()
    .withMessage('Entity name is required')
    .trim(),
  body('code')
    .notEmpty()
    .withMessage('Entity code is required')
    .trim()
    .matches(/^[A-Za-z0-9-_]+$/)
    .withMessage('Entity code can only contain letters, numbers, hyphens and underscores'),
  body('type')
    .optional()
    .isIn(['Operating', 'Holding', 'Special Purpose', 'Elimination', 'Consolidated'])
    .withMessage('Invalid entity type'),
  body('currency')
    .optional()
    .isLength({ min: 3, max: 3 })
    .withMessage('Currency must be a 3-letter code'),
  
  // Use centralized validation middleware
  validateRequest
];

// Similar updates for other validation chains
exports.validateUpdateEntity = [
  param('id')
    .isMongoId()
    .withMessage('Invalid entity ID format'),
  body('name')
    .optional()
    .notEmpty()
    .withMessage('Entity name cannot be empty')
    .trim(),
  // other validations...
  validateRequest
];

exports.validateEntityId = [
  param('id')
    .isMongoId()
    .withMessage('Invalid entity ID format'),
  validateRequest
];



================================================
File: server/validators/journalEntryValidator.js
================================================
// validators/journalEntryValidator.js
const { body, param, validationResult } = require('express-validator');

// Validation middleware for journal entry creation
exports.validateJournalEntry = [
  body('date')
    .isDate()
    .withMessage('Valid date is required'),
  body('entityId')
    .isMongoId()
    .withMessage('Valid entity ID is required'),
  body('description')
    .notEmpty()
    .withMessage('Description is required')
    .trim(),
  body('entries')
    .isArray({ min: 1 })
    .withMessage('At least one entry is required'),
  body('entries.*.accountId')
    .isMongoId()
    .withMessage('Valid account ID is required'),
  body('entries.*.amount')
    .isFloat({ gt: 0 })
    .withMessage('Amount must be greater than zero'),
  body('entries.*.type')
    .isIn(['debit', 'credit'])
    .withMessage('Type must be either debit or credit'),
    
  // Validation result middleware
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed', 
        errors: errors.array() 
      });
    }
    next();
  }
];

// Validation middleware for journal entry ID format
exports.validateJournalEntryId = [
  param('id')
    .isMongoId()
    .withMessage('Invalid journal entry ID format'),
    
  // Validation result middleware
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ 
        success: false,
        message: 'Validation failed', 
        errors: errors.array() 
      });
    }
    next();
  }
];


