Architect's Mission: Implement Industry-Standard Context Selection
1. Goal

Refactor the application's context selection logic to align with the highest industry standards exemplified by platforms like Odoo and Sage Intacct. On initial application load, no client shall be automatically selected. Data will only be loaded and displayed after a user explicitly selects a client and entity, or when the context is provided directly in the URL.

2. Root Cause Analysis & Architectural Mandate

The current implementation violates our most important architectural principle. By restoring the last-viewed client from localStorage, the UI loads into a "pre-selected" state that is not represented in the URL. This creates a disconnect between the application's state and its address, leading directly to the race conditions and broken data-loading behavior we have observed.

State-of-the-art platforms do not function this way. They present a clean slate and require the user to make an explicit contextual choice. We will enforce this standard immediately. The "memory" of the last client is a low-value feature that is causing high-impact bugs; it will be removed in favor of absolute predictability and stability.

3. Definitive Fix Plan

We will execute a two-part surgical refactor to correct this behavior permanently.

Part 1: Decouple Global Selector from localStorage

File to Modify: client/src/components/dashboard/GlobalContextSelector.tsx
Action:
Locate the useState hook that manages the selectedClientId.
Remove the localStorage.getItem call from its initialization. The state must be initialized to a null or undefined state (e.g., useState<number | null>(null)).
Locate and delete the entire useEffect hook that saves the selectedClientId back to localStorage.
RESULT: The GlobalContextSelector will now be a "dumb" component. It will no longer have its own memory. Its state will be driven exclusively by URL parameters and direct user interaction, as it should be.
Part 2: Enhance the EntityLayout Guard

File to Modify: client/src/components/layout/EntityLayout.tsx
Action:
The layout guard must be enhanced to handle three distinct scenarios gracefully:
A) Context Loading: If the EntityContext is still fetching its initial data (isLoading || !initialLoadComplete), the layout must render a full-page <Spinner />. This prevents any child component from rendering with partial or stale data.
B) No Client/Entity in URL: If the context has loaded but the clientId or entityId parameters are missing from the URL, the layout must render the <NoEntitySelected /> component. This provides clear instructions to the user to select a client to begin working.
C) Context Ready: If the context is loaded AND the clientId and entityId are present in the URL, the layout will proceed with its primary function of rendering the <Outlet />, allowing the target page (e.g., JournalEntries) to render.
4. Expected Outcome

When a user navigates to a base URL like /journal-entries, the GlobalContextSelector will correctly show "Select a client..." and the main content area will display the <NoEntitySelected /> message. The application's initial state will be clean, predictable, and unambiguous.
The user will then make an explicit choice from the selector, which will trigger a navigation to the appropriate URL (e.g., /clients/235/entities/376/journal-entries).
The EntityLayout will re-render. With the required parameters now present in the URL, it will render the JournalEntries page, which will now load its data correctly and reliably on the very first attempt.
This flow is professional, bug-free, and aligns with the user experience of other world-class enterprise accounting platforms. It fully enforces the URL as the one and only source of truth for the application's context.