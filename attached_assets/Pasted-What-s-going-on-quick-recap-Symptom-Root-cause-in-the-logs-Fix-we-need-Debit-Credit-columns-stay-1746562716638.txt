What’s going on – quick recap
Symptom	Root cause (in the logs)	Fix we need
Debit/Credit columns stay blank	We added the new entry alias, but the table still references the old helper isClientFormatLine() & getLineAmount() which only recognise the legacy format (debit / credit fields). New hierarchical calls return the compact `{ type:"debit"	“credit”, amount: n }format, so the helpers return0`.
POST / Save-as-draft returns 400	The payload that goes to /journal-entries is fine except for two common validation failures the server now enforces: ① duplicate referenceNumber (you used "new" three times) and ② a null accountId on at least one credit line (see the first request you made – "accountId": null).	Client-side validation before the mutation + friendlier error surfacing when the API says 400.
Post button appears inert	It does fire the mutation (see the console) but because the promise rejects with 400, nothing happens in the UI. We swallow the error in onError and never flash a toast.	Bubble the error up (or show a toast) so the user knows why.

1 — Patch the helpers so amounts render
ts
Copy
Edit
// utils/journalEntry.ts (or inside JournalEntryDetail.tsx if that's where it lives)

/** Returns true if the line is in the *new* compact shape */
const isCompactFormat = (l: any): l is { type: 'debit' | 'credit'; amount: number } =>
  !!l.type && typeof l.amount === 'number';

/** Old helper – keep it */
const isLegacyFormat = (l: any): l is { debit: number; credit: number } =>
  typeof l.debit === 'number' || typeof l.credit === 'number';

export const getDebit = (l: any) => {
  if (isLegacyFormat(l)) return l.debit ?? 0;
  if (isCompactFormat(l)) return l.type === 'debit' ? l.amount : 0;
  return 0;
};

export const getCredit = (l: any) => {
  if (isLegacyFormat(l)) return l.credit ?? 0;
  if (isCompactFormat(l)) return l.type === 'credit' ? l.amount : 0;
  return 0;
};
Replace every manual line.type === … ? … check in JournalEntryDetail & JournalEntryForm with these helpers.
Totals (calculateTotals, entity balances, etc.) become:

ts
Copy
Edit
const totals = entry.lines.reduce(
  (t, l) => ({
    totalDebit: t.totalDebit + getDebit(l),
    totalCredit: t.totalCredit + getCredit(l),
  }),
  { totalDebit: 0, totalCredit: 0 }
);
2 — Client-side validation before calling the API
Add just before mutate() inside handleSubmit:

ts
Copy
Edit
// 1. lines must be balanced
const diff = Math.abs(totals.totalDebit - totals.totalCredit);
if (diff > 0.005) {
  toast.error('Debits and credits must balance before you can save.');
  return;
}

// 2. every line needs an accountId
if (entry.lines.some(l => !l.accountId)) {
  toast.error('Each line needs an account code.');
  return;
}

// 3. reference number required & unique client-side cache check
if (!entry.referenceNumber?.trim()) {
  toast.error('Reference # is required.');
  return;
}
3 — Surface a 400 error nicely
In the mutation’s onError:

ts
Copy
Edit
onError: (err: any) => {
  // our API returns { field, message } on 400
  if (err?.field === 'referenceNumber') {
    toast.error(err.message);
  } else {
    toast.error(err.message ?? 'Could not save entry – check required fields');
  }
},
Now the user knows immediately if “Reference number already exists”.

4 — Why the Post button keeps spinning
It’s doing its job; we just never see success because of the 400’s.
After the two fixes above you should be able to:

Add a credit line with a valid account.

Give the entry a unique reference #.

Click Save as draft or Post – the toast should say “Journal entry created”, the list invalidates, and the detail page shows balanced amounts.

Quick smoke-test checklist
Create a JE with balanced lines → “Draft created” toast.

Post the same JE → status flips, row shows “Posted”.

Try using a duplicate reference → toast “Reference number already in use”.

Open any JE (legacy or hierarchical) → Debit / Credit columns populate.

Let me know if any of these still fail and we’ll dig deeper!