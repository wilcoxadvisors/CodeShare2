Instructions for Replit AI Agent
Hello Agent. We will now create the API routes that will allow the frontend to interact with the dimension storage layer we just built.

High-Level Goal:
Create a new dimensionRoutes.ts file containing a set of RESTful API endpoints for all CRUD operations on dimensions and their values. Then, register these new routes with the main Express application.

MANDATORY INSTRUCTIONS

Part 1: Create the Dimension Routes File
Create a new file inside the server/routes/ directory (if it exists, otherwise in server/) named dimensionRoutes.ts.

Add the following code to this new server/routes/dimensionRoutes.ts file. This code sets up all the necessary endpoints for managing dimensions and their associated values.

TypeScript

// In server/routes/dimensionRoutes.ts

import { Router } from 'express';
import { asyncHandler, throwBadRequest } from '../errorHandling';
import { dimensionStorage } from '../storage/dimensionStorage';
import { isAuthenticated } from '../authMiddleware';

const router = Router();

// --- Dimension Routes ---

// GET all dimensions and their values for a specific client
router.get('/clients/:clientId/dimensions', isAuthenticated, asyncHandler(async (req, res) => {
    const clientId = parseInt(req.params.clientId, 10);
    if (isNaN(clientId)) {
        return throwBadRequest('A valid client ID is required.');
    }
    const allDimensions = await dimensionStorage.getDimensionsByClient(clientId);
    res.status(200).json(allDimensions);
}));

// POST (create) a new dimension for a client
router.post('/clients/:clientId/dimensions', isAuthenticated, asyncHandler(async (req, res) => {
    const clientId = parseInt(req.params.clientId, 10);
    if (isNaN(clientId)) {
        return throwBadRequest('A valid client ID is required.');
    }
    // Assuming the request body contains { code, name, description }
    const newDimension = await dimensionStorage.createDimension({ ...req.body, clientId });
    res.status(201).json(newDimension);
}));

// PUT (update) an existing dimension
router.put('/dimensions/:id', isAuthenticated, asyncHandler(async (req, res) => {
    const id = parseInt(req.params.id, 10);
    if (isNaN(id)) {
        return throwBadRequest('A valid dimension ID is required.');
    }
    const updatedDimension = await dimensionStorage.updateDimension(id, req.body);
    res.status(200).json(updatedDimension);
}));


// --- Dimension Value Routes ---

// POST (create) a new value for a specific dimension
router.post('/dimensions/:dimensionId/values', isAuthenticated, asyncHandler(async (req, res) => {
    const dimensionId = parseInt(req.params.dimensionId, 10);
    if (isNaN(dimensionId)) {
        return throwBadRequest('A valid dimension ID is required.');
    }
    // Assuming the request body contains { code, name, description }
    const newValue = await dimensionStorage.createDimensionValue({ ...req.body, dimensionId });
    res.status(201).json(newValue);
}));

// PUT (update) an existing dimension value
router.put('/dimension-values/:id', isAuthenticated, asyncHandler(async (req, res) => {
    const id = parseInt(req.params.id, 10);
    if (isNaN(id)) {
        return throwBadRequest('A valid dimension value ID is required.');
    }
    const updatedValue = await dimensionStorage.updateDimensionValue(id, req.body);
    res.status(200).json(updatedValue);
}));

export default router;
Part 2: Register the New Routes in the Main Application
Open the main router file, which is likely server/routes.ts or server/index.ts (where other routes like journalEntryRoutes are registered).

Import the new dimension router at the top of the file:

TypeScript

import dimensionRoutes from './routes/dimensionRoutes';
Register the router with the Express app. Inside the main routing function (e.g., registerRoutes), add the following line to make the new endpoints active:

TypeScript

app.use('/api', dimensionRoutes);
Next Step:
Once this is complete, the entire backend foundation for Dimensions will be finished. We will have a database, a data access layer, and a full API. The next and final phase for this feature will be to build the user interface components in the frontend.