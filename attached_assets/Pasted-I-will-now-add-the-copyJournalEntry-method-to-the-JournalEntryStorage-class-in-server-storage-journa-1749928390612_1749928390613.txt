I will now add the copyJournalEntry method to the JournalEntryStorage class in server/storage/journalEntryStorage.ts. This method will handle the core logic of duplicating a journal entry and all its associated data within a single database transaction to ensure data integrity.

Here is the code to be added to server/storage/journalEntryStorage.ts:

TypeScript

import { and, eq, sql } from 'drizzle-orm';
import { db } from '../db';
import * as schema from '../../shared/schema';
import {
  JournalEntry,
  JournalEntryLine,
  NewJournalEntry,
  NewJournalEntryLine,
} from '../../shared/schema';
import { IJournalEntryStorage } from './IJournalEntryStorage';
import { generateReferenceNumber } from '../utils/referenceNumber';
import { txDimensionLinks } from '../../shared/schema';

export class JournalEntryStorage implements IJournalEntryStorage {
  // ... existing methods ...

  async copyJournalEntry(
    originalEntryId: number,
    newUserId: number
  ): Promise<JournalEntry> {
    const originalEntry = await db.query.journalEntries.findFirst({
      where: eq(schema.journalEntries.id, originalEntryId),
      with: {
        lines: {
          with: {
            dimensions: {
              columns: {
                dimensionId: true,
                valueId: true,
              },
            },
          },
        },
      },
    });

    if (!originalEntry) {
      throw new Error(`Original journal entry with id ${originalEntryId} not found`);
    }

    const newJournalEntry = await db.transaction(async (tx) => {
      const [copiedEntry] = await tx
        .insert(schema.journalEntries)
        .values({
          ...originalEntry,
          id: undefined, // Let the database generate a new ID
          journalId: undefined, // This will be regenerated
          date: new Date(),
          status: 'draft',
          referenceNumber: await generateReferenceNumber(),
          description: `Copy of: ${originalEntry.description}`,
          postedBy: undefined,
      		postedAt: undefined,
          createdAt: new Date(),
          updatedAt: new Date(),
          createdById: newUserId,
          updatedById: newUserId,
        })
        .returning();

      if (!copiedEntry) {
        tx.rollback();
        throw new Error('Failed to create copied journal entry header.');
      }

      for (const line of originalEntry.lines) {
        const [newLine] = await tx
          .insert(schema.journalEntryLines)
          .values({
            ...line,
            id: undefined, // Let the database generate a new ID
            journalEntryId: copiedEntry.id,
          })
          .returning();

        if (!newLine) {
          tx.rollback();
          throw new Error('Failed to create copied journal entry line.');
        }

        if (line.dimensions && line.dimensions.length > 0) {
          const newDimensionLinks = line.dimensions.map((dim) => ({
            journalEntryLineId: newLine.id,
            dimensionId: dim.dimensionId,
            valueId: dim.valueId,
          }));
          await tx.insert(txDimensionLinks).values(newDimensionLinks);
        }
      }

      return copiedEntry;
    });

    // Refetch the full entry to return to the client
    const fullCopiedEntry = await this.getJournalEntry(newJournalEntry.id);
    if (!fullCopiedEntry) {
      // This should not happen if the transaction was successful
      throw new Error("Could not retrieve the newly copied journal entry.");
    }
    
    return fullCopiedEntry;
  }
}
I have added the copyJournalEntry method as specified. Next, I will proceed with Part 2: API Endpoint. Please confirm.






