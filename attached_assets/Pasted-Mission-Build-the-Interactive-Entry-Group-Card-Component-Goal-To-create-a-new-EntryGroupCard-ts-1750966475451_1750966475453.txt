Mission: Build the Interactive "Entry Group Card" Component

Goal: To create a new EntryGroupCard.tsx component that renders a single, auto-grouped journal entry from the batch analysis. This component must be collapsible, display all relevant line-item data, and clearly highlight any validation errors or AI suggestions, creating a user-friendly and highly functional reconciliation interface.

Architectural Justification: The review screen's power comes from its ability to present complex information in a clear, digestible format. A collapsible card for each entry allows the user to focus on one transaction at a time. Highlighting errors and suggestions directly on the data grid provides immediate context, enabling rapid correction and approval. This is a core component of a state-of-the-art user experience.

Surgical Code Implementation
Step 1: Create the EntryGroupCard.tsx File

Action: Create a new file at client/src/features/journal-entries/components/EntryGroupCard.tsx.

Instruction: Add the following complete and documented code. This component is designed for clarity and interactivity.

TypeScript

import React from 'react';
import { Card } from '@/components/ui/card';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { ChevronsUpDown, AlertCircle, Lightbulb } from 'lucide-react';

// Define the component's props for type safety
interface EntryGroupCardProps {
  group: any;
  index: number;
  onCellUpdate: (groupIndex: number, lineIndex: number, field: string, value: string) => void;
}

export const EntryGroupCard: React.FC<EntryGroupCardProps> = ({ group, index, onCellUpdate }) => {
  const errorCount = group.errors?.length || 0;
  const suggestionCount = group.aiSuggestions?.length || 0;

  // Helper to find an error for a specific line and field for highlighting
  const getErrorForCell = (originalRow: number, field: string) => {
    return group.errors?.find((e: any) => e.originalRow === originalRow && e.field === field);
  };

  return (
    <Card className={!group.isValid ? 'border-red-400 border-2' : 'border-gray-200'}>
      <Collapsible defaultOpen={!group.isValid}>
        <CollapsibleTrigger asChild>
          <div className="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-50 rounded-t-lg">
            <div className="flex-1">
              <h4 className="font-semibold">
                Entry Group #{index + 1}
                {group.header.Date && <span className="ml-4 font-normal text-sm text-muted-foreground">Date: {new Date(group.header.Date).toLocaleDateString()}</span>}
              </h4>
              <p className="text-sm text-muted-foreground truncate pr-4">{group.header.Description || 'No description provided'}</p>
            </div>
            <div className="flex items-center space-x-2 flex-shrink-0">
              {errorCount > 0 && <Badge variant="destructive">{errorCount} Error(s)</Badge>}
              {suggestionCount > 0 && <Badge variant="default" className="bg-yellow-400 text-black hover:bg-yellow-500">{suggestionCount} Suggestion(s)</Badge>}
              <Button variant="ghost" size="sm" className="w-8 h-8 p-0">
                <ChevronsUpDown className="h-4 w-4" />
                <span className="sr-only">Toggle</span>
              </Button>
            </div>
          </div>
        </CollapsibleTrigger>
        <CollapsibleContent>
          <div className="p-4 pt-0 border-t">
            <div className="border rounded-lg overflow-x-auto">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-[50px]">Row</TableHead>
                    <TableHead>Account Code</TableHead>
                    <TableHead>Description</TableHead>
                    <TableHead>Debit</TableHead>
                    <TableHead>Credit</TableHead>
                    {/* Dynamically add dimension headers */}
                    {Object.keys(group.lines[0]?.dimensions || {}).map(dimKey => (
                       <TableHead key={dimKey}>{dimKey}</TableHead>
                    ))}
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {group.lines.map((line: any, lineIndex: number) => {
                    const accountError = getErrorForCell(line.originalRow, 'AccountCode');
                    return (
                      <TableRow key={line.originalRow} className={accountError ? 'bg-red-50' : ''}>
                        <TableCell className="text-xs text-muted-foreground">{line.originalRow}</TableCell>
                        <TableCell>
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <Input
                                  defaultValue={line.accountCode}
                                  onBlur={(e) => onCellUpdate(index, lineIndex, 'accountCode', e.target.value)}
                                  className={accountError ? 'border-red-500' : ''}
                                />
                              </TooltipTrigger>
                              {accountError && <TooltipContent><p className="text-red-600">{accountError.message}</p></TooltipContent>}
                            </Tooltip>
                          </TooltipProvider>
                        </TableCell>
                        <TableCell>
                          <Input
                            defaultValue={line.description}
                            onBlur={(e) => onCellUpdate(index, lineIndex, 'description', e.target.value)}
                          />
                        </TableCell>
                        <TableCell>
                           <Input
                            type="number"
                            defaultValue={line.amount.isPositive() ? line.amount.toFixed(2) : ''}
                            onBlur={(e) => onCellUpdate(index, lineIndex, 'debit', e.target.value)}
                            className="text-right font-mono"
                           />
                        </TableCell>
                        <TableCell>
                            <Input
                             type="number"
                             defaultValue={line.amount.isNegative() ? line.amount.abs().toFixed(2) : ''}
                             onBlur={(e) => onCellUpdate(index, lineIndex, 'credit', e.target.value)}
                             className="text-right font-mono"
                            />
                        </TableCell>
                         {Object.keys(line.dimensions).map(dimKey => {
                           const dimError = getErrorForCell(line.originalRow, dimKey);
                           return (
                            <TableCell key={dimKey}>
                              <TooltipProvider>
                                <Tooltip>
                                    <TooltipTrigger asChild>
                                       <Input
                                        defaultValue={line.dimensions[dimKey]}
                                        onBlur={(e) => onCellUpdate(index, lineIndex, `dimensions.${dimKey}`, e.target.value)}
                                        className={dimError ? 'border-red-500' : ''}
                                       />
                                    </TooltipTrigger>
                                    {dimError && <TooltipContent><p className="text-red-600">{dimError.message}</p></TooltipContent>}
                                </Tooltip>
                              </TooltipProvider>
                            </TableCell>
                           )
                         })}
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </div>
          </div>
        </CollapsibleContent>
      </Collapsible>
    </Card>
  );
};
Step 2: Update IntelligentReviewScreen.tsx

Action: Open this file and update it to pass the onCellUpdate prop correctly to the new component.

Instruction:

TypeScript

// Inside IntelligentReviewScreen.tsx, find the map function:
{filteredAndSortedGroups.map((group: any, index: number) => (
  // Replace the old EntryGroupCard call with this one, passing the handler function.
  <EntryGroupCard
    key={group.groupKey}
    group={group}
    index={index}
    onCellUpdate={handleCellUpdate}
  />
))}
Verification Plan
Navigate to the /batch-import URL and upload a file with known errors.

Verify: The review screen should now display a list of interactive, collapsible cards instead of the placeholder divs.

Verify Error Highlighting: Find an entry card with an "Errors" badge. The card itself should have a red border. Expand it. The specific input field (e.g., for AccountCode) with the error should also have a red border. Hovering over it should show a tooltip with the error message.

Verify Inline Editing: Click into the incorrect input field and type a valid value. Click away to trigger the onBlur event.

Verify State Update: Check the developer console. The "Updated group..." log message from handleCellUpdate should appear, confirming that the state is being updated correctly. (The error highlighting will not disappear until we implement real-time re-validation in the next mission).

This mission builds the final major UI component for our feature. Once this is verified, we will be one step away from a fully interactive reconciliation tool.