Task Assignment: Refactor Account Storage Logic into New Module

Context: The main server/storage.ts file is too large. We are refactoring it by domain. This task extracts all Chart of Accounts (CoA) related storage logic into a dedicated module.

Goal: Create a new accountStorage.ts file, move all Account-related interfaces and class methods into it, and update the account API routes to use the new module.

Instructions:

Action: Create Directory:

Create the directory if it doesn't exist: CodeShare/server/storage/
Bash

mkdir -p CodeShare/server/storage
Action: Create accountStorage.ts File:

Create the new file: CodeShare/server/storage/accountStorage.ts

Populate it with the following TypeScript code. This defines the IAccountStorage interface and the AccountStorage class containing the logic previously in DatabaseStorage for accounts.

TypeScript

// CodeShare/server/storage/accountStorage.ts
import { db } from "../db"; // Adjust path if db connection setup is elsewhere
import {
    accounts, Account, InsertAccount, AccountType, journalEntryLines,
    // Import other necessary types from schema if needed by helper functions below
} from "../../shared/schema"; // Adjust path to schema file relative to new location
import { eq, and, desc, asc, sql, count, inArray, gt } from "drizzle-orm";
import { standardChartOfAccounts } from "../coaTemplate"; // Adjust path to coaTemplate relative to new location
import { ApiError, handleDbError } from "../errorHandling"; // Adjust path to errorHandling relative to new location
// Import any other necessary utilities (e.g., PapaParse, XLSX for import)
// import Papa from 'papaparse';
// import * as XLSX from 'xlsx';


// --- Interface Definition ---

// Define interface for hierarchical account structure
export interface AccountTreeNode extends Account {
  children: AccountTreeNode[];
}

// Define interface specifically for Account storage operations
export interface IAccountStorage {
    seedClientCoA(clientId: number): Promise<void>;
    getAccountsByClientId(clientId: number): Promise<Account[]>;
    getAccountsTree(clientId: number): Promise<AccountTreeNode[]>;
    createAccount(accountData: Omit<Account, 'id' | 'isActive' | 'createdAt' | 'updatedAt'>): Promise<Account>;
    getAccountById(accountId: number, clientId: number): Promise<Account | undefined>;
    updateAccount(accountId: number, clientId: number, accountData: Partial<Omit<Account, 'id' | 'clientId' | 'isActive' | 'createdAt' | 'updatedAt'>>): Promise<Account | null>;
    deleteAccount(accountId: number, clientId: number): Promise<boolean>; // Soft delete
    importCoaForClient(clientId: number, fileBuffer: Buffer, fileName: string, selections?: any | null): Promise<{ success: boolean; message: string; results?: any; errors: string[]; warnings: string[] }>; // Refined return type
    exportCoaForClient(clientId: number): Promise<any[]>;
    accountHasTransactions(id: number): Promise<boolean>;
}

// --- Implementation Class ---

export class AccountStorage implements IAccountStorage {

    // --- Helper Methods (Copied from original storage.ts) ---

    private normalizeAccountType(type: string): AccountType {
      // Implementation from original DatabaseStorage...
      if (!type) throw new Error("Account type is required");
      const upperType = type.trim().toUpperCase();
      if (upperType === 'ASSET' || upperType === 'ASSETS') return AccountType.ASSET;
      if (upperType === 'LIABILITY' || upperType === 'LIABILITIES') return AccountType.LIABILITY;
      if (upperType === 'EQUITY') return AccountType.EQUITY;
      if (upperType === 'REVENUE' || upperType === 'INCOME' || upperType === 'REVENUES' || upperType === 'INCOMES') return AccountType.REVENUE;
      if (upperType === 'EXPENSE' || upperType === 'EXPENSES') return AccountType.EXPENSE;
      // Add other mappings as necessary from the original implementation
      throw new Error(`Invalid account type: ${type}`);
    }

    private parseBooleanFlag(value: any, defaultValue: boolean = false): boolean {
        // Implementation from original DatabaseStorage...
         if (value === undefined || value === null) return defaultValue;
         if (typeof value === 'boolean') return value;
         const normalizedValue = String(value).toLowerCase().trim();
         return ['true', '1', 'yes', 'y'].includes(normalizedValue);
    }

     private getCaseInsensitiveValue(row: any, fieldName: string): any {
         // Implementation from original DatabaseStorage...
         if (!row) return null;
         const lowerFieldName = fieldName.toLowerCase();
         for (const key in row) {
             if (key.toLowerCase() === lowerFieldName) {
                 return row[key];
             }
         }
         // Add variations if needed (e.g., account_code vs accountCode)
         if(fieldName === 'accountCode') return row['account_code'] ?? row['Account Code'] ?? row['code'] ?? null; // Added legacy 'code'
         if(fieldName === 'parentCode') return row['parent_code'] ?? row['Parent Code'] ?? row['parent'] ?? null; // Added legacy 'parent'

         return null;
     }

     private getParentCode(row: any): string | null {
        // Implementation from original DatabaseStorage...
        const parentCodeValue = this.getCaseInsensitiveValue(row, 'parentCode'); // Use the helper
        if (parentCodeValue !== null && parentCodeValue !== undefined && String(parentCodeValue).trim() !== '') {
          const trimmed = String(parentCodeValue).trim();
          if (trimmed) {
            return trimmed;
          }
        }
        return null;
     }

    private parseIsSubledger(row: any, existingAccount?: Account): boolean {
         // Implementation from original DatabaseStorage...
        const isSubledgerField = this.getCaseInsensitiveValue(row, 'isSubledger') ?? this.getCaseInsensitiveValue(row, 'is_subledger');
        if (isSubledgerField === undefined && existingAccount) {
          return existingAccount.isSubledger ?? false; // Default to false if null/undefined in existing
        }
        return this.parseBooleanFlag(isSubledgerField, false); // Default to false if not provided/invalid
    }

     private getSubledgerType(row: any, existingAccount?: Account): string | null {
         // Implementation from original DatabaseStorage...
        const subledgerType = this.getCaseInsensitiveValue(row, 'subledgerType') ?? this.getCaseInsensitiveValue(row, 'subledger_type');
        if (subledgerType) {
            const trimmed = String(subledgerType).trim();
            return trimmed !== '' ? trimmed : null;
        }
        if (existingAccount) {
          return existingAccount.subledgerType;
        }
        return null;
    }


    // --- Storage Methods (Copied from original DatabaseStorage) ---

    async seedClientCoA(clientId: number): Promise<void> {
        // Implementation copied from DatabaseStorage in original storage.ts
         console.log(`Attempting to seed CoA for client ${clientId}`);
         try {
            await db.transaction(async (tx) => {
                const existingAccounts = await tx.select({ id: accounts.id })
                                                .from(accounts)
                                                .where(eq(accounts.clientId, clientId))
                                                .limit(1);

                if (existingAccounts.length > 0) {
                    console.log(`CoA already seeded for client ${clientId}. Skipping.`);
                    return;
                }

                console.log(`Seeding standard CoA for client ${clientId}...`);
                const accountMap = new Map<string, number>(); // Maps template ID to actual DB ID

                const insertedIds: { templateId?: string, dbId: number, parentTemplateId?: string }[] = [];
                for (const acc of standardChartOfAccounts) {
                     const accountData: Omit<Account, 'id' | 'updatedAt' | 'createdAt'> = { // Adjusted Omit type
                        clientId: clientId,
                        accountCode: acc.accountCode,
                        name: acc.name,
                        type: acc.type,
                        parentId: null, // Insert with null parent first
                        fsliBucket: acc.fsliBucket,
                        internalReportingBucket: acc.internalReportingBucket,
                        isActive: true,
                        isFolder: acc.isFolder ?? false,
                        description: acc.description ?? '',
                        isSystemAccount: acc.isSystemAccount ?? false,
                    };
                     const inserted = await tx.insert(accounts).values(accountData).returning({ id: accounts.id });
                     if (inserted.length > 0 && acc.id) {
                         const dbId = inserted[0].id;
                         accountMap.set(acc.id, dbId); // Map template ID to DB ID
                         insertedIds.push({ templateId: acc.id, dbId: dbId, parentTemplateId: acc.parentId });
                    } else {
                         console.error("Failed to insert account during seeding:", acc);
                         throw new Error(`Failed to insert account ${acc.accountCode} for client ${clientId}`);
                    }
                }

                const parentUpdates: Promise<any>[] = [];
                for (const item of insertedIds) {
                     if (item.parentTemplateId) {
                         const parentDbId = accountMap.get(item.parentTemplateId);
                         if (parentDbId) {
                             parentUpdates.push(
                                 tx.update(accounts)
                                   .set({ parentId: parentDbId })
                                   .where(eq(accounts.id, item.dbId))
                             );
                         } else {
                             console.warn(`Could not find parent DB ID for template parent ID ${item.parentTemplateId} when seeding for client ${clientId}`);
                         }
                     }
                 }
                 await Promise.all(parentUpdates);


                console.log(`Successfully seeded ${standardChartOfAccounts.length} accounts for client ${clientId}.`);
            });
         } catch (error) {
             throw handleDbError(error, `seeding CoA for client ${clientId}`);
         }
    }

    async getAccountsByClientId(clientId: number): Promise<Account[]> {
         console.log(`Getting accounts for client ${clientId}`);
         try {
             return await db.select()
                            .from(accounts)
                            .where(and(eq(accounts.clientId, clientId), eq(accounts.isActive, true))) // Only active
                            .orderBy(accounts.accountCode);
         } catch (error) {
             throw handleDbError(error, `Workspaceing accounts for client ${clientId}`);
         }
    }

    async getAccountsTree(clientId: number): Promise<AccountTreeNode[]> {
        console.log(`Getting accounts tree for client ${clientId}`);
        try {
            const allAccounts = await db.select()
                                        .from(accounts)
                                        .where(and(eq(accounts.clientId, clientId), eq(accounts.isActive, true)))
                                        .orderBy(accounts.accountCode);

            const accountMap: { [key: number]: AccountTreeNode } = {};
            const rootAccounts: AccountTreeNode[] = [];

            allAccounts.forEach(account => {
                accountMap[account.id] = { ...account, children: [] };
            });

            allAccounts.forEach(account => {
                if (account.parentId && accountMap[account.parentId]) {
                    accountMap[account.parentId].children.push(accountMap[account.id]);
                } else {
                    rootAccounts.push(accountMap[account.id]);
                }
            });

            // Recursively sort children by accountCode
            const sortNodes = (nodes: AccountTreeNode[]) => {
              nodes.sort((a, b) => a.accountCode.localeCompare(b.accountCode));
              nodes.forEach(node => {
                if (node.children.length > 0) {
                  sortNodes(node.children);
                }
              });
            };
            sortNodes(rootAccounts);


            return rootAccounts;
        } catch (error) {
            throw handleDbError(error, `getting accounts tree for client ${clientId}`);
        }
    }

     async getAccountById(accountId: number, clientId: number): Promise<Account | undefined> {
         console.log(`Getting account ${accountId} for client ${clientId}`);
         try {
             const [account] = await db.select()
                 .from(accounts)
                 .where(and(eq(accounts.id, accountId), eq(accounts.clientId, clientId)))
                 .limit(1);
             return account;
         } catch (error) {
             throw handleDbError(error, `getting account by ID ${accountId}`);
         }
     }

    async createAccount(accountData: Omit<Account, 'id' | 'isActive' | 'createdAt' | 'updatedAt'>): Promise<Account> {
         console.log(`Creating account '<span class="math-inline">\{accountData\.name\}' \(</span>{accountData.accountCode}) for client ${accountData.clientId}`);
         try {
              if (accountData.parentId) {
                  const parent = await db.select({id: accounts.id})
                                         .from(accounts)
                                         .where(and(eq(accounts.id, accountData.parentId), eq(accounts.clientId, accountData.clientId), eq(accounts.isActive, true)))
                                         .limit(1);
                  if(parent.length === 0) {
                     throw new ApiError(400, `Parent account ID ${accountData.parentId} not found or inactive for client ${accountData.clientId}.`);
                  }
              }

             const dataToInsert = {
                 ...accountData,
                 isActive: true, // Default to active
                 description: accountData.description ?? '',
                 isFolder: accountData.isFolder ?? false,
                 isSystemAccount: accountData.isSystemAccount ?? false,
                 // Ensure createdAt/updatedAt are handled by DB defaults or set here if needed
             };

             const [result] = await db.insert(accounts).values(dataToInsert).returning();
             if (!result) throw new Error("Account creation failed in DB.");
             return result;
           } catch (error) {
              if (error instanceof ApiError) throw error;
              // Check for unique constraint violation (specific to PostgreSQL error code '23505')
              if (error instanceof Error && (error as any).code === '23505') {
                 // Extract constraint name if possible to be more specific
                  const constraintMatch = error.message.match(/constraint "([^"]+)"/);
                  if (constraintMatch && constraintMatch[1].includes('account_code_client_id')) {
                      throw new ApiError(409, `Account code '${accountData.accountCode}' already exists for this client.`);
                  }
              }
             throw handleDbError(error, "creating account");
         }
    }

    async updateAccount(accountId: number, clientId: number, accountData: Partial<Omit<Account, 'id' | 'clientId' | 'isActive' | 'createdAt' | 'updatedAt'>>): Promise<Account | null> {
        console.log(`Updating account ${accountId} for client ${clientId}`);
         try {
              if (accountData.parentId === accountId) {
                  throw new ApiError(400,"Account cannot be its own parent.");
              }
               if (accountData.parentId !== undefined && accountData.parentId !== null) {
                   const parent = await db.select({id: accounts.id})
                                          .from(accounts)
                                          .where(and(eq(accounts.id, accountData.parentId), eq(accounts.clientId, clientId), eq(accounts.isActive, true)))
                                          .limit(1);
                   if(parent.length === 0) {
                      throw new ApiError(400, `New parent account ID ${accountData.parentId} not found or inactive for client ${clientId}.`);
                   }
               }

             const updatePayload = { ...accountData, updatedAt: new Date() };

             const [result] = await db.update(accounts)
                                    .set(updatePayload)
                                    .where(and(eq(accounts.id, accountId), eq(accounts.clientId, clientId), eq(accounts.isActive, true))) // Can only update active accounts
                                    .returning();
             return result ?? null;
           } catch (error) {
             if (error instanceof ApiError) throw error;
             if (error instanceof Error && (error as any).code === '23505') {
                const constraintMatch = error.message.match(/constraint "([^"]+)"/);
                 if (constraintMatch && constraintMatch[1].includes('account_code_client_id')) {
                    throw new ApiError(409, `Account code '${accountData.accountCode}' already exists for this client.`);
                }
            }
            throw handleDbError(error, `updating account ${accountId}`);
         }
    }

    async accountHasTransactions(id: number): Promise<boolean> {
         const [result] = await db
           .select({ count: count() })
           .from(journalEntryLines)
           .where(eq(journalEntryLines.accountId, id))
           .limit(1); // Optimization: only need to know if count > 0

         return (result?.count ?? 0) > 0;
    }


    async deleteAccount(accountId: number, clientId: number): Promise<boolean> {
        // Soft delete by setting isActive = false
        console.warn(`Soft deleting account ${accountId} for client ${clientId}`);
        try {
            return await db.transaction(async (tx) => {
                const account = await tx.select({ id: accounts.id, isFolder: accounts.isFolder })
                                        .from(accounts)
                                        .where(and(eq(accounts.id, accountId), eq(accounts.clientId, clientId), eq(accounts.isActive, true)))
                                        .limit(1);

                if (account.length === 0) return false;

                const activeChildren = await tx.select({ id: accounts.id })
                                                .from(accounts)
                                                .where(and(eq(accounts.parentId, accountId), eq(accounts.isActive, true)))
                                                .limit(1);
                if (activeChildren.length > 0) {
                    throw new ApiError(400, "Cannot deactivate an account with active child accounts. Deactivate children first.");
                }

                const hasTransactions = await this.accountHasTransactions(accountId);
                if (hasTransactions) {
                    throw new ApiError(400, "Cannot deactivate an account that has associated journal entries.");
                }

                const result = await tx.update(accounts)
                                      .set({ isActive: false, updatedAt: new Date() })
                                      .where(eq(accounts.id, accountId))
                                      .returning({ id: accounts.id });

                return result.length > 0;
            });
        } catch (error) {
             if (error instanceof ApiError) throw error;
            throw handleDbError(error, `deleting account ${accountId} (soft)`);
        }
    }

    // --- CoA Import/Export ---
     async importCoaForClient(clientId: number, fileBuffer: Buffer, fileName: string, selections?: any | null): Promise<{ success: boolean; message: string; results?: any; errors: string[]; warnings: string[] }> {
         // Implementation copied and adapted from DatabaseStorage in original storage.ts
         console.log(`Starting CoA import for client ${clientId}`);
         const result: { success: boolean; message: string; results?: any; errors: string[]; warnings: string[] } = {
            success: false, message: "", results: { inserted: 0, updated: 0, unchanged: 0, deactivated: 0, skipped: 0, deleted: 0, processed: 0 }, errors: [], warnings: []
         };

         try {
             let rows: any[] = [];
             const isExcel = fileName && (fileName.endsWith('.xlsx') || fileName.endsWith('.xls'));

             if (isExcel) {
                  const XLSX = await import('xlsx');
                  const workbook = XLSX.read(fileBuffer, { type: 'buffer' });
                  const sheetName = workbook.SheetNames[0];
                  const worksheet = workbook.Sheets[sheetName];
                  const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, dateNF: 'yyyy-mm-dd' }); // Keep raw=false for type inference, adjust dateNF if needed
                  if (jsonData.length < 2) throw new Error('Excel file is empty or missing header row');
                 const headers = (jsonData[0] as string[]).map(h => this.getCaseInsensitiveValue({header: h}, 'header'));
                 rows = jsonData.slice(1).map(row => {
                     const rowData: any = {};
                     (row as any[]).forEach((cell, index) => { if (headers[index]) rowData[headers[index]] = cell; });
                     return rowData;
                 });
             } else { // Assume CSV
                 const Papa = await import('papaparse');
                 const csvContent = fileBuffer.toString('utf-8');
                 const parseResult = Papa.default.parse(csvContent, { header: true, skipEmptyLines: true, transformHeader: (h: string) => this.getCaseInsensitiveValue({header: h}, 'header')});
                 if (parseResult.errors.length > 0) throw new Error(`CSV parsing error: ${parseResult.errors[0].message}`);
                 rows = parseResult.data as any[];
             }
              if (rows.length === 0) throw new Error("No data rows found in file.");


              return await db.transaction(async (tx) => {
                  const existingAccounts = await tx.select().from(accounts).where(eq(accounts.clientId, clientId));
                  const existingCodeMap = new Map(existingAccounts.map(acc => [acc.accountCode.toLowerCase(), acc]));
                  const existingIdMap = new Map(existingAccounts.map(acc => [acc.id, acc]));
                  const codeToIdMap = new Map(existingAccounts.map(acc => [acc.accountCode.toLowerCase(), acc.id]));

                  const accountsWithTransactions = new Set<number>();
                  if (existingAccounts.length > 0) { /* ... populate set ... */ } // Populate as before

                  const accountsToInsert: InsertAccount[] = [];
                  const accountsToUpdate: { id: number, data: Partial<Account> }[] = [];
                  const importedCodes = new Set<string>();
                  const parentLinkUpdates: { accountId: number, parentCode: string }[] = [];

                  for (const row of rows) {
                    result.results.processed++;
                    const code = this.getCaseInsensitiveValue(row, 'accountCode');
                    const name = this.getCaseInsensitiveValue(row, 'name');
                    const typeRaw = this.getCaseInsensitiveValue(row, 'type');

                    if (!code || !name || !typeRaw) { result.skipped++; result.errors.push(`Row ${result.results.processed}: Skipped: Missing required fields (code, name, type).`); continue; }

                    const lowerCode = String(code).toLowerCase().trim(); // Ensure string and trim
                     if (!lowerCode) { result.skipped++; result.errors.push(`Row ${result.results.processed}: Skipped: Account code cannot be empty.`); continue; }

                    if (importedCodes.has(lowerCode)) { result.skipped++; result.warnings.push(`Row ${result.results.processed}: Duplicate account code in import: ${code}. Skipping subsequent entries.`); continue; }
                    importedCodes.add(lowerCode);

                    let type: AccountType;
                    try { type = this.normalizeAccountType(typeRaw); } catch (e) { result.skipped++; result.errors.push(`Row <span class="math-inline">\{result\.results\.processed\}\: Skipped\: Invalid type '</span>{typeRaw}' for code '${code}'.`); continue; }

                    const existing = existingCodeMap.get(lowerCode);
                    const parentCode = this.getParentCode(row);
                    const isActive = this.parseBooleanFlag(this.getCaseInsensitiveValue(row, 'active'), true);

                    // Prepare data common to insert and update
                    const accountDataBase: Partial<Omit<Account, 'id' | 'clientId' | 'parentId' | 'createdAt' | 'updatedAt'>> = {
                        name: String(name).trim(), // Ensure string and trim
                        type: type,
                        subtype: this.getCaseInsensitiveValue(row, 'subtype'),
                        isSubledger: this.parseBooleanFlag(this.getCaseInsensitiveValue(row, 'isSubledger')),
                        subledgerType: this.getSubledgerType(row),
                        description: this.getCaseInsensitiveValue(row, 'description'),
                        isActive: isActive,
                        fsliBucket: this.getCaseInsensitiveValue(row, 'fsliBucket'), // Added
                        internalReportingBucket: this.getCaseInsensitiveValue(row, 'internalReportingBucket'), // Added
                        isFolder: this.parseBooleanFlag(this.getCaseInsensitiveValue(row, 'isFolder')), // Added
                        isSystemAccount: this.parseBooleanFlag(this.getCaseInsensitiveValue(row, 'isSystemAccount')), // Added
                    };
                    // Remove null/undefined fields to prevent accidental overwrites
                    Object.keys(accountDataBase).forEach(key => (accountDataBase[key] === undefined || accountDataBase[key] === null) && delete accountDataBase[key]);


                    if (existing) { // Update logic
                         if (!isActive && existing.isActive) { // Deactivation attempt
                             // Check constraints before deactivating
                             // ... (checks for transactions, children - same as deleteAccount logic) ...
                              if (accountsWithTransactions.has(existing.id)) {
                                  result.warnings.push(`Account ${code} has transactions. Cannot deactivate via import. Keeping active.`);
                                  result.skipped++; continue;
                              }
                              const activeChildren = await tx.select({ id: accounts.id }).from(accounts).where(and(eq(accounts.parentId, existing.id), eq(accounts.isActive, true))).limit(1);
                              if (activeChildren.length > 0) {
                                   result.warnings.push(`Account ${code} has active children. Cannot deactivate via import. Keeping active.`);
                                   result.skipped++; continue;
                              }
                              accountsToUpdate.push({ id: existing.id, data: { isActive: false } });
                              result.results.updated++; // Still count as an update
                              result.results.deactivated++; // Specific counter
                              if (parentCode) parentLinkUpdates.push({ accountId: existing.id, parentCode });

                         } else if (isActive && !existing.isActive) { // Reactivation + Update other fields
                              accountsToUpdate.push({ id: existing.id, data: { ...accountDataBase, isActive: true } });
                              result.results.updated++;
                              if (parentCode) parentLinkUpdates.push({ accountId: existing.id, parentCode });
                         } else if (isActive) { // Standard update (only if active)
                               const changes: Partial<Account> = {};
                               let hasChanges = false;
                               for(const key of Object.keys(accountDataBase)) {
                                   if(accountDataBase[key] !== existing[key] && !(accountDataBase[key] === null && existing[key] === null)) {
                                       changes[key] = accountDataBase[key];
                                       hasChanges = true;
                                   }
                               }
                               // Also check if accountCode itself changed (case-insensitively matched, but might differ in case)
                               if(code !== existing.accountCode) {
                                  changes.accountCode = code;
                                  hasChanges = true;
                               }

                               if (hasChanges) {
                                    accountsToUpdate.push({ id: existing.id, data: changes });
                                    result.results.updated++;
                               } else {
                                   result.results.unchanged++;
                               }
                               if (parentCode) parentLinkUpdates.push({ accountId: existing.id, parentCode }); // Check parent link even if other fields unchanged
                         } else { // Already inactive and import says inactive
                            result.results.unchanged++;
                         }

                    } else { // Insert logic
                        const insertData: InsertAccount = {
                            clientId: clientId,
                            accountCode: code, // Use original case from file
                            parentId: null, // Set later
                            ...accountDataBase, // Add other fields
                            isActive: isActive
                        };
                        accountsToInsert.push(insertData);
                        result.results.added++;
                        // Use placeholder ID for parent link update
                        if (parentCode) parentLinkUpdates.push({ accountId: -codeToIdMap.size - 1, parentCode: parentCode }); // Use temp negative ID based on map size
                        codeToIdMap.set(lowerCode, -codeToIdMap.size - 1); // Add temp ID to map immediately
                    }
                 }

                 // ==================== Batch Insert ====================
                 let tempIdToNewId = new Map<number, number>();
                 if (accountsToInsert.length > 0) {
                     console.log(`Inserting ${accountsToInsert.length} new accounts...`);
                     const inserted = await tx.insert(accounts).values(accountsToInsert).returning({ id: accounts.id, accountCode: accounts.accountCode });
                     inserted.forEach(acc => {
                         const tempId = codeToIdMap.get(acc.accountCode.toLowerCase()); // Get temp ID
                         if (tempId && tempId < 0) {
                             tempIdToNewId.set(tempId, acc.id); // Map temp ID to real DB ID
                         }
                         codeToIdMap.set(acc.accountCode.toLowerCase(), acc.id); // Update map with real DB ID
                     });
                     result.results.inserted = inserted.length;
                 }

                  // ==================== Batch Update ====================
                  if (accountsToUpdate.length > 0) {
                     console.log(`Updating ${accountsToUpdate.length} accounts...`);
                     let updatedCount = 0;
                     for (const update of accountsToUpdate) {
                         try {
                              const updateRes = await tx.update(accounts).set({...update.data, updatedAt: new Date()}).where(eq(accounts.id, update.id)).returning({id: accounts.id});
                              if(updateRes.length > 0) updatedCount++;
                         } catch (e) { result.errors.push(`Failed to update account ID ${update.id}: ${(e as Error).message}`); }
                     }
                     result.results.updated = Math.max(result.results.updated || 0, updatedCount); // Ensure we count updates accurately
                 }

                 // ==================== Update Parent Links ====================
                 if (parentLinkUpdates.length > 0) {
                     console.log(`Updating ${parentLinkUpdates.length} parent links...`);
                     let parentLinkSuccess = 0;
                     for (const link of parentLinkUpdates) {
                         let accountId = link.accountId;
                         if (accountId < 0) { // It was a temporary ID for a new account
                              accountId = tempIdToNewId.get(accountId) ?? -1; // Get the real DB ID
                          }
                          if (accountId < 0) { result.warnings.push(`Could not update parent link for new account (parent code ${link.parentCode}) as its final ID was not found.`); continue; }

                         const parentId = codeToIdMap.get(link.parentCode.toLowerCase());
                         if (parentId) {
                             if (accountId === parentId) { result.warnings.push(`Account with parent code ${link.parentCode} cannot be its own parent. Skipping link update.`); continue; }
                             try {
                                 await tx.update(accounts).set({ parentId: parentId, updatedAt: new Date() }).where(eq(accounts.id, accountId));
                                 parentLinkSuccess++;
                             } catch(e) { result.errors.push(`Failed parent link update for account ID ${accountId} -> parent ${link.parentCode}: ${(e as Error).message}`); }
                         } else { result.warnings.push(`Parent account code '${link.parentCode}' not found for account ID ${accountId}.`); }
                     }
                     console.log(`Successfully processed ${parentLinkSuccess} parent links.`);
                 }

                 // ==================== Handle Deactivation of Missing Accounts ====================
                 const accountsToDeactivate = existingAccounts.filter(acc => acc.isActive && !importedCodes.has(acc.accountCode.toLowerCase()));
                 if(accountsToDeactivate.length > 0) { /* ... Deactivation logic as before ... */
                     console.log(`Processing ${accountsToDeactivate.length} accounts not in import file...`);
                     let deactivatedCount = 0;
                     for (const acc of accountsToDeactivate) {
                         if (accountsWithTransactions.has(acc.id)) { result.warnings.push(`Account ${acc.accountCode} has transactions and was not in import; keeping active.`); continue; }
                         const activeChildren = await tx.select({ id: accounts.id }).from(accounts).where(and(eq(accounts.parentId, acc.id), eq(accounts.isActive, true))).limit(1);
                         if (activeChildren.length > 0) { result.warnings.push(`Account ${acc.accountCode} has active children and was not in import; keeping active.`); continue; }
                         try {
                             await tx.update(accounts).set({ isActive: false, updatedAt: new Date() }).where(eq(accounts.id, acc.id));
                             deactivatedCount++;
                         } catch (e) { result.errors.push(`Failed to deactivate account ${acc.accountCode}: ${(e as Error).message}`); }
                     }
                     result.results.deactivated = deactivatedCount;
                     console.log(`Deactivated ${deactivatedCount} accounts.`);
                 }

                  // ==================== Finalize ====================
                  result.success = result.errors.length === 0;
                  result.message = `Import finished. Processed: ${result.results.processed}, Added: ${result.results.inserted}, Updated: ${result.results.updated}, Unchanged: ${result.results.unchanged}, Deactivated: ${result.results.deactivated}, Skipped: ${result.skipped}. Errors: ${result.errors.length}, Warnings: ${result.warnings.length}.`;
                  if (result.errors.length > 0) {
                     console.error("Import Errors:", result.errors);
                     throw new ApiError(400, `Import failed with ${result.errors.length} errors. See warnings for details. Errors: ${result.errors.join('; ')}`);
                  }
                  if(result.warnings.length > 0) console.warn("Import Warnings:", result.warnings);

                 return result;
             });
        } catch (error: any) {
            console.error(`Error importing CoA for client ${clientId}:`, error);
            result.success = false;
            result.message = `Import failed: ${error.message}`;
             if (error instanceof ApiError) {
                 result.errors = [error.message, ...result.errors]; // Prepend specific error
             } else {
                 result.errors.push(error.message);
             }
            // Throw the error to ensure transaction rollback
            throw error;
        }
    }

    async exportCoaForClient(clientId: number): Promise<any[]> {
        console.log(`Exporting CoA for client ${clientId}`);
         try {
             const accountsToExport = await db.select({
                 accountCode: accounts.accountCode,
                 name: accounts.name,
                 type: accounts.type,
                 subtype: accounts.subtype,
                 parentId: accounts.parentId,
                 fsliBucket: accounts.fsliBucket,
                 internalReportingBucket: accounts.internalReportingBucket,
                 isFolder: accounts.isFolder,
                 description: accounts.description,
                 isSystemAccount: accounts.isSystemAccount,
                 isActive: accounts.isActive,
                 isSubledger: accounts.isSubledger,
                 subledgerType: accounts.subledgerType,
                 id: accounts.id
             })
             .from(accounts)
             .where(eq(accounts.clientId, clientId))
             // Export ALL accounts (active and inactive) by default for full backup/restore capability
             // .where(and(eq(accounts.clientId, clientId), eq(accounts.isActive, true))) // Optionally filter only active
             .orderBy(accounts.accountCode);

             const accountMap = new Map(accountsToExport.map(acc => [acc.id, acc.accountCode]));
             return accountsToExport.map(acc => {
                 const { id, parentId, isActive, ...rest } = acc; // Exclude internal ID, handle parentId and isActive
                 return {
                     ...rest,
                     parentCode: parentId ? accountMap.get(parentId) : '', // Map to parentCode
                     active: isActive ? 'Yes' : 'No' // Convert boolean to Yes/No for export
                 };
             });
           } catch (error) {
            throw handleDbError(error, `exporting CoA for client ${clientId}`);
        }
    }
}

// Export an instance
export const accountStorage = new AccountStorage();

Action: Modify server/storage.ts:

Open CodeShare/server/storage.ts.
DELETE the following method definitions from the IStorage interface:
seedClientCoA
getAccountsByClientId
getAccountsTree
createAccount
getAccountById (or getAccount)
updateAccount
deleteAccount
importCoaForClient
exportCoaForClient
accountHasTransactions
DELETE the corresponding method implementations from both the DatabaseStorage class and the MemStorage class. Be careful to remove the entire method body for each.
Action: Modify server/accountRoutes.ts:

Open CodeShare/server/accountRoutes.ts.
REMOVE the line importing the monolithic storage:
TypeScript

// Remove this line (or similar)
import { storage } from './storage';
ADD an import for the new accountStorage instance (adjust path as necessary):
TypeScript

// Add this line
import { accountStorage } from './storage/accountStorage';
FIND & REPLACE: Replace all occurrences of storage. used to call an Account method with accountStorage.. Examples:
storage.getAccountsTree(...) becomes accountStorage.getAccountsTree(...)
storage.createAccount(...) becomes accountStorage.createAccount(...)
storage.updateAccount(...) becomes accountStorage.updateAccount(...)
storage.deleteAccount(...) becomes accountStorage.deleteAccount(...)
storage.importCoaForClient(...) becomes accountStorage.importCoaForClient(...)
storage.exportCoaForClient(...) becomes accountStorage.exportCoaForClient(...)
Action: Verify Application Startup:

Restart the application server (npm run dev).
Confirm the server starts without errors related to missing functions or incorrect imports in storage.ts or accountRoutes.ts.
Verification:

New file server/storage/accountStorage.ts exists and contains only Account-related storage logic/interface.
The original server/storage.ts no longer contains Account storage logic/interface methods.
server/accountRoutes.ts imports from and uses accountStorage.
The application server starts successfully.
Reporting:

Confirm creation of server/storage/accountStorage.ts.
Confirm removal of Account logic from server/storage.ts.
Confirm update of imports/calls in server/accountRoutes.ts.
Report PASS/FAIL for server startup verification.
State readiness to refactor the next domain (e.g., Journal Entries).