Mission 1 (Revised): Fix Critical Data Persistence
Justification: Issues #5, #7, #9, and #12 represent a complete failure of the system's ability to reliably store data. Nothing else matters until this is fixed. This is our only priority right now.

Agent, your instructions are as follows. Execute them precisely.

1. Fix Attachment Data Retrieval (Issues #5 & #9):

Analysis: The root cause is a backend bug. The getJournalEntry function in journalEntryStorage.ts fetches the attachment records from the database but fails to include them in the final object that is sent to the frontend.

Action: You are to replace the entire getJournalEntry function with the corrected version below. This version ensures the fetched files array is correctly attached to the final result object.

File: server/storage/journalEntryStorage.ts

Replace the existing getJournalEntry function with this exact code:

TypeScript

async getJournalEntry(id: number, includeLines: boolean = true, includeFiles: boolean = true): Promise<JournalEntry | undefined> {
  try {
    const [entry] = await db.select().from(journalEntries).where(eq(journalEntries.id, id));

    if (entry) {
      const lines = includeLines ? await this.getJournalEntryLines(id) : [];
      let files: any[] = []; // Initialize files array

      if (includeFiles) {
        console.log(`ARCHITECT_DEBUG: Manually fetching files for entry ID: ${id}`);
        // Assign fetched files to the local 'files' variable
        files = await db.query.journalEntryFiles.findMany({
            where: (files, { eq, and }) => and(
                eq(files.journalEntryId, id),
                isNull(files.deletedAt) // Ensure we don't load deleted files
            )
        });
        console.log(`ARCHITECT_DEBUG: Attached ${files.length} files.`);
      }

      // Construct the final result object, ensuring the 'files' array is included
      const result = {
        ...entry,
        lines: lines || [],
        files: files || []
      } as JournalEntry & {
        lines: JournalEntryLine[],
        files: any[]
      };

      return result;
    }
    return undefined;
  } catch (e) {
    throw handleDbError(e, `getting journal entry ${id}`);
  }
}
2. Fix Date-Shifting Bug (Issues #7 & #12):

Analysis: The date changes because of a classic timezone handling error on the server. The code unnecessarily converts a clean 'yyyy-MM-dd' string into a Date object, which introduces timezone shifts. The fix is to trust the date string sent from the client and pass it directly to the database.

Action: You are to modify the updateJournalEntryWithLines function to prevent this faulty conversion.

File: server/storage/journalEntryStorage.ts

Function: updateJournalEntryWithLines

Inside this function, find and replace the following code block:

From this:

TypeScript

if (entryData.date !== undefined) {
  const formattedDate = typeof entryData.date === 'string'
    ? entryData.date
    : format(new Date(entryData.date), 'yyyy-MM-dd');

  updatedEntryData.date = formattedDate;
}
To this:

TypeScript

if (entryData.date !== undefined) {
    // The frontend sends a 'yyyy-MM-dd' string. Trust it and pass it directly.
    // This prevents timezone conversion errors.
    updatedEntryData.date = entryData.date;
}
After you have executed these two instructions precisely, run the verification tests I specified earlier (jeAttachment.test.ts and jeDate.test.ts) and report the results. We will not move on to issue #4 or any other bug until these critical data integrity failures are confirmed to be resolved.