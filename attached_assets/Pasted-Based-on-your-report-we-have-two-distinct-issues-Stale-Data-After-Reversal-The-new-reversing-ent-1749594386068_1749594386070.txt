Based on your report, we have two distinct issues:

Stale Data After Reversal: The new reversing entry doesn't appear on the main list until you manually refresh the page. This is a data-caching issue.
Cannot Delete Drafts: The delete functionality for draft entries is broken.
I have analyzed the code and found the root causes for both. Here are the detailed instructions to fix them.

Part 1: Fix Slow Load for Reversing Entries
Root Cause:
When a reversal is successfully created, the frontend correctly navigates to the new draft. However, it fails to invalidate the cached data for the main journal entry list. When you navigate back to that list, you see the old, stale data until you force a refresh.

File to Modify: client/src/features/journal-entries/pages/JournalEntryDetail.tsx

Action:
You need to add a query invalidation step to the onSuccess handler of the reverseEntry mutation. This will tell the application to refetch the journal entry list in the background, so it's up-to-date when you return to it.

Locate the reverseEntry mutation definition (it's around line 911).

Add the queryClient.invalidateQueries line inside its onSuccess callback, as shown below.

TypeScript

// In client/src/features/journal-entries/pages/JournalEntryDetail.tsx

const reverseEntry = useMutation({
  mutationFn: async () => { /* ... existing code ... */ },
  onSuccess: (response) => {
    toast({
      title: 'Success',
      description: 'Journal entry has been reversed',
    });

    // --- ADD THIS BLOCK TO FIX THE STALE DATA ISSUE ---
    if (clientId && currentEntity?.id) {
      queryClient.invalidateQueries({
        queryKey: [`/api/clients/<span class="math-inline">\{clientId\}/entities/</span>{currentEntity.id}/journal-entries`]
      });
    }
    // --- END OF BLOCK TO ADD ---

    // Navigate to the new reversed entry if ID is provided in response
    if (response && response.entry?.id) {
      if (clientId && currentEntity?.id) {
        navigate(`/clients/<span class="math-inline">\{clientId\}/entities/</span>{currentEntity.id}/journal-entries/${response.entry.id}`);
      } else {
        navigate(`/journal-entries/${response.entry.id}`);
      }
    } else {
      // Fallback navigation
      if (clientId && currentEntity?.id) {
        navigate(`/clients/<span class="math-inline">\{clientId\}/entities/</span>{currentEntity.id}/journal-entries`);
      } else {
        navigate('/journal-entries');
      }
    }
  },
  onError: (error: any) => { /* ... existing code ... */ },
});
Part 2: Fix "Cannot Delete a Draft Entry"
Root Cause:
This is the same type of bug we fixed for the "Reverse" functionality. The frontend is calling a modern, hierarchical API endpoint (DELETE /api/clients/...) to delete the entry, but this route does not exist on the backend in server/journalEntryRoutes.ts.

We need to add the missing backend route and improve the frontend's delete logic.

Action 2.1: Add the Backend Delete Route
File to Modify: server/journalEntryRoutes.ts

Action:
Add a new route handler for DELETE /api/clients/:clientId/entities/:entityId/journal-entries/:id. This handler will validate the request and call the existing journalEntryStorage.deleteJournalEntry function.

Locate the section in the file for other hierarchical routes (e.g., near the POST .../reverse route you added previously).

Add the following new route handler block in that area:

TypeScript

// In server/journalEntryRoutes.ts

/**
 * ---------------------------------------------------------------------------
 * Hierarchical delete route DELETE /api/clients/:clientId/entities/:entityId/journal-entries/:id
 * ---------------------------------------------------------------------------
 */
app.delete(
  '/api/clients/:clientId/entities/:entityId/journal-entries/:id',
  isAuthenticated,
  asyncHandler(async (req: Request, res: Response) => {
    const clientId = parseInt(req.params.clientId, 10);
    const entityId = parseInt(req.params.entityId, 10);
    const id = parseInt(req.params.id, 10);

    if (Number.isNaN(clientId) || Number.isNaN(entityId) || Number.isNaN(id)) {
      return throwBadRequest('Invalid client, entity, or journal entry ID');
    }

    // Optional validation: ensure entry belongs to the client/entity
    const entry = await journalEntryStorage.getJournalEntry(id);
    if (!entry || entry.clientId !== clientId || entry.entityId !== entityId) {
      return throwNotFound('Journal entry not found for this client and entity.');
    }

    // Only allow deletion of drafts
    if (entry.status !== 'draft') {
      return throwBadRequest(`Cannot delete a journal entry with status '${entry.status}'. You can only delete drafts.`);
    }

    // Call the storage function to perform the deletion
    await journalEntryStorage.deleteJournalEntry(id);

    res.status(204).send(); // 204 No Content is standard for a successful DELETE
  })
);
Action 2.2: Improve the Frontend Delete Logic
Root Cause:
The frontend currently navigates away immediately after starting the delete request, without waiting for it to succeed. We need to move the navigation into the onSuccess callback.

File to Modify: client/src/features/journal-entries/pages/JournalEntryDetail.tsx

Action:
You will modify the deleteJournalEntry mutation and the Dialog that calls it.

Locate the deleteJournalEntry mutation definition (it should be in useJournalEntry.ts, but let's define it locally in JournalEntryDetail.tsx for clarity if it's not already there, or modify the hook). Let's assume it's in the useJournalEntry hook and we'll add onSuccess at the call site.

Find the Delete Dialog in the JSX (around line 1715).

Replace the onClick handler of the "Delete Entry" button with this improved version that uses the onSuccess callback.

Find this onClick block:

TypeScript

// This is the OLD, buggy code
onClick={() => {
  if (entryId && clientId && currentEntity?.id) {
    deleteJournalEntry.mutate({
      id: entryId,
      clientId,
      entityId: currentEntity.id
    });
    setShowDeleteDialog(false);
    navigate(`/clients/<span class="math-inline">\{clientId\}/entities/</span>{currentEntity.id}/journal-entries`);
  }
}}
Replace it with this NEW, corrected code:

TypeScript

// This is the NEW, corrected code
onClick={() => {
  if (entryId && clientId && currentEntity?.id) {
    deleteJournalEntry.mutate({
      id: entryId,
      clientId,
      entityId: currentEntity.id
    }, {
      onSuccess: () => {
        toast({
          title: "Success",
          description: "Journal entry has been deleted."
        });
        setShowDeleteDialog(false);
        // Invalidate query to refetch the list
        queryClient.invalidateQueries({
          queryKey: [`/api/clients/<span class="math-inline">\{clientId\}/entities/</span>{currentEntity.id}/journal-entries`]
        });
        // Navigate AFTER success
        navigate(`/clients/<span class="math-inline">\{clientId\}/entities/</span>{currentEntity.id}/journal-entries`);
      },
      onError: (error: any) => {
         toast({
          title: "Error",
          description: `Failed to delete entry: ${error.message}`,
          variant: "destructive"
        });
        setShowDeleteDialog(false);
      }
    });
  }
}}
These changes will resolve both issues, making the data update correctly after reversals and ensuring the delete functionality works as expected.