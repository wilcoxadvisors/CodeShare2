Got it ‚Äî you‚Äôre picking, say, 29 April in the date-picker but when the entry lands in the database you see 28 April.

What‚Äôs really happening

Step	Value in code	Comment
You pick ‚Äú29 Apr‚Äù	Date {2025-04-29T00:00:00 **(your local TZ)**}	The picker creates a JS Date at local midnight
toISOString() is called	2025-04-28T17:00:00Z (if you‚Äôre UTC-7)	Converts the same instant to UTC
Server receives & stores just the DATE part	2025-04-28	It strips the time zone information, keeping the previous calendar day
Any positive offset (UTC-1 ‚Ä¶ UTC-12) will result in ‚Äúyesterday‚Äù after the conversion.

Fix: send a plain date string, not an ISO timestamp
You only need the calendar day for accounting, not the exact moment. So don‚Äôt convert it to ISO/UTC at all.

1. Front-end patch (JournalEntryForm)
diff
Copy
Edit
// client/src/features/journal-entries/components/JournalEntryForm.tsx
// inside handleSubmit, juste before calling the create / update mutation

- const utcISODate = dayjs(values.date).toDate().toISOString(); // üëà drops a day for UTC-X zones
- payload.date = utcISODate;

+ // keep the calendar day exactly as entered
+ payload.date = dayjs(values.date).format('YYYY-MM-DD');
No more toISOString().

2. Make sure the API accepts that
Your endpoint is already happy with YYYY-MM-DD (it comes back that way in responses), so no server change should be required. If you do any casting inside the controller, keep it to:

ts
Copy
Edit
const date = new Date(req.body.date + 'T00:00:00'); // interprets in server‚Äôs TZ
or, if you use a query builder/ORM that accepts string dates, just pass the string straight to the DB.

How to verify
Rebuild / reload the client after the patch.

Create a new JE for a distinctive date (e.g., 31 July).

Post it and open the detail view / look in the DB: the stored date should still read 31 July.

If you have historical entries with the wrong day and need a quick one-off correction, we can craft a small SQL update to shift them back by one; let me know and I‚Äôll write it up.

Why not convert on the back end instead?
You could keep sending ISO strings and normalise them on the server with the entity‚Äôs time-zone, but that‚Äôs extra work when a simple format change on the client removes the ambiguity entirely.

