Excellent. Thank you for the clarification, and my sincere apologies for misinterpreting your last message. I understand now: the crash is fixed, and you are giving me the new requirements to make the feature fully usable.

That is great news. I will now provide the instructions to implement the user-facing features you've described.

Based on your request, we need to:

Ensure multiple, unique dimension tags can be added to each line.
Visibly display the selected tags on the line item.
Provide a clear way for a user to remove a tag.
My previous analysis of the usability bugs (invisible selection, single tag issue) pointed to a fundamental flaw in how the component was being rendered, which I will now instruct the agent to fix. The following three-part plan will solve those underlying bugs and simultaneously build the new UI you have requested.

Architect's Instruction for the Replit AI Agent
Status Update: The UI crash has been resolved. The new task is to overhaul the dimension tagging UI to meet the user's requirements for full functionality.

New Requirements:

Fix the bug that prevents adding more than one dimension tag to a line.
Fix the bug where the selected value is not visible after selection.
Display all selected tags for a line item clearly in the UI.
Provide a button to remove each individual tag.
Root Cause of Usability Bugs: The core issue is the use of an unstable index as the key prop when rendering journal entry lines. This causes incorrect UI updates when the state changes, leading to the visibility and multi-tag bugs.

You will now execute a definitive, three-part overhaul of the feature.

File to Modify: client/src/features/journal-entries/components/JournalEntryForm.tsx
Part 1: Implement Stable React Keys (The Core Bug Fix)
Action: You will assign a unique, stable key to each journal entry line. This is the most critical step to ensure React updates the UI correctly and fixes the visibility/multi-tag bugs.

Import uuidv4: At the top of the file, ensure this import is present:

TypeScript

import { v4 as uuidv4 } from "uuid";
Update JournalLine Interface: Add a unique key property.

Find: interface JournalLine { ... }
Add: _key?: string;
Update lines State Initialization: Give every line a unique key.

Replace the entire useState hook for lines with this:
TypeScript

const [lines, setLines] = useState<JournalLine[]>(
  (existingEntry?.lines?.map((line: any) => ({ ...line, _key: uuidv4() })) || [
    { _key: uuidv4(), accountId: "", entityCode: defaultEntityCode, description: "", debit: "", credit: "" },
    { _key: uuidv4(), accountId: "", entityCode: defaultEntityCode, description: "", debit: "", credit: "" },
  ])
);
Update addLine Function: Ensure newly added lines get a unique key.

Replace the addLine function with this:
TypeScript

const addLine = () => {
  setLines([
    ...lines,
    { _key: uuidv4(), accountId: "", entityCode: defaultEntityCode, description: "", debit: "", credit: "" },
  ]);
};
Update the JSX key Prop: In the <tbody>, find the <tr> element.

Change: <tr key={index}>
To: <tr key={line._key || line.id || index}>
Part 2: Implement the New UI for Displaying and Removing Tags
Action: You will redesign the "Tags" table column to display selected tags as removable badges, fulfilling the user's central request.

Create the handleRemoveTag Function: Inside the JournalEntryForm component (before the return statement), add this new function. It will power the "remove" button for each tag.

TypeScript

const handleRemoveTag = (lineIndex: number, dimensionIdToRemove: number) => {
  const line = lines[lineIndex];
  if (!line || !line.tags) return;
  const newTags = line.tags.filter(tag => tag.dimensionId !== dimensionIdToRemove);
  updateLineTags(lineIndex, newTags);
};
Replace the "Tags" Column UI:

In the table body (<tbody>), find the <td> element for the "Tags" column (the one containing the Popover).
Replace the entire content of that <td> with the following new JSX. This creates the badge display area and a cleaner "add" button.
TypeScript

<td className="px-6 py-4 whitespace-nowrap">
  <div className="flex items-center gap-2">
    <div className="flex flex-wrap items-center gap-1">
      {line.tags?.map((tag) => (
        <Badge key={tag.dimensionId} variant="secondary" className="flex items-center gap-1.5 pl-2 pr-1 py-1">
          <span className="text-xs font-medium">{tag.dimensionName?.substring(0, 4)}: {tag.dimensionValueName}</span>
          <button
            type="button"
            className="rounded-full hover:bg-muted-foreground/20 p-0.5"
            aria-label={`Remove ${tag.dimensionName} tag`}
            onClick={() => handleRemoveTag(index, tag.dimensionId)}
          >
            <X className="h-3 w-3" />
          </button>
        </Badge>
      ))}
    </div>
    <Popover open={tagPopoverOpen[index] || false} onOpenChange={(open) => toggleTagPopover(index, open)}>
      <PopoverTrigger asChild>
        <Button variant="ghost" size="icon" className="h-7 w-7 flex-shrink-0">
          <Plus className="h-4 w-4" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-4">
        <div className="space-y-4">
          <h4 className="font-medium text-sm">Dimension Tags</h4>
          {dimensions.filter(dim => dim.isActive).map((dimension) => (
            <div key={dimension.id} className="space-y-2">
              <Label className="text-xs font-medium text-gray-700">
                {dimension.name}
              </Label>
              <Select
                value={line.tags?.find(tag => tag.dimensionId === dimension.id)?.dimensionValueId?.toString() || "none"}
                onValueChange={(valueId) => {
                  const currentTags = line.tags || [];
                  let newTags = [...currentTags];
                  if (valueId === "none") {
                    newTags = newTags.filter(tag => tag.dimensionId !== dimension.id);
                  } else {
                    const selectedValue = dimension.values?.find(v => v.id.toString() === valueId);
                    if (selectedValue) {
                      newTags = newTags.filter(tag => tag.dimensionId !== dimension.id);
                      newTags.push({
                        dimensionId: dimension.id,
                        dimensionValueId: selectedValue.id,
                        dimensionName: dimension.name,
                        dimensionValueName: selectedValue.name
                      });
                    }
                  }
                  updateLineTags(index, newTags);
                }}
              >
                <SelectTrigger className="w-full h-8">
                  <SelectValue placeholder="Select value..." />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="none">None</SelectItem>
                  {dimension.values
                    ?.filter(value => value && typeof value.id === 'number' && value.id > 0)
                    .filter(value => value.isActive)
                    .map((value) => (
                      <SelectItem key={value.id} value={String(value.id)}>
                        {value.name} ({value.code})
                      </SelectItem>
                    ))
                  }
                </SelectContent>
              </Select>
            </div>
          ))}
        </div>
      </PopoverContent>
    </Popover>
  </div>
</td>
Agent, this comprehensive overhaul directly implements the user's requests and fixes the underlying bugs preventing the feature from working. Execute this plan precisely.