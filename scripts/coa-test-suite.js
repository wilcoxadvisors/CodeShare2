/**
 * Comprehensive Chart of Accounts Import/Export Test Suite
 * 
 * This script performs end-to-end testing of the Chart of Accounts
 * import and export functionality, including CSV and Excel formats,
 * with detailed verification of data integrity and error handling.
 */

// Required libraries
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import FormData from 'form-data';
import Papa from 'papaparse';
import chalk from 'chalk';
import XLSX from 'xlsx';

// Get current file directory (equivalent to __dirname in CommonJS)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const BASE_URL = 'https://80550fad-9a85-4035-aa54-a26530837091-00-3hx3dcszn47es.janeway.replit.dev'; // Direct URL provided by user
const COOKIES_FILE = path.join(__dirname, '../curl_cookies.txt');
const TEMP_DIR = path.join(__dirname, '../tmp/coa-test');
const TEST_CLIENT_PREFIX = 'COA_TEST_';
const API_BASE = '/api/admin/clients';

// Track created clients for cleanup
const createdClients = [];

// Test results
const testResults = {
  passed: [],
  failed: []
};

/**
 * Helper function to read cookies from file and format for HTTP headers
 */
function getCookieHeader() {
  if (!fs.existsSync(COOKIES_FILE)) {
    throw new Error('No cookie file found. Please login first.');
  }
  
  // Read the cookie file content
  const cookieFileContent = fs.readFileSync(COOKIES_FILE, 'utf8');
  
  // Parse and clean the cookie content
  // Extract the cookie values in the format expected by HTTP headers
  const cookieLines = cookieFileContent.split('\n').filter(line => line.trim() !== '');
  const cookies = cookieLines
    .filter(line => !line.startsWith('#') && line.includes('='))
    .map(line => {
      // Extract just the name=value portion
      const matches = line.match(/(\S+)=([^;]*)/);
      if (matches && matches.length >= 3) {
        return `${matches[1]}=${matches[2]}`;
      }
      return null;
    })
    .filter(Boolean)
    .join('; ');
  
  return cookies;
}

/**
 * Ensure temporary directory exists
 */
function ensureTempDir() {
  if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
    console.log(chalk.blue(`Created temporary directory: ${TEMP_DIR}`));
  }
}

/**
 * Log test results in a consistent format
 */
function logResult(testName, success, message) {
  if (success) {
    console.log(chalk.green(`✓ PASS: ${testName} - ${message}`));
    testResults.passed.push({ name: testName, message });
    return true;
  } else {
    console.log(chalk.red(`✗ FAIL: ${testName} - ${message}`));
    testResults.failed.push({ name: testName, message });
    return false;
  }
}

/**
 * Login to get auth cookie
 */
async function login() {
  try {
    console.log(chalk.blue('Authenticating with admin credentials...'));
    
    // Always attempt to get a fresh cookie for a more reliable test
    // Remove old cookie file if it exists
    if (fs.existsSync(COOKIES_FILE)) {
      fs.unlinkSync(COOKIES_FILE);
      console.log(chalk.blue('Removed old cookie file'));
    }
    
    // Authenticate to get fresh cookies
    console.log(chalk.blue('Authenticating with server...'));
    const response = await axios.post(`${BASE_URL}/api/auth/login`, {
      username: 'admin',
      password: 'password123'
    }, {
      maxRedirects: 0,
      validateStatus: status => status >= 200 && status < 400
    });
    
    console.log(chalk.green('Authentication response status:', response.status));
    
    // Extract and save cookies
    const cookies = response.headers['set-cookie'];
    if (!cookies) {
      console.error(chalk.red('No cookies in response headers:', JSON.stringify(response.headers)));
      throw new Error('No cookies received from authentication');
    }
    
    // Extract the session cookie value
    const sessionCookie = cookies.find(cookie => cookie.includes('connect.sid='));
    if (!sessionCookie) {
      console.error(chalk.red('Available cookies:', cookies));
      throw new Error('Session cookie not found in authentication response');
    }
    
    // Format the cookie in Netscape format for curl
    const domain = new URL(BASE_URL).hostname;
    const path = '/';
    const secure = 'TRUE';
    const expiry = Math.floor(Date.now() / 1000) + 86400; // 24 hours from now
    
    // Extract cookie name and value
    const cookieMatch = sessionCookie.match(/^(connect\.sid)=([^;]*)/);
    if (!cookieMatch) {
      throw new Error('Failed to parse cookie value');
    }
    
    const cookieName = cookieMatch[1];
    const cookieValue = cookieMatch[2];
    
    // Format as Netscape cookie
    const netscapeCookie = `# Netscape HTTP Cookie File
# https://curl.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

#HttpOnly_${domain}\t${secure}\t${path}\t${secure}\t${expiry}\t${cookieName}\t${cookieValue}
`;
    
    // Save cookie to file
    fs.writeFileSync(COOKIES_FILE, netscapeCookie);
    console.log(chalk.green('Successfully authenticated and saved cookies'));
    
    // Verify user session by making a request to a protected endpoint
    const verifyResponse = await axios.get(`${BASE_URL}/api/users/me`, {
      headers: { Cookie: getCookieHeader() }
    });
    
    if (verifyResponse.data && verifyResponse.data.id) {
      console.log(chalk.green('Successfully verified authentication with user ID:', verifyResponse.data.id));
    } else {
      console.warn(chalk.yellow('Authentication succeeded but user data is incomplete:', JSON.stringify(verifyResponse.data)));
    }
    
    return getCookieHeader();
  } catch (error) {
    console.error(chalk.red('Authentication failed:'), error.message);
    if (error.response) {
      console.error(chalk.red('Server response status:'), error.response.status);
      console.error(chalk.red('Server response data:'), JSON.stringify(error.response.data, null, 2));
    }
    throw error;
  }
}

/**
 * Create a test client
 */
async function createTestClient() {
  try {
    const timestamp = Date.now();
    const testClientName = `${TEST_CLIENT_PREFIX}${timestamp}`;
    console.log(chalk.blue(`Creating test client: ${testClientName}`));
    
    const cookies = getCookieHeader();
    
    // First, get the current user's ID to use in client creation
    console.log(chalk.blue('Getting current user ID...'));
    let userId;
    try {
      const userResponse = await axios.get(`${BASE_URL}/api/users/me`, {
        headers: { Cookie: cookies }
      });
      
      console.log(chalk.blue('User response status:', userResponse.status));
      console.log(chalk.blue('Full user response data:', JSON.stringify(userResponse.data, null, 2)));
      
      // Check the nested response format
      let userData = userResponse.data;
      if (userResponse.data && userResponse.data.status === 'success' && userResponse.data.data) {
        userData = userResponse.data.data;
        console.log(chalk.blue('Detected nested response format, extracted data:', JSON.stringify(userData, null, 2)));
      }
      
      if (userData && userData.id) {
        userId = userData.id;
        console.log(chalk.green(`Found user ID: ${userId}`));
      } else {
        console.warn(chalk.yellow('Could not retrieve user ID from response, trying to find alternates'));
        
        // Try alternative approach - maybe it's in a different format
        if (typeof userResponse.data === 'object') {
          // Try to find any key that might be an ID
          const possibleIdKeys = Object.keys(userResponse.data).filter(key => 
            (key === 'id' || key === 'userId' || key === 'user_id' || key === '_id' || key === 'uid') && 
            userResponse.data[key] !== undefined
          );
          
          // Log all keys for debugging
          console.log(chalk.blue('All keys in response:', Object.keys(userResponse.data).join(', ')));
          
          if (possibleIdKeys.length > 0) {
            userId = userResponse.data[possibleIdKeys[0]];
            console.log(chalk.green(`Found user ID via alternative key '${possibleIdKeys[0]}': ${userId}`));
          } else {
            // Fallback to admin user ID 1 for testing
            userId = 1;
            console.warn(chalk.yellow('No ID found in response. Using default admin ID (1) for testing purposes.'));
          }
        } else {
          // Fallback to admin user ID 1 for testing
          userId = 1;
          console.warn(chalk.yellow('Response is not an object. Using default admin ID (1) for testing purposes.'));
        }
      }
    } catch (userError) {
      console.error(chalk.red('Failed to get user profile:'), userError.message);
      if (userError.response) {
        console.error(chalk.red('Server response status:'), userError.response.status);
        console.error(chalk.red('Server response data:'), JSON.stringify(userError.response.data, null, 2));
      }
      
      // Fallback to admin user ID 1 for testing
      userId = 1;
      console.warn(chalk.yellow('Exception during user ID retrieval. Using default admin ID (1) for testing purposes.'));
    }
    
    // Use the correct admin API endpoint for client creation
    const ADMIN_API_URL = '/api/admin/clients';
    
    // Create payload with userId
    const clientPayload = {
      name: testClientName,
      active: true,
      industry: 'ACCOUNTING',
      userId: userId  // Include the userId in the payload
    };
    
    // Log the request details for debugging
    console.log(chalk.blue('Request details:'));
    console.log(chalk.blue('URL:', `${BASE_URL}${ADMIN_API_URL}`));
    console.log(chalk.blue('Payload:', JSON.stringify(clientPayload, null, 2)));
    
    const response = await axios.post(
      `${BASE_URL}${ADMIN_API_URL}`, 
      clientPayload,
      {
        headers: {
          Cookie: cookies
        }
      }
    );
    
    // Log response details
    console.log(chalk.green('Response status:', response.status));
    console.log(chalk.green('Response data type:', typeof response.data));
    console.log(chalk.green('Response data:', JSON.stringify(response.data, null, 2)));
    
    // Handle the nested response format
    if (!response.data || !response.data.status || !response.data.data || !response.data.data.id) {
      throw new Error(`Failed to create test client. Response: ${JSON.stringify(response.data)}`);
    }
    
    const clientData = response.data.data;
    const clientId = clientData.id;
    console.log(chalk.green(`Created test client with ID: ${clientId}`));
    createdClients.push({ id: clientId, name: testClientName });
    
    return { id: clientId, name: testClientName };
  } catch (error) {
    console.error(chalk.red('Failed to create test client:'), error.message);
    if (error.response) {
      console.error(chalk.red('Response status:'), error.response.status);
      console.error(chalk.red('Server response:'), JSON.stringify(error.response.data, null, 2));
    }
    throw error;
  }
}

/**
 * Seed initial Chart of Accounts for a client
 */
async function seedInitialAccounts(clientId) {
  try {
    console.log(chalk.blue(`Seeding initial accounts for client ID: ${clientId}`));
    
    // Standard accounts for testing
    const standardAccounts = [
      // Assets (1000-1999)
      { code: '1000', name: 'Assets', type: 'ASSET', subtype: 'Asset', isSubledger: false, active: true, description: 'Asset accounts', parentCode: null },
      { code: '1100', name: 'Current Assets', type: 'ASSET', subtype: 'Current Asset', isSubledger: false, active: true, description: 'Current assets', parentCode: '1000' },
      { code: '1200', name: 'Cash', type: 'ASSET', subtype: 'Current Asset', isSubledger: false, active: true, description: 'Cash accounts', parentCode: '1100' },
      { code: '1201', name: 'Checking Account', type: 'ASSET', subtype: 'Current Asset', isSubledger: false, active: true, description: 'Primary checking account', parentCode: '1200' },
      { code: '1202', name: 'Savings Account', type: 'ASSET', subtype: 'Current Asset', isSubledger: false, active: true, description: 'Savings account', parentCode: '1200' },
      { code: '1300', name: 'Accounts Receivable', type: 'ASSET', subtype: 'Current Asset', isSubledger: true, subledgerType: 'CUSTOMER', active: true, description: 'Amounts owed by customers', parentCode: '1100' },
      { code: '1400', name: 'Inventory', type: 'ASSET', subtype: 'Current Asset', isSubledger: false, active: true, description: 'Inventory assets', parentCode: '1100' },
      { code: '1500', name: 'Fixed Assets', type: 'ASSET', subtype: 'Non-Current Asset', isSubledger: false, active: true, description: 'Long-term assets', parentCode: '1000' },
      { code: '1600', name: 'Equipment', type: 'ASSET', subtype: 'Non-Current Asset', isSubledger: false, active: true, description: 'Equipment owned', parentCode: '1500' },
      { code: '1700', name: 'Buildings', type: 'ASSET', subtype: 'Non-Current Asset', isSubledger: false, active: true, description: 'Buildings owned', parentCode: '1500' },
      
      // Liabilities (2000-2999)
      { code: '2000', name: 'Liabilities', type: 'LIABILITY', subtype: 'Liability', isSubledger: false, active: true, description: 'Liability accounts', parentCode: null },
      { code: '2100', name: 'Current Liabilities', type: 'LIABILITY', subtype: 'Current Liability', isSubledger: false, active: true, description: 'Current liabilities', parentCode: '2000' },
      { code: '2200', name: 'Accounts Payable', type: 'LIABILITY', subtype: 'Current Liability', isSubledger: true, subledgerType: 'VENDOR', active: true, description: 'Amounts owed to vendors', parentCode: '2100' },
      { code: '2300', name: 'Credit Cards', type: 'LIABILITY', subtype: 'Current Liability', isSubledger: false, active: true, description: 'Credit card balances', parentCode: '2100' },
      { code: '2400', name: 'Accrued Expenses', type: 'LIABILITY', subtype: 'Current Liability', isSubledger: false, active: true, description: 'Accrued expenses', parentCode: '2100' },
      { code: '2500', name: 'Long-term Liabilities', type: 'LIABILITY', subtype: 'Non-Current Liability', isSubledger: false, active: true, description: 'Long-term liabilities', parentCode: '2000' },
      { code: '2600', name: 'Loans Payable', type: 'LIABILITY', subtype: 'Non-Current Liability', isSubledger: false, active: true, description: 'Long-term loans', parentCode: '2500' },
      
      // Equity (3000-3999)
      { code: '3000', name: 'Equity', type: 'EQUITY', subtype: 'Equity', isSubledger: false, active: true, description: 'Equity accounts', parentCode: null },
      { code: '3100', name: 'Common Stock', type: 'EQUITY', subtype: 'Equity', isSubledger: false, active: true, description: 'Common stock issued', parentCode: '3000' },
      { code: '3200', name: 'Retained Earnings', type: 'EQUITY', subtype: 'Equity', isSubledger: false, active: true, description: 'Accumulated earnings', parentCode: '3000' },
      
      // Revenue (4000-4999)
      { code: '4000', name: 'Revenue', type: 'REVENUE', subtype: 'Revenue', isSubledger: false, active: true, description: 'Revenue accounts', parentCode: null },
      { code: '4100', name: 'Service Revenue', type: 'REVENUE', subtype: 'Operating Revenue', isSubledger: false, active: true, description: 'Revenue from services', parentCode: '4000' },
      { code: '4200', name: 'Product Sales', type: 'REVENUE', subtype: 'Operating Revenue', isSubledger: false, active: true, description: 'Revenue from product sales', parentCode: '4000' },
      { code: '4300', name: 'Other Revenue', type: 'REVENUE', subtype: 'Non-Operating Revenue', isSubledger: false, active: true, description: 'Other revenue sources', parentCode: '4000' },
      
      // Expenses (5000-5999)
      { code: '5000', name: 'Expenses', type: 'EXPENSE', subtype: 'Expense', isSubledger: false, active: true, description: 'Expense accounts', parentCode: null },
      { code: '5100', name: 'Operating Expenses', type: 'EXPENSE', subtype: 'Operating Expense', isSubledger: false, active: true, description: 'Operating expenses', parentCode: '5000' },
      { code: '5200', name: 'Payroll Expenses', type: 'EXPENSE', subtype: 'Operating Expense', isSubledger: false, active: true, description: 'Payroll-related expenses', parentCode: '5100' },
      { code: '5300', name: 'Rent Expense', type: 'EXPENSE'